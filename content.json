{"posts":[{"title":"ALGOA_CM1&amp;2","text":"ALGOA_CM1&amp;2Algorithmique avancée_CM1&amp;2 IntroductionPourquoi étudier l’algorithmique ? Résoudre plus facilement les problèmes (Problem solving) ; Ne pas réinventer[再次创作] la roue ; Produire des programmes : corrects, efficaces, et lisibles（可读性）. Pourquoi faire des programmes efficaces ? Pour optimiser l’utilisation des ressources : temps de calcul, mémoire, énergie. 下面是一个提高算法效率的例子（斐波那契） 123456789101112def fib1 (n): if n == 0 or n == 1: return 1 else : return fib1 (n=1) + fib1(n=2)def fib2 (n): x = 1 y = 1 for i = 2 to n: y = x + y#后两个数相加得第三个数 x = y - x#舍弃第一个数 return y Objectifs du cours • Prouver la correction de programmes ; • Analyser leur performance ; • Connaître et savoir utiliser les principales stratégies génériques de résolution de problèmes (algorithmiques) ; • Connaître et savoir utiliser les principaux types abstraits（抽象的） ; • Comprendre le fonctionnement de leurs principales implémentations（实施方法） et leurs limites. Analyse d’algorithmesProuver des propriétésPropriétés des algorithmes (et programmes)： Propriétés non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] Performances Prouver des propriétés： exhaustif:全面，formelles:正式的 Invariants de boucles：循环不变量Pour prouver ce type de propriétés[什么属性？] : ​ • Invariants de boucles : ​ • Propriétés inductives[归纳的，电感的，感应的] ; ​ • À prouver par induction[归纳] sur les itérations. ​ • Contrats de type assume-guarantee : ​ • Sous réserve de la précondition[前提条件] X, la postcondition[后置条件] Y est vraie ​ • Version informelle des triplets de Hoare dans la logique du même nom. 源于网上的一些解释 在计算机科学中，循环不变量，是一组在循环体内、每次迭代均保持为真的某种性质，通常被用来证明程序或算法的正确性。 我们使用循环不变量帮助我们理解一个算法为什么是对的。对于一个给定的循环不变量，我们必须遵循以下三个属性： 初始化：在循环的第一次迭代之前，循环不变量为真。 保持：如果在循环的一次迭代之前循环不变量为真，那么在下一次迭代之前循环不变量同样为真。 终止：当循环结束时，不变量能够提供我们有用的属性，用于帮助我们证实算法是正确的。 当保证前两个属性时，循环不变量在循环的任意迭代之前都满足。注意它与数学归纳法的相似性，当你想证明一个属性存在时，你需要证明一个基准和一个归纳步。相应的，我们第一次迭代之前保证不变量成立对应于一个基准，我们在每次迭代之间保证不变量成立对应于一个归纳步。 因为我们用循环不变量证明算法正确性，所以第三个属性或许是最重要的。通常，我们必须保证在循环结束时“循环不变量”和“循环终止条件”同时成立。 这与数学归纳法有所不同。数学归纳法常采用无限的归纳步，而循环不变量的归纳往往随着循环的终止而结束。 EXEMPLE 对于插入算法的12到14行，有如下分析 après la $n^e$ itération, on a 0 ≤ j &lt; x vrai pour n = 0, par la ligne 11 et l’hypothèse x ≥ 1 si vrai pour n ≥ 0, alors : • soit j = 0 (ou A[x] ≤ A[j]), la boucle s’arrête et pas d’itération n + 1 ; • soit j &gt; 0 (et A[j] &lt; A[x]) et après la ligne 14, au début de l’itération n + 1, on a bien 0 ≤ j &lt; x. EXERCICE 1.插入排序 123456789101112def sort (A, n): for i = 1 to n = 1: insert(i , A) def insert (x , A): key = A[x] j = x - 1#j从后往前遍历 while j &gt; 0 and A[j] &gt; key:#比key大的都往后移 A[j + 1] = A[j] j = j - 1 A[j] = key#放入key 1.quel invariant pour la boucle dans sort ? —回答第n次迭代会发生什么事情，从功能上和参数变化上来考虑 Après $k^e$ iteration, les k+1 premieres cases de A sont par ordre croissant. 2.quelles préconditions et postconditions pour insert ? Après $k^e$ appel de insert: ​ préconditions: les k permiers triés ​ postconditions: les k+1 permiers triés 3.quel invariant pour le while d’insert ? après la $m^e$ itération du while: $j = x -1 - m$ les m éléments d’indice plus grand que j sont &gt; key soit A[j] &gt; key, soit (A[j] &lt;= key et pour tout i&lt;=j, A[i]&lt;=key) soit A’ la valeur de A au début de itération ​ si $ i &gt; j , A[i+1] = A’[i]$ ​ si $i &lt;=j, A[i] = A’[i]$ 2.Algorithme d’Euclide#相减求最大公约数 12345678# pour a et b strictement positifsdef euclid (a , b): while a != b: if a &gt; b: a = a - b else : b = b - a return a On note ai la valeur de a à la n de l’itération i (donc a0 est la valeur initiale) et on définit bi de façon similaire. Quel invariant de la boucle while pour la correction de l’algorithme?—从功能上解释：Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] ​ après $i^e$ itération: $pgcd(a_i,b_i) = pgcd(a,b)$ Quel invariant de la boucle while pour la terminaison ? —从参数上解释：non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. ​ $0&lt;a_i&lt;a_{i-1}$ ou $0&lt;b_i&lt;b_{i-1}$ Conclure quand à la terminaison et la correction de l’algorithme en utilisant les deux invariants. Invariants pour les programmes récursifsEXEMPLE: 123456# Pour i &lt; n = len(A)def maximum(i, A): if i == len(A) - 1: return A[i] else : return max(A[i], maximum(i + 1, A)) EXERCICE: 123456789# pour a et b strictement positifsdef euclid (a , b): if a == b: return a else : if a &gt; b: return euclid (a - b, b) else : return euclid (a , b - a) Invariants et problèmes insolubles On peut aussi utiliser les invariants pour démontrer qu’un problème n’a pas de solution ; L’invariant est satisfait[满足] par les itérations de tout hypothétique algorithme ; Il n’est pas satisfait par la configuration finale recherchée. EXERCICE: 第一个是奇数不行—&gt;每次循环增加的一个多米洛是2 第二个是缺同色的不行—&gt;每次循环增加的是一黑一白，但棋盘缺了两白色 Preuve automatique et indécidabilité[不可决定性]Peut-on écrire un programme qui prend un programme quelconque[任何] en entrée et décide s’il a une propriété donnée ? 比如说，我们Écrire un programme qui décide si un programme quelconque s’arrête (sur une entrée donnée). • Supposons qu’un tel programme existe : on l’appelle H ; • Pour un programme P et une entrée i donnés, H(P, i) vaut vrai si P s’arrête pour l’entrée i et faux sinon • Soit le programme H‘ , qui prend en entrée un programme P dont l’entrée est un programme, et défini par : 1234if H(P,P): while True: passelse: print(&quot;coin !&quot;) Que se passe-t-il pour l’exécution de H’ pour le programme H’? H’ est bien un programme qui prend un programme en entrée • Si l’exécution se termine alors H(H’, H’) est vrai… et on devrait aller dans le while qui ne s’arrête jamais ; • Si l’exécution ne se termine pas, alors H(H’, H’) est faux… et on devrait s’arrêter en affichant “coin !”. —&gt;Donc le programme H‘ ne peut pas exister ! IndécidableUn problème algorithmique dont la réponse est vrai ou faux est appelé problème de décision ; Un problème de décision pour lequel il n’existe pas d’algorithme qui le résout est dit indécidable ; Le Théorème de Rice dit (informellement) que toute propriété non-triviale[琐碎，平凡] sur les programmes est indécidable. 下面是3个Indécidable的例子 le 10e problème de Hilbert 不定方程又称丢番图方程[ Une équation diophantienne]的可解性 Problème de correspondance de Post (PCP) Machines à deux compteurs Complexité定义La complexité d’un problème est celle du meilleur algorithme[最佳算法] qui le résoud ; Deux mesures principales : 1 temps de calcul ; 2 mémoire maximale utilisée. Ces mesures dépendent de l’instance du problème considéré : 1.on mesure en fonction de la taille de l’entrée ; 2. meilleur cas ou pire cas ; 3.cas moyen (espérance) ; Elles dépendent aussi du modèle de calcul considéré : Informatique théorique : machines de Turing. Par exemple le problème de décision du voyageur de commerce est NP-complet Analyse pratique : modèle RAM. Par exemple le tri fusion opère[归并排序] en $O(nlog_2n)$ Machines de TuringEXEMPLE 负数的补码计算：取反+1 EXERCICE Écrire une machine de Turing sur l’alphabet {a, b} qui décide si un mot est un palindrome. Par exemple abba ou ababa sont acceptés mais abbaa est rejeté. 本质思想还是第一个和最后一个比。 Complexité d’une machine de Turing-Les machines de Turing sont le modèle le plus simple d’algorithme -Un seul type d’instruction, un seul type de données (symbole) 单一指令单一数据类型 -La taille de l’entrée est le nombre de cases initialement non vides -Les notions de complexité sont simples et naturelles : Complexité temporelle : nombre d’instructions réalisées avant arrêt[执行的指令数] Complexité spatiale : nombre maximal de cases non vides simultanément[同时最大数量的非空方格] SATquelques classes de complexité des problèmes de décision PTIME: temps polynomial —&gt; $O(n^k)$ ​ existence d’une solution dans un programme linéaire PSPACE: espace polynomial ​ décider si on peut passer d’un conguration à une autre dans Rush Hour ou Sokoban[独木桥] EXPTIME: temps exponentiel —&gt; $O(2^n)$ ​ déterminer si le 1er joueur gagne pour une position de Go[围棋] (en fonction de la taille du plateau) EXPSPACE: espace exponentiel ​ déterminer si 2 expression régulières (simples) ont le même langage $(a^b^+c)^ = (a+b+c)^$ PTIME\\subset PAPACE \\subset EXPTIEM \\subset EXPSPACE\\\\ PTIME\\subsetneqq EXPTIEM Le problème SAT 布尔可满足性问题: 确定是否存在满足给定布尔公式的解释的问题。 -Entrée: une formule booléenne avec des variables propositionnelles. -Sortie: existe-t-il une valeur des variables telle que la formule est vraie ? EXEMPLE：8皇后问题的SAT表示 Le problème des huit reines : Placer huit reines sur un échiquier telles qu’elles ne soient pas en prise. Comment résoudre ce problème avec le problème SAT ? X_{11} \\vee X_{12} \\vee ... \\vee X_{18}\\\\\\land\\\\X_{21} \\vee X_{22} \\vee ... \\vee X_{28}\\\\\\land\\\\...\\\\\\land\\\\ X_{11} = \\neg X_{22} \\land \\neg X_{33} \\land ... \\land\\neg X_{88}\\\\\\land\\\\...Complexité de SAT -问题是时间复杂度是EXPTIME: temps exponentiel —&gt; $O(2^n)$ -On peut encoder une partie d’échecs ou de go avec SAT ⇒ mais avec une formule de taille exponentielle ! -Si on donne une valeur des variables, il est facile de vérifier que c’est une solution ou non -De nombreux problèmes utiles ont cette propriété : existence d’un cycle hamiltonien dans un graphe orienté ; #有向图的哈密顿回路[一笔画] coloration de graphes[着色] problème du sac-à-dos (Knapsack) [背包问题]; problème des cartons (Bin packing) [装箱问题]; programmation linéaire en nombre entiers (ILP)[整数线性规划]. -Pour les étudier : abstraire la recherche de la solution[将问题答案01编码] Permettre à la machine de deviner[猜想，尝试] une solution avant de la vérifier ; Permettre à la machine de se dupliquer[赋值] et vérifier plusieurs candidats en même temps → Machine non-déterministe Machines de Turing non-déterministes 就是读到的东西一样可能导致不同的操作 Dans ce cas, la machine se duplique[自我复制] et chaque copie exécute l’une des possibilités. La machine accepte si l’une des copies atteint l’état accept, mais la machine rejette si toutes les copies atteigent l’état reject. EXEMPLE Écrire une machine de Turing non-déterministe qui étant donnée une séquence de 0, 1 et x décide s’il existe une valeur de x ∈ {0, 1} telle que la séquence est un palindrome sur {0, 1}. NPLa classe de complexité NP -Une machine non-déterministe résout SAT en temps polynomial：[PTIME: $O(n^k)$] -NPTIME (ou NP) : les problèmes qu’on peut résoudre en temps polynomial . ​ ex. SAT, knapsack, ILP, etc. -Mais aussi NPSPACE, NEXPTIME, NEXPSPACE, etc. Le Théorème de Savitch implique que PSPACE = NPSPACE et EXPSPACE = NEXPSPACE. P ⊆ NP ⊆ PSPACEUne question ouverte importante est P=NP? Bornes inférieures et complétude -Soit un problème P tel que : on peut transformer toute instance d’un problème quelconque de la classe de complexité C en une instance de P la transformation n’est pas trop coûteuse[昂贵] (typiquement polynomiale, ou logarithmique pour PTIME) -P est C-dificile ; -Si de plus P ∈ C alors P est C-complet ; -Les problèmes C-complets sont les plus dificiles de la classe C ; -Le Théorème de Cook-Levin dit que SAT est NP-dificile (et donc NP-complet). EXERCICE Le problème de décision ILP est : étant donnée une intersection de demi-espaces, contient-elle un point entier ? Montrer que ILP est NP-dificile. 证明所有的SAT问题都能转换成ILP问题。 任何SAT: X_1 \\land \\ \\neg X_2 \\land \\neg X_3\\\\ 转化为ILP:0","link":"/2022/09/06/ALGOA_CM1&2/"},{"title":"ALGOA_CM4&amp;5","text":"ALGOA_CM4&amp;5Énumeration exhaustive et Backtracking et Diviser pour régner Énumeration exhaustiveEXEMPLE Carré magique. Pour n ∈ N&gt;0, placer une fois et une seule chaque nombre de 1 à n^2 dans une grille carrée de taille de côté n de façon à ce que la somme de chaque ligne, chaque colonne, et chaque grande diagonale soit la même. 123456789def carre(C,T,k,n): if k == n^2 and test\\_carre(C, n):#递归终止条件 return C for i = 1 to n^2: if not T[i]: T[i] = true#标记有没有取过 C[(k / n),(k mod n)]=i#这里下标很有意思，这样i和j都能取[0..n-1] carre(C,T,k+1,n) T[i]=false#回退 EXERCICE Backtracking解空间树，DFS+约束函数 Exemple 八皇后： 123456789101112131415def aligned(L,i,j):#约束函数 for (k,l) in L: if k==i or l == j or abs(k-i) == abs(l - j): return True return Falsedef queen(L,i,n): if i==n: return L else: for j = 1 to n-1: if not aligned(L,i,j): L2 = L L2 = L2 ++ [(i,j)] queen(L2,i+1,n) return [] EXERCICE: Trouver des valeurs de x, y, z et w pour satisfaire cette formule de 3-SAT par backtracking : $(x ∨ z ∨ w) ∧ (x ∨ y ∨ ¬w) ∧ (¬x ∨ ¬y ∨ w) ∧ (¬x ∨ ¬y ∨ z) ∧ (¬x ∨ ¬w) ∧ ¬z$ X=0,Y=1,W=1,Z=0 OU X=1,Y=0,W=0,Z=0 Le voyage du cavalier. On considère un échiquier de taille n avec un cavalier sur la case en haut à gauche. On rappelle que le cavalier se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale. Écrire un algorithme pour trouver dans quel ordre le cavalier doit visiter les cases de l’échiquier pour les voir toutes exactement une fois. -se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale: ​ -老师写的算法 12345678910111213141516def moves(B,i,j): n = len(B) deps = [(2,1),(-2,1),(2,-1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)] L = [] for (x,y) in deps: if i+x &gt;= 0 and i+x &lt; n and j+y &gt;= 0 and j+y &lt; n and B[i+x][j+y] == 0: L.append((i+x,j+y)) return Ldef knight(B,i,j,k): if k == n*n+1: print_board(B)#注意终止条件！ else: for (x,y) in moves(B,i,j): B[x][y]=k knight(B,i,j,k+1) B[x][y]=0 Diviser pour régner (Divide &amp; Conquer ) Principe général: Diviser en sous-problèmes Résoudre les sous-problèmes Combiner les solutions. En général, on parle de diviser pour régner , quand on divise en (au moins deux) problèmes indépendants identiques au problème initial mais plus petits. Donne naturellement des algorithmes récursifs. EXEMPLE: merge sort 归并排序 1234567891011121314151617181920def merge_sort(A,d,f): if f - d &gt; 1 : //划分 m = int((f+d)/2) merge_sort(A,0,m) merge_sort(A,m,f) B = A //合并 i = 0 j = m k = 0 while i &lt; m or j &lt; n: if j == n or B[i]&lt;B[j]#左半区更小 A[k] = B[i] i = i+1 else: A[k] = B[j] j = j + 1 k = k + 1 时间复杂度分析 T(n) = 2T(n/2) + Θ(n) a=2,b=2,k=1—&gt;T(n)=Θ(nlogn) EXERCICE: Recherche dichotomique. Proposer un algorithme pour la recherche d’un élement dans un tableau trié et donner sa complexité au pire cas. 二分查找 12345678def dicho(A,x,d,f): if d &gt; f : return False else: m = (d+f)/2 if x == A[m]: return m else: if x &lt; A[m]: return dicho(A,x,d,m) else : return dicho(A,x,m+1,f) Occurrences. Écrire un algorithme pour compter le nombre d’occurrences d’un élément donné dans un tableau trié et donner sa complexité pire cas. 查找出现的次数 123456789101112131415161718192021def find_first(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m] or (m &gt; d and A[m-1] == x): --这里的m&gt;d等价于f&gt;d，看着没啥必要的样子哎 return find_first(A,x,d,m) elif x &gt; A[m]: return find_first(A,x,m+1,f) else: return mdef find_last(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m]: return find_last(A,x,d,m) elif x &gt; A[m] or (m &lt; f and A[m-1] == x): --这里的m&gt;f也等价于f&gt;d，看着也没啥必要的样子 return find_last(A,x,m+1,f) else: return m 多米诺棋盘覆盖问题 用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//tr,tc表示棋盘左上角//dr,dc表示表示特殊方格void ChessBoard(int tr , int tc , int dr , int dc , int size){ if(size == 1)return;//棋盘只有一个方格其是特殊方格 int number = ++t;//L型骨牌号 int s = size/2;//划分棋盘 //覆盖左上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s-1][tc+s-1]=number; ChessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)//特殊方格在右上角子棋盘中 ChessBoard(tr,tc+s,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖左下角，再递归处理子棋盘 board[tr+s-1][tc+s]=number; ChessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左下角子棋盘中 ChessBoard(tr+s,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右上角，再递归处理子棋盘 board[tr+s][tc+s-1]=number; ChessBoard(tr+s ,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr+s,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s][tc+s]=number; ChessBoard(tr+s,tc+s,tr+s,tc+s,s); }} a = 4 , b = 2 , k = 1 Pesées. On a n pièces de monnaies dont une exactement est fausse et plus légère que les autres. On dispose d’une balance de type Roberval ou à éau : en une pesée on peut déterminer si un ensemble de pièces est plus lourd qu’un autre. Écrire un algorithme pour trouver la pièce fausse à l’aide de la balance et donner sa complexité au pire cas. On représente les pièces par un tableau de poids et on veut l’indice de la pièce fausse. On dispose d’une fonction compare(A, d1, f1, d2, f2) qui renvoit −1, 0 ou 1 si la somme des poids des pièces aux indices d1 jusqu’à f1 est respectivement plus petite, égale, ou plus grande que celle des pièces de d2 à f2 12345678910def pesses(A,d,f): if d &gt; f : return False elif d == f : return d else: m = (d+f)//2 if compare(A,0,m,m+1,f) == -1 : return pesses(A,0,m) elif compare(A,0,m,m+1,f) == 1 : return pesses(A,m,f) else: return False Tri rapide (quick sort). Si on choisit un élément du tableau (le pivot), on peut partionner les autres éléments en ceux qui sont plus petits, et ceux qui sont plus grands que le pivot. En exploitant ce principe, proposer un algorithme de tri d’un tableau et donner sa complexité au pire cas 123456789101112131415def quicksort (A, d, f ): if d &lt; f : p = partition (A, d, f ) quick_sort(A, d, p-1) quick_sort(A, p+1, f)def partition (A, d, f ): p = random_int(d, f) swap(A, f , p) j = d for i = d to f - 1: if A[i] ≤ A[f]: swap(A, j , i ) j = j + 1 swap(A, j , f ) return j a = 2,b=,k=1","link":"/2022/09/16/ALGOA_CM4&5/"},{"title":"ALGOA_CM3","text":"ALGOA_CM3Complexité asymptotique et Algorithmes probabilistes Complexité asymptotique 对O，Ω，Θ等的一些理解 EXEMPLE求解插入排序在最坏情况下的时间复杂度 EXERCICE求解下面两个算法的时间复杂度 On veut évaluer en un point x un polynôme de degré n en donné par la liste A de ses coefficients. On considère deux approches : 12345678910111213def naive(A,x,n): s = [0] for i = 1 to n: p = A[i] for j = 1 to i: p = p*x s = s+p return sdef horner(A,x,n): s = 0 for i = n downto 0: s = s*x + A[i] return s Calculer proprement la complexité des deux approches. naive:$1+2*n+\\sum^n_1\\sum^i_1 1 = 1 + 2n + \\sum^n_1 i = 1 + 2n + n(n-1)/2 = Θ(n^2)$ horner: $1+n=Θ(n)$ Quelle est la complexité du tri par insertion en fonction du nombre d’inversions I (le nombre de couples (i, j) tels que i &lt; j et A[i] &gt; A[j]) et de n ? 移动的次数就是等于翻转对的个数：移动一次就少一个翻转对，直到排序完成 然后需要加上定位到所有位置的一个遍历的复杂度n O(n+l) Complexité pire cas des algorithmes récursifs-On peut les résoudre parfois directement : récurrences linéaires à coefficients constants ; deviner une expression et la prouver[归纳法归纳法] ; Théorèmes dédiés : Master Theorem (voir divide and conquer), récurrences d’Akra-Bazzi. 不能直接解决的那种证明可以用归纳法！ EXEMPLE阶乘 12345def fact(n): if n == 0: return 1 eles: return n * fact(n-1) $T(n) = T(n-1)+1 \\quad T(0)=1 —&gt; T(n)=n+1=Θ(n)$ fib: 12345def fib(n): if n == 0 or n == 1: return 1 else: return fib(n-1)+fib(n-2) $T(n+2) = T(n+1) + T(n) +1 &gt;= T(n+1) +T(n) \\quad et \\quad T(0)=1,T(1)=2$ $x^2-x-1 &gt;= 0$ 是因为偏微分方程 EXERCICEMontrer que la complexité de fib est $O(2^n)$ 归纳法归纳法 假设\\quad{\\exists} C、N，tq\\quad{\\forall}n>N\\quad f(n)","link":"/2022/09/16/ALGOA_CM3/"},{"title":"ALGORITHM-Prem","text":"Prem问题描述：全排列问题的两种递归实现 1.DFS(来自啊哈算法一书) 123456789101112131415161718192021222324void dfs(int step , int n ,int book[] , int a[]){ if (step == n )//排到第n个数，排列完成 { print(a,n); return;//【返回之前一步，很重要】 }//每一步的操作for (int i = 0; i &lt; n; i++){ if (!book[i])//还没有排 { a[step] = i+1; book[i] = 1; //开始排下一个了 dfs(step+1,n,book,a); book[i] = 0;//排序完成，回收本次数【！！！】 }} return;} DFS：深度优先搜索，这里的DFS不单指图论，理解为一种递归的思想。下一步操作与当下操作是一样的,一直执行，直到符合条件。基本模型为： void dfs(int step) { 判断边界(递归结束条件)return; 尝试每一种可能 for(int i = 0 ; i &lt; n ; i++) { 继续下一步 dfs(step + 1); } return ; }","link":"/2021/12/06/ALGORITHM-Prem/"},{"title":"ALGORITHM-期末","text":"期末实验汇总西南交通大学算法实验期末题型汇总 凸包问题蛮力法文字描述 找所有构成凸包的点 对由n个点构成的集合S中每两个点进行遍历，判断这两点是否能构成凸多边形的边。如果能，则将这两点的标志位flag置位1。具体判断方法为：集合S内的所有点都在这两个点构成边的同一侧。(一侧的判断由ax+by&gt;=c的点的个数为n-2或0完成) （以凸包内一点）用的斜率反推角度进行逆时针排序 说明：本算法中因输入设置为当x==0&amp;&amp;y==0时停止输入，因此在选择计算凸包边界各点的斜率的原点时选用(0,0)。 角度求解（由于atanx的范围为-π/2到π/2，但a的实际范围为-π到π，因此在求角度时要进行不同情况的判断计算）： ​ x = 0 ：y &gt; 0 时，a = π / 2；y &lt; 0 时，a = - π / 2 ; ​ a = atan(y / x) : 第一象限 x&gt;0,y&gt;0 :a = a;第二象限：x0,a= a +π；第三象限：x","link":"/2021/12/06/ALGORITHM-%E6%9C%9F%E6%9C%AB/"},{"title":"ALGORITHM-算法效率","text":"算法_第二章__算法效率分析1.算法分析概述对算法所需要的两种计算机资源：时间资源和空间资源进行估算。 目的是为了设计和选择更好的算法 （1）时间效率时间效率：设输入的元素个数为n,执行该算法的第i步操作记为op（i）,该步骤执行的次数为Cop(i)，则该算法的总执行时间为： T(n)=\\sum_i C_{opi} * C_i(n)（2）时间复杂性时间复杂性：指执行算法所消耗或占用时间资源的量【程序步数】 ​ 在最坏、最好、平均三种情况下的时间复杂度 （3）例题1.非递归程序顺序检索：在具有n个元素的数组a[1……n]中找出值等于x的元素的位置 1234567template&lt;class Type&gt;int seqSearch(Type *a, int n, Type x){ for(int i=0;i&lt;n;i++) if (a[i]==x) return i; return -1;} 最坏：T(n) = n 最好：T(n) = 1 平均：Tavg（n）=sum[p(I)T(I)] 变式：设计一个尽可能高效的算法，在长度为n的一维数组a[n]中查找值最大的元素max和最小的元素min，并分析算法的最好、最坏和平均时间复杂度。 123456789void MaxMin(int a[],int n,int &amp;max,int &amp;min){ int I; max=min=a[0]; for(i=1;i&lt;n;i++) if(a[i]&gt;max) max=a[i]; else if(a[i]&lt;min) min=a[i];//【要特别注意这的else！！！】} 最好：是一个递增的，n-1 最坏：递减，2*（n-1） 平均：假设a中有一半元素比max大，a[i]&gt;max执行n-1次，else语句执行（n-1）/2次———&gt;平均3*（n-1）/2次 2.递归程序的时间复杂性分析 123456789float RSum(float list[],const int n){ if (n) //1 { return RSum(list,n-1)+list[n-1]; //? } return 0; //1} T(n) = T(n-1)+2[T(0)=2] 程序步骤不能确切反映程序运行的实际时间 2.渐进定义：只关心f(n)的阶 大O表示法：若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≤c×f(n)，则称f(n)是T(n)的上界，记为：T(n)=O(f(n)) 大Ω表示法：若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≥c×g(n)，则称g(n)是T(n)的下界，记为：T(n)= Ω(g(n) Θ表示法：若存在三个正的常数c1、c2和n0，对于任意n≥n0都有c1×f(n)≥T(n)≥c2×f(n)，则称f(n)与T(n)同阶，记为：T(n)=Θ(f(n)) 求解方法： \\lim_n {t(n)\\over g(n)}=0\\mbox{\\quad \\quad t(n)的增长次数比g(n)小}\\\\ \\lim_n {t(n)\\over g(n)}=c>0\\mbox{\\quad \\quad t(n)的增长次数和g(n)相同}\\\\ \\lim_n {t(n)\\over g(n)}=\\infty\\mbox{\\quad \\quad t(n)的增长次数比g(n)大}为0时，大O；为无穷时，大Ω；c为Θ 3.时间复杂度定义：针对指定基本运算，计数算法所做运算次数 例： 123456x=1; for(i=1; i&lt;=n; i++) for(j=1 ; j&lt;=i; j++) for(k=1; k&lt;=j; k++) x++; 执行次数为： \\sum^n_{i=1}\\sum^i_{j=1}\\sum^j_{k=1}1=\\sum^n_{i=1}\\sum^i_{j=1}j=\\sum^n_{i=1}{i(i+1)\\over2}=[n(n+1)(2n+1)/6+n(n+1)/2]/2 \\\\ ={n^3+3n^2+2n\\over6}时间复杂度T(n) = O(n^3) 4.递归的高阶方程的数学分析先化简再计算 例： 1.汉诺塔问题的递归算法的复杂度分析 代码： 12345678910void Hanoi(int n , A ,B,C){ if(n == 1)MoveOne(n,A,B); else { Hanoi(n-1 , A ,C , B); MoveOne(n,A,C); Hanoi(n-1 , B , A , C); }} M(n) = 2M(n-1)+1 M(n) = Θ(2^n) 2.斐波那契 代码： 1.递归实现 123456int Fibonacci1(int n){ if(n &lt; 0) return -1; if(n &lt;= 0) return (n); else return Fibonacci1(n-1)+Fibonacci1(n-2);} A(n) = A(n-1)+A(n-2)+1 2.迭代法 123456789int Fibonacci2(int n){ int F[n+1]; F[0] = 0; F[1] = 1; for(int i = 2 ; i &lt;= n ; i++) F[i] = F[i-1] + F[i - 2]; return F[n];} 时间复杂度低但空间资源浪费高 A(n) = n - 1 = Θ(n) 3.最优解法 123456789101112int Fibonacci3(int n){ int F , Fa , Fb; Fa = 0 ; Fb = 1 ; for(int i = 2 ; i &lt;= n ; i++) { F = Fa + Fb; Fb = Fa; Fa = F; } return F;}","link":"/2021/12/06/ALGORITHM02/"},{"title":"ALGPR-1","text":"序第一周的算法课都讲了什么T.T CM1TD1从字符的匹配开始讲的，说了蛮多伪代码的东西，真难看(bushi 字符的匹配貌似没啥，就是熟悉一下子法语书写的伪代码 L123456789101112131415Variables://定义变量 Caractère:courant//串，定义为字符类型 Entier:nbL//拿来计数的int Début nbL &lt;- 0 courant &lt;- lire()//这里的读是一个个读 tantque(courant != '.') si(courant == 'L') nbL &lt;- nbL+1 finsi courant &lt;- lire() fintanque afficher(nbL)//输出Fin LE1234567891011121314151617Variables: Caractère:courant,précédent Entier:nbLE Début nbLE &lt;- 0 précédent &lt;- '.' courant &lt;- lire() tantque(courant != '.') si(courant == 'L' ET courant = 'E') nbLE &lt;- nbLE+1 finsi précédent &lt;- courant courant &lt;- lire() fintanque afficher(nbLE)Fin ELLE就是把子串固定，然后拿courant去做匹配 以ELELLELLLLEL找ELLE为例 1234567891011121314151617181920212223242526272829303132Variables: Chaine de caractère:courant,motif//motif是子串 Caractère: c Entier: nbMotif Début nbMotif &lt;- 0 afficher(&quot;quel est le motif cherché?&quot;) motif &lt;- lire() //初始化串为...courant[0] pour i de 0 à taille(motif)-2 courant[i] &lt;- '.' finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c //串变成了...E tantque(c != '.') si (courant = motif) nbMotif &lt;- nbMotif+1 finsi //从后往前移 pour i de 0 à taille(motif)-2 courant[i] &lt;- courant[i+1] finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c fintanque afficher(nbMotif)Fin 妙的！时间复杂度的话N*n，可能比用想的的find函数要好哎 实际写的好艰难,string里面真的好多东西哦:( 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main(){ int nbMotif=0; string courant,motif; cin&gt;&gt;courant; cin&gt;&gt;motif; size_t p=0;//注意返回类型 while((p = courant.find(motif,p)) != courant.npos) { nbMotif++; p += motif.size(); } cout&lt;&lt;nbMotif&lt;&lt;endl; return 0;} 老师的奇妙方法用矩阵还是图的知识来实现匹配(example:LE 123456789101112131415161718192021Variables: Caractère:c Entier: s,ss,x,nbLE Tableau d'Entiers m &lt;- {{0,1,0,2},{0,1,0,2}} Début nbLE &lt;- 0 s &lt;- 0 tantque(s != 2) courant &lt;- lire() x &lt;- 0 si(c == 'L') alors x &lt;- 1 finsi si(c == 'E') alors x &lt;- 2 finsi si(c == '.') alors x &lt;- 3 finsi ss &lt;- m(s,x) si (s = 1 ET x = 2) alors nbLE &lt;- nbLE+1 finsi s&lt;- ss fintanque afficher(nbLE)Fin 时间复杂度的话应该有两部分，一是在写m矩阵那里，然后是主程序。主程序的时间复杂度的话，有个逐个读的n，然后剩下的话我感觉有m^2。—-&gt; ? 矩阵长这样 好像是在用s和x来表示前后两次的匹配的结果 但感觉就是时间也多了，空间也给浪费了嘛(；′⌒`) TD题题1.1 Points et polygone (enregistrement)On souhaite calculer quelques propri´et´es d’un polygone quelconque (p´erim etre, longueurmoyenne des arˆetes, boite englobante). La boite englobante est un rectangle englobant lepolygone de cˆot´es paralleles aux axes. Les sommets du polygone sont donn´es (dans l’ordrede parcours du p´erimetre) par leurs coordonn´ees r´eelles dans un plan et le nom du point(caractere).La liste de coordonn´ees est suppos´ee correcte et n’est lue qu’une seule fois. Exemple defichier a lire :— 1,5 3,7 A— 6,4 4,6 B— 5,8 8,3 C— …— 1,5 3,7 A (dernier sommet a ne pas ajouter dans la structure de donn´ees)Les coordonn´ees du dernier sommet sont ´egales a celles du premier. Ce sommet permetuniquement de d´etecter la fermeture du polygone. Il ne faut pas rentrer ce sommet dans lastructure de donn´ees.— Proposez une structure de donn´ee pour stocker le polygone,— Ecrivez l’algorithme principal pour lire le fichier contenant les points du polygone, ´appeler les fonctions permettant de calculer les propri´et´es demand´ees et afficher lesr´esultats a l’´ecran,— Ecrivez les fonctions secondaires pour calculer la longueur du p´erim`etre, calculer la ´longueur moyenne des arˆetes et d´elimiter la boite englobante. 解1234567891011121314151617181920Types//应该是在定义结构体 point: enregistrement caratère: nom réel: x réel: y fin_enregistrement tabPoint: tableau de pointAlgorithme principal PolygoneVariables://定义变量 tabPoint polygone,boiteEnglobante réel périmètre, longMoy Début polygone &lt;- lirePolygone(&quot;data.txt&quot;)//读文件 périmètre &lt;- calcuPérimètre(polygone)//周长 longMoy &lt;- périmètre/taille(polygone)//棱边数 boiteEnglobante &lt;- calculBoite(polygone)Fin Algorithme 我想的C++不知道能不能成 1234567891011121314151617181920212223struct Point{ char Nom; float x; float y;};float distance(Point A, Point B){ return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}class Polygone{ vecter&lt;Point&gt; PonitsDePolygone; public: //构造函数 Polygone(Point A){PonitsDePolygone.push(A);} //拷贝构造 ou 析构？？？？ float périmètre(); int longMoy();} 结语KMP,CM和未完成的C++就是明天一定","link":"/2022/02/08/ALGPR-1/"},{"title":"ALGPR-2","text":"序第二周的算法课都讲了什么T.T TD2尝试在课上直接记blog的第一天 Récursivitécalcule la puissance d’un nombreprincipe_1: calcul récursif pour n != 0,et puissance(x,0)=1 123456entier puissance(entier x,entier n):Début si (n = 0) alors retourner 1//结束递归的跳出条件 sinon retourner x * pusissance(x,n-1)//递归 finsiFin principe_2: par la méthod “diviser pour régner”,et puissance(x,0)=1,et puissance(x,1)=x div étant la division entiere 1234567891011121314151617Début //结束递归的跳出条件 si (n = 0) alors retourner 1 finsi si (n = 1) alors retourner x finsi //本质还是在所递归，有减少一些递归的次数 entier y = puiss2(x, (n div 2)) si (n mod 2 = 0 ) alors retourner y*y sinon alors retourner x*y*y finsiFin ——&gt;堆栈！ L’ordre inversé12345678910111213141516171819202122232425262728293031323334affiche_1(vecteur&lt;entier&gt; w)Début pour i de 0 à taille(w) -1 faire écrire(w[i]+'') fin_pourFin affiche_2(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors écrire(w[debut]+'') affiche_2(w,debut+1) fin_siFinentier debut = taille(w) -1affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut = -1) exit(0) fin_si écrire(w[debut]+'') affiche_inv(w,debut-1)Fin//可以初始化为0，先递归再输出[妙！]affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors affiche_inv(w,debut-1) écrire(w[debut]+'') fin_siFin String的palidrome123456789101112Algorithm palindrome booléen &lt;- palindrome(string s,int decal) Début si(decal &lt; (taille(s)-1)/2) si(s[decal] != s[taille(s)-1-decal]) retourner FAUX sinon palindrome(s,decal+1) sinon retourner VRAIFin —&gt;用stack来实现 Reine et pions(八皇后！)题有点怪 先写题 On considère un échiquier de huit cases sur huit comportant huit pions et une reine. Les positions des pions et de la reine sont données dans un fichier sous un format que vous devez définir(selon la structure de données que vous choisissez). La reine peut se déplacer sur les lignes(diagonales; verticale et horizontale) sur lesquelles elle se trouve. On souhaite savoir combien de pions sont en prise(i.e. pouvant êrte pris par la reine). Si deux pions ou plus sont sur la même ligne(diagonale, verticale , horizontale), seul le premier est en prise. 123456789101112131415161718192021DFSint res[9]void dfs(int step){ int i,j; if(step &gt; 8) { for(i=0;i&lt;8;i++) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0; } //尝试每一种可能 for(int i = 0 ; i &lt; 8; i++) { 继续下一步 dfs(step + 1); } return ; } CM2Gestion de la mémoire//内存管理Possible de stocker un lien vers une case mémoire Utile pour : ​ Structures de données (listes chainées, arbres) ​ Passage de paramètres：传递参数​ Allocation de mémoire：配置、地址分配 像是在讲指针的样子 1234567891011utilisation 'lien' :ExempleLienEntiervariables lien entier lienEnt//声明一个lien entier entDébut lienEnt ← lien(ent) contenu(lienEnt) ← 5 reçoit la valeur 5//接受 afficher(ent)Fin 关于lien和contenu lien:创造或声明链接 contenu：访问链接的内容 Structures de données composées Stockage de plusieurs données dans une seule structure pour：Structurer les données，Faciliter les traitements Données de même type : listes et arbres//树和表Données de type quelconque : enregistrements(记录登记) Enregistrements 应该是结构体 123456789101112131415161718types article : Enregistrement entier : référence réel : prix chaine de caractère : libellé entier : quantité Fin enregistrementvectArticles : tableau d’articlevariablesarticle artCour // article courantentier valeurStockartCour.prix &lt;-- lire ()artCour.libellé &lt;-- lire ()artCour.quantité &lt;-- lire ()valeurStock &lt;-- artCour.prix * artCour.quantitéécrire (&quot;La valeur du stock de &quot;, artCour.libellé, &quot; est de : &quot;,valeurStock, &quot; euros&quot;) Structures linéairesListesDéfinitionEnsemble d’éléments de même type liés par une relation de séquentialité 注意一下名字： prédécesseur， successeur 一些关于表的基本操作:插入、删除、测试表是否为空、测表长 Tableaux表Accès direct à un élément à l’aide de son indice(下标) 目标算法: Somme(求和), Tris(排序), Présence d’élément(?) Exemple de définition de types composés tabEnt : Tableau d’entiers matReels : Tableau de dimension 2 de réels tab4DEnt : tableau d’entiers de dimension 4 123456789101112131415161718192021222324252627282930//检查是否正序variables tabEnt tab entier n booléen trie{n, tab} &lt;- lire ()trie &lt;- VRAIpour i &lt;- 0 à n-2 faire si ( tab[i] &gt; tab[i+1] ) alors trie FAUX fin sifin poursi ( non trie ) alors écrire (&quot;le tableau n’est pas trié&quot;)fin si//一般函数variables vectArticles tabArt//?结构体的vector？ réel valStock entier nDébut{n, tabArt} &lt;-- lire (&quot;data.txt&quot;)valStock &lt;-- 0pour i 0 à n-1 faire valStock valStock + tabArt[i].prix * tabArt[i].quantitéfin pourécrire (&quot;La valeur du stock des &quot;, n, &quot; articles est de : &quot;,valStock, &quot; euros&quot;)Fin 所以说就是表的元素可以是结构体的意思？ Liste chainée链表单向 successeur链表的定义(值与指向下一元素的指针)： 1234567891011121314151617type elementEntier : Enregistrement entier valeur, lien elementEntier suivant, // lien vers l’élément suivant Fin enregistrementvariables elementEntier elementUn, elementDeux, ..., elementSix... elementUn.valeur 12 elementUn.suivant lien(elementDeux) elementDeux.valeur 99 elementDeux.suivant lien(elementTrois) ... elementCinq.suivant lien(elementSix) elementSix.valeur 16 elementSix.suivant VIDE 双向要同时定义前置和后置指针 Calcul de la longueur d’une liste（递归） 1234567891011fonction : longueur calculLongueur(lienDébutListe)paramètres : lien elementEntier lienDébutListerésultats : entier longueurDébut si ( lienDébutListe est VIDE ) alors longueur 0 sinon longueur 1 + calculLongueur(lienD´ebutListe-&gt;suivant) fin si retourner longueurFin Recherche d’un élément dans une liste（递归） 12345678910111213141516fonction : présence chercherElement(lienDébutListe, val) paramètres : lien élémentEntier lienDébutListe, entier val résultats : booléen présenceDébut si ( lienDébutListe est VIDE ) alors//链表为空退出 présence FAUX sinon si ( lienDébutListe-&gt;valeur = val ) alors présence VRAI sinon présence chercherElement(lienDébutListe-&gt;suivant, val) fin_si fin_si retourner présenceFin 就是链表本质就是结构体+数组吗？ Liste chainée和tableau时间复杂度的比较 查找，添加/删除头(位) Piles存储结构讲表与链表，然后栈、队列是特殊的线性表（？） LIFO:栈，先入后出 基本操作： ajoute(push),delete(pop),Test de pile vide File d’attenteFIFO：队列，先入先出 Structures arborescentes​ Extension du concept de liste avec plusieurs successeurs pour un élément(一个节点后面可以接多个节点) 结语总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/09/ALGPR-2/"},{"title":"ALGPR-3","text":"序ALGPR的第三周 TDTD2_Division euclidienne1234567891011121314151617181920212223242526272829303132couplEntier qr &lt;- divEuclid(entier n, entier d)Types couplEntiers: enregistrement entier: quotient entier: reste fin_enregistrement Variables couplEntiers qr,inter Début Si(n &lt; d) alors qr.reste &lt;- n; Sinon qr.quotient++; divEuclid(n - d , d); fin_Si retourner qrFinDébut Si(n &lt; d) alors qr.quotient &lt;- 0; qr.reste &lt;- n; Sinon inter &lt;- divEuclid(n - d , d); qr.quotient &lt;- inter.quotient + 1; qr.reste = inter.reste ; fin_Si retourner qrFin TD3_DéfinitionNotion de lien vers une structure de données: ce lien est un type de données à part entière défini par le mot-clé lien, suivi du type lié. Cette notion de lien sera traduite(翻译) en C++ par la notion de pointeur（指针） Lien Type_x 1: pour créer ou déclarer un lien sur une variable contenu(1): pour accéder au contenu du lien 1 指针和引用 指针本质也是变量，存储地址。引用本质是取地址。 注： 引用必须初始化，引用不能为空，引用只是别名不是实体 就是说不能这样子 int &amp;n 要这样 int &amp;n = m(m之前定义) 然后in &amp;n = 3这样子也会报错（？） 引用没有const 引用的自增和指针的自增问题 123456789101112131415int *p,entier;int &amp;q = entier;entier=5;p = &amp;q;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;*p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;q++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; 指针自增就是还挺多，*运算符的优先级低于右++，然后还有什么移位不安全啥的，看到再说 Exemple 1234567891011121314Variables Lien Entier lienEnt Entier nDébut lienEnt &lt;- lien(n) conteun(lienEnt) &lt;- 5 afficher(n)Finint *lienEnt,nlienEnt = &amp;n;*lienEnt = 5;cout&lt;&lt;n; [?] ne transmettre que la valeur de la variable: utiliser le passage par valeur modifier la valeur originale de la variable: utiliser le passage en partage TD3_Swap1234567Variables Entier cDébut c &lt;- a a &lt;- b b &lt;- cFin TD3_Swap+lien+struct12345678910111213141516fonction creerArticleproblème : création d'un novel articleapecification: fonction: Lien Article &lt;- creerArticle(r,n,p) paramètres: Entier r, VectCar n , Réel p résultats: Lien Article 1A Variables Lien Article 1ADébut 1A &lt;- nouveau() contenu(1A).reference &lt;- r contenu(1A).nom &lt;- n contenu(1A).prix &lt;- p renvoyer 1AFin 结语总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/21/ALGPR-3/"},{"title":"ANG","text":"序From BBC 6 Minute English.(https://www.bbc.co.uk/learningenglish/english/features/6-minute-english ) Welcome to the ‘metaverse’Links：https://www.bbc.co.uk/learningenglish/english/features/6-minute-english_2022/ep-220106 1.5 minutes的introductionThe topic I chose to talk about is &lt;&lt;Welcome to the ‘metaverse’&gt;&gt;. So to begin with, what is metavers? According to the video, metaverse means a virtual-reality space in which users can interact with a computer-generated environment and other users. Recently, Facebook announced that it was hiring ten thousand new workers to develop VR for the ‘metaverse’, according to Mark Zuckerberg, the Facebook boss,” in the future we’ll all spend much of our time living and working in the ‘metaverse’ “. But people hold different opinions about it. Some supporters think it can make a great difference to our living world. They believe that with the technology of metaverse, everything that we do on our phone today can be done in 3-D. But there are also some negative opinions. For example,some people called VR ‘ vomity reality ’,because wearing the headset of VR makes them feel sick, maybe because it’s so unwieldy . From my perspective, I hold a supportive attitude towards this new technology as it seems so cool which can make our world more convenient . 2 new keywordsVR: virtual-reality,a hypothetical three-dimensional visual world created by a computer; user wears special goggles and fiber optic gloves etc., and can enter and move about in this world and interact with objects as if inside it unwieldy: difficult to move or carry because it’s so heavy, large or strangely shaped 结语所以元宇宙就是VR? VR OU AR ? 看了一些科普，就是有比较像头号玩家那种世界（或许赛博朋克的那种？。感觉就是，元宇宙感觉是个画大饼的不太实的概念（ Body language onlineLinks: https://www.bbc.co.uk/learningenglish/english/features/6-minute-english/ep-211209 IntroductionThe topic I chose to talk about is ‘Body language online’. As we know, body language is important when we communicate with others. By using some hand gestures and facial expressions, we can make the conversation more natural. But during the Covid pandemic, the communication tend to move online to be video meetings by using software like Zoom and Skype. So, in that case, how has body language changed in the world of online video meetings? Firstly, eye contact. In face-to-face meetings, we immediately see someone’s reaction to what we’ve said through eye contact, but using a web camera to make eye contact is almost impossible in online meetings and this often creates a kind of ‘distance’ effect.—&gt; ? Secondly, pause. It was completely normal to have a one-minute pause in a room with one another because we knew when we’re thinking but if we don’t hear someone speak on video, we may ask them if there are some Internet problems.—&gt; Slow down. Last but not the least, smile or laughing. Erica , a communications expert from the conversation, points out that laughing often happens in unison, so it is much less likely that we laugh and smile on camera. Laughing is often done in unison where we can quickly pick up the energy of someone smiling or laughing and feed off of that and laugh together. When it comes to screen delays, the fact that it’s not natural to see our own camera – being distracted by that – we are much less likely to laugh and smile. —&gt;Water cooler effect. That’s all. New wordsWater cooler effect: it’s an American expression to describe informal conversations between people at work.—&gt; Talk someting informal out of the topic. In Unison: it means happening together and at the same time Pandemic: 流行病 noun: a widespread outbreak of an infectious disease and many people are infected at the same time adjective: existing everywhere","link":"/2022/02/06/ANG-01/"},{"title":"CCUBE_Chapitre1","text":"序CCUBE: ${C^3}$ est capteurs, contrôle, commande Chapitre_0:Préface et ObjectifsPréface Objectifs et moyens教学目标：— échantillonner un signal 信号采样;— en faire une analyse de Fourier 傅里叶分析;— modéliser un système physique continu par le langage des fonctions de transfert 用transfert函数给系统建模;— modéliser un système physique continu par le langage de l’espace d’état 用l’’espace d’état给系统建模;— lier les phénomènes physiques aux paramètres de ces représentations (temps de réponse, stabilité) ;— interfacer le temps continu et le temps discret(离散) ;— simuler(模拟) ces représentations à l’aide de logiciels adaptés. TP使用Matlab的Simulink完成： 1.la reconstruction d’une partition à partir de l’enregistrement audio-phonique ; 2.le pilotage en simulation d’une navette spatiale, version très simplifiée d’un contrat avec l’agence spatiale 前置数学知识— les nombres complexes 复数;— la dérivation et l’intégration d’une fonction d’une variable réelle（？） à valeur réelle（？） 积分求导;— les suites de nombres réels ou complexes ;on n’a pas à craindre les quelques calculs élémentaires de séries ;— le calcul matriciel 矩阵 ;— les valeurs et vecteurs propres, la diagonalisation d’une matrice carrée特征值； —LTI linéaire temporellement invariant线性时间不变 Chapitre1:Concepts et outils fondamentaux结语总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/04/CCUBE-01/"},{"title":"ALGPR-4","text":"序关于算法的第四周 TDListes chainéesEn utilisant une structure de liste chainée dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: afficher les éléments de liste(打印) ajouter un éléments à la fin de la liste(增) rechercher une valeur avec renvoi du nombre de valeurs présentes dans la liste(查) 1234567891011types elementSimplementChiane: Enregistrement type valeur, lien elementSimplementChiane suivant Fin_Enregistrementtypes elementEntier: Enregistrement type valeur lien elementSimplementChiane suivant Fin_Enregistrement Afficher12345678910111213141516Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementafficherElement(Lien ElementEntier début)paramètre: Lien sur ElementEntierresultat: videDébut si(début non vide) alors écrire(début -&gt; valeur)//也可以写成contenu(début).valeur afficherElement(début -&gt; suivant)//contenu(début).suivant finsiFin Ajouter1234567891011121314151617Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementajoutFin(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors contenu(début).suivant &lt;- ajoutFin(contenu(début).suivant,val) sinon contenu(début).valeur &lt;- val; contenu(début).suivant &lt;- NULL; finsi renvoyer débutFin Rechercher12345678910111213141516171819Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementrechercheNbVal(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors si(contenu(début).valeur = val) nb &lt;- nb+1 finsi nb &lt;- nb+rechercheNbVal(contenu(début).suivant,val) sinon nb&lt;-0 finsi renvoyer débutFin Liste doublement chainéesEn utilisant une structure de liste doublement chainées dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: ajouter un éléments à la bonne place dans une liste triée, supprimer un élément dont la valeur est donnée en paramètre. 123456Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement Ajouter123456789101112131415161718192021222324252627282930Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement ajoutTrié(Lien ElementEntier début, Entier val)Variable: Lien ElementEntierDbl tmpDébut si(début n'est pas vide) alors si(val &lt; contenu(début).valeur) tmp &lt;- noveau() contenu(tmp).valeur &lt;- val //insère contenu(tmp).suivant &lt;- début contenu(tmp).précrédent &lt;- contenu(début).précrédent contenu(début).précrédent &lt;- tmp début &lt;- tmp sinon contenu(début).suivant &lt;- ajoutTrié(contenu(début).suivant,val) finsi sinon début &lt;- noveau() contenu(début).valeur &lt;- val finsi renvoyer débutFin Arbres binaires12345Type NoeudArbreBinaire: Enregistrement type valeur, lien NoeudArbreBinaire fg, lien NoeudArbreBinaire fd,Fin_enregistrement Fonction parcoursPréfixe123456789Début afficher(racine -&gt; valeur) si racine -&gt; fg non vide alors parcoursPréfixe(racine-&gt;fg) fin_si si racine -&gt; fd non vide alors parcoursPréfixe(racine-&gt;fd) fin_siFin Recherche12345678910111213141516171819202122Booleen &lt;- existe(lien NoeudEntier noeud, Entier val)Début si(noeud n'est pas vide) alors renvoyer FAUX sinon si(noeud.valeur = val) alors renvoyer VRAI sinon renvoyer existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val)//注意这里一定是ou fin_si fin_siFin另一种写法Début si(noeud is not vide) alors renvoyer FAUX sinon renvoyer (noeud.valeur = val) OU existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val) fin_siFin Supprime[]1234567891011121314lien NoeudEntier &lt;- supprimeFeuille(lien NoeudEntier, Entier val)efface()、nouveau()Début si(noeud is not vide) alors si(noeud.fg = vide ET noeud.fd = vide ET noeud.valeur = val) efface(noeud) sinon noeud.fg &lt;- supprimeFeuille(noeud.fg , val) noeud.fd &lt;- supprimeFeuille(noeud.fd , val) fin_si fin_si renvoyer noeudFin AjouterHaute123456789101112Entier &lt;- hauteur(lien NoeudEntier noeud)Début variable: entier g,d=0//放这里吗？？？？是的 si(noeud.fg is not vide) alors g &lt;- hauteur(noeud.fg) finsi si(noeud.fd is not vide) alors d &lt;- hauteur(noeud.fd) finsi h &lt;- 1+ max(g,d) renvoyer hFin ajouter dans la branche la plus courte d’un arbre une valeur passée en paramètre(在树的最短分支上添加一个参数中传递的值) 12345678910111213141516//[用树高来判断存在问题]---&gt;树的最小深度问题lien NoeudEntier &lt;- ajoutHtMin(lien NoeudEntier noeud, Entier val)Début si(noeud is not vide) alors si(hauteur(noeud-&gt;fg) &lt; hauteur(noeud-&gt;fd)) noeud.fg &lt;- ajoutHtMin(noeud-&gt;fg, val) sinon noeud.fd &lt;- ajoutHtMin(noeud-&gt;fd, val) sinon nouveau.valeur &lt;- val nouveau.fg &lt;- NULL nouveau.fd &lt;- NULL noeud &lt;- nouveau() finsi renvoyer noeudFin Arbres binaires de recherche(ABR): enracinementDéfinition : Un ABR est un arbre dont les valeurs des noeuds appartiennent à un ensemble totalement ordonné et les conditions équivalentes suivantes sont vérifiées: ​ La liste des valeurs en ordre infixe est croissante ​ Pour tout noeud x de valeur v, les valeurs des noeuds de la branche gauche de x sont inférieures ou égales à v et les valeurs des noeuds de la branche droite de x sont surpérieures ou égales à v (左节点要小于根节点，右节点要大于根结点) 二叉查找树的查找会更快 Verificationconstituer 用parcoursInfixe()创建//中序 inferieur, superieur(), abr()//都是布尔型函数 1234567891011121314151617181920specification: fonction: super &lt;- superieur(racine , x) parametres: lien NoeudArbreBinaire racine, Entier x resultat: booleenDebutvariables locales booleen b &lt;- (x &gt;= racine-&gt;valeur) choix selon (racine-&gt;fg != NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fg , x) et superieur(racine-&gt;fd , x) et b (racine-&gt;fg != NULL et racine-&gt;fd = NULL): renvoyer superieur(racine-&gt;fg , x) et b (racine-&gt;fg = NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fd , x) et b (racine-&gt;fg = NULL et racine-&gt;fd = NULL): renvoyer b fin_choix_selonFin CM真后悔，没去 待补 看了一眼，大概c++的语法。好耶！","link":"/2022/02/28/ALGPR-4/"},{"title":"Ekya","text":"序戴老师给的第二篇论文 读论文 DNN深度神经网络，隐含层大于两层的神经网络 跑项目项目地址：https://github.com/edge-video-services/ekya 结语武运昌隆！","link":"/2022/08/01/Ekya/"},{"title":"INDUR_CM1","text":"INDUR - Informatique durable_CM1 一些问题和介绍Quels mots/concepts vous évoque[唤起] l’idée d’une informatique durable(ou responsable)? ​ Energie: Conception logicielle—&gt;cycle de vie d’un logiciel analyse de complecité—&gt;metro compatilite utilisation a finalité de DD matériel—&gt;ordinateurs de []/centre de données Energie social ​ Ethique Quelques problèmes d’intérêt? design et informatique: le doomscrolling https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0257728在讲寻找与 COVID 相关的新闻可能会破坏积极情绪这些 informatique verte Une obligation sociétale https://www.legifrance.gouv.fr/codes/id/LEGIARTI000044330813/2022-09-01/ 讲说工程培训包括与数字服务的生态设计和数字清醒相关的模块。 Analyse d’impact relative a la protection des données(AIPD)? -obligatoire pour les traitements susceptibles[高风险] d’engendrer des risques élevés -Composé de 3 parties : Description détaillée du traitement mis en œuvre Évaluation juridique de la nécessité et de la proportionnalité concernant les principes et droits fondamentaux Étude technique des risques sur la sécurité des données (confidentialité[保密性], intégrité[完整性] et disponibilité[可用性]) et leurs impacts potentiels sur la vie privée -英语的：DPIA/PIA Plan du coursPlan du coursinformatique verte(9月) Identifier les principes de l’informatique verte et les leviers[杠杆?] associés Enjeux[问题] et impacts directs et indirects Consommation énergétique matérielle et logicielle Sobriété[清醒] numérique -MOOC: impacts environnementaux du numérique Règlementation et éthique(10月) Cadre juridique en matière[材料，物质] de traitement automatique de données Ethique et responsabilité 11月7号早上考试!!! Objectifs du cours-Savoir construire une analyse éthique et responsable des traitements automatiques de l’information (identification de l’impact de ces traitements, des biais[偏差] possibles, etc.) -Savoir mettre en oeuvre un diagnostic de la consommation énergétique des applications informatiques Développer une pensée rationnelle[理性], basée sur la littérature scientifique 小组讨论 课后作业/之后的安排MOOC(https://lms.fun-mooc.fr/courses/course-v1:inria+41025+session01/info)看完然后选主题写报告 就是说是让咋搁教室去上MOOC的意思？","link":"/2022/09/06/INDUR_CM1/"},{"title":"HASK_入门学习","text":"HASK_入门学习B站：https://www.bilibili.com/video/BV16F411j7Zq?p=8&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 P1简单算术运算cmd+ghci进入环境，可以直接使用命令行进行简单的数学计算 Haskell的自定义函数结构函数名+输出参数+等号+表达式（可以调用函数/别的或者自己） 运行文件以.hs结尾保存 cmd进入桌面：cd Desktop ghci :l + 文件名 输入函数名和参数，回车即可运行。 P2列表定义用中括号定义，只能包含单一元素类型(但可以嵌套：列表元素是列表) 字符串，用双引号定义，其实是字符列表 常用操作拼接++ [1,2,3]++[4,5] —&gt; [1,2,3,4,5] “hello”++”haskell”—&gt;”hellohaskell” 单个元素的拼接可以使用冒号 6：[3,4,5] —&gt; [6,3,4,5] 2:[] —&gt;[2] 2:3:4:[]—&gt;[2,3,4] 获取元素!! “haskell world” !! 1 —&gt;’a’ 比较可以直接用 &gt;(如果相等则比较下一个位置),&lt;,== 列表乘 常用函数let lst = [1,2,3,4] head,last,tail（第一个元素之后的元素）,init（最后一个函数之前的元素）,length,null,reverse take+n+列表：获取前n个元素//0返回空 drop+n+列表：删除前n个元素 4+’elem’+列表：判断4是否在列表中 minimum,maximum,sum,product(累乘) Range直接.. cycle表示无限循环，take+cycle组合使用 take的是长度 take 5(repeat ‘a’) 等价于 replicate 5 ‘a’ 也可以用列表的形式实现 [2*x|x&lt;-[1..10]] [x|x&lt;[1..100], x mod13 == 0] 例题注释：单行—，多行{-多行注释-} |表示对a进行说明，a&lt;-str表示a取自字符串str（想成在遍历） _&lt;-str表示取自字符串str,都把它搞成1 x &lt;- xs,odd x表示只获取xs中的奇数 元组()表示，可以包含多种元素，不同长度的元组是不同的数据类型 1[(1,2),(8,9,10),(4,5)]会报错 函数：fst返回第一个元素，snd返回第二个元素，但只用于长度为2的元组（？？？？？？） ZIP函数接收两个列表进行元素配对压缩为新列表，新列表的元素为元组 [1..]['A',''B,'C']```-->[(1,'A'),(2,'B'),(3,'C')]12345678## 例题10以内可组成直角三角形的三条边的组合```haskellfun = [(a,b,c)|a&lt;-[1..10],b&lt;-[1..10],c&lt;-[1..10],a^2+b^2 == c^2]--&gt;fun = [(a,b,c)|a&lt;-[1..b],b&lt;-[1..c],c&lt;-[1..10],a^2+b^2 == c^2]--可以避免重复 P3：类型、类型变量、类型类TYPE使用:t查看 类型变量比如说head啊fst啊这些函数返回值（的类型）是不一定的，所以head和fst函数就是类型变量 类型类 没懂啊啊啊啊啊啊啊啊啊啊 P4 模式匹配 输入5之外都是“holiday” 阶乘 不写：：那排能运行吗？—&gt;不能 P5：|、where、let、case|：管道，单竖线，感觉有点像if where let 有点像where case switch吧 听不懂了不听了 P7: 递归、排序、高阶函数递归fibonacci 1234fibonacci :: Integer -&gt; Integerfibonacii 0 = 0fibonacii 1 = 1fibonacii n = fibonacii (n-1) + fibonacii (n-2) 重写replicate 123replicate :: i -&gt; a -&gt; [a]replicate n x if n &lt;=0 = [] else = x:replicate (n-1) x 重写take 123take :: i -&gt; [a] -&gt; atake n _ [] = []take n (x:xs) = x : take $ (n-1) xs 重写reverse 123reverse :: [a] -&gt; areverse [] = []reverse (x:xs) = reverse xs ++ [x] 重写zip 1234zip :: [a] -&gt; [b] -&gt; [(a,b)]zip _ [] = []zip [] _ = []zip (x:xs) (y:ys) = (x,y) : zip xs ys 重写elem 1234elem :: a -&gt; [a] -&gt; Boolelem a [] = Falseelem a (x:xs) = if a == x then True else = elem a xs 排序快排 1234567qs :: [a] -&gt; [a]qs [] = []qs [x] = [x]qs (x:xs) = let smallS = qs [a| a&lt;-xs,a&lt;x] bigS = qs [a| a&lt;-xs,a&gt;x] in smallS ++ [x] ++ bigS 高阶函数Haskell函数的参数可以是函数，返回值也可以是函数。 Haskell的每个参数都只接受一个参数。 空格类似一个操作符，具有最高优先级。 关于max的理解 a-&gt;(a-&gt;a): 接收一个参数，返回一个函数，返回的这个函数再接收一个参数，并返回一个参数 部分应用的函数，博主用了个很有意思的理解 12345678910111213141516171819202122compareWith3 x = compare 3 x --也可以简写成：compareWith3 = compare 3--因为compare本身返回值就是一个需要一个参数的函数divBy10 :: a -&gt; adivBy10 = (/10)isUpperCase :: Char -&gt; BoolisUpperCase = (`elem` ['A'..'Z'])apllyTwice :: (a-&gt;a)-&gt;a-&gt;aapllyTwice f x = f (f x)--重写zipWithzipWith :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt;[c]zipWith _ [] _ = []zipWith _ _ [] = []zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys--重写flip函数flip :: (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)flip g x y = g y x P8:$\\lambda$,$,fold,map,filter$有最低的优先级，代替括号 12map ($ 9) [(1+),(2*),(2-),sqrt]sum.replicate 4.max 6 $ 7 $\\lambda$lambda 匿名函数：( 参数 -&gt; 函数体) 例 : map (\\a -&gt; a+1) [1..6] foldfoldl + 函数 + 初始值 + 列表元素 —区别在于函数中的参数顺序foldl 是先初始值，再列表元素，foldr则相反 比如sum的改写，i是0，a是列表元素 123456789foldl (\\i a -&gt;i+a) 0 [1..3]--foldl (+) 0 [1..3]--foldl (+) [1..3]--列表的第一个元素当做初始值foldl (\\a i -&gt;i+a) 0 [1..3]--foldr (+) 0 [1..3]--foldr (+) [1..3]--列表的最后一个元素当做初始值--重写elemelem y= foldl (\\i x -&gt; (x == y) || i) False--没写参数(列表ys)是因为,返回值是个需要参数的函数 map123map :: (a-&gt;b)-&gt;[a]-&gt;[b]map _ [] = []map f (x:xs) = f x : map f xs filter1234filter:: (a-&gt;Bool)-&gt;[a]-&gt;[a]filter _ [] = []filter p (x:xs) = if p x then x : filter p xs else = filter p xs 用filter改写qs 1234567qs :: [a] -&gt; [a]qs [] = []qs [x] = [x]qs (x:xs) = let smallS = qs (filter (&lt;x) xs) bigS = qs (filter (&gt;x) xs) in smallS ++ [x] ++ bigS takeWhile12345678--从给定列表的元素第一个开始，直到FlasetakeWhile :: (a-&gt;Bool) -&gt; [a] -&gt;[a]--考拉兹猜想：对于每个正整数，如果奇数*3+1，如果偶数除2，最终都能得到1collatz :: a -&gt; [a]collatz 1 = [1]collatz n = if odd n then n:collatz (n*3+1) else n:collatz (div n 2) P10&amp;11：类型类自定义定义类型data关键字 类型名(首字母大写) = 值构造器[可以与类型名相同或者不同，首字母大写] 值构造器：接收几个value作为参数，生成一个新的value 123456789data Point = Point Float Float deriving Showdata Shape = Circle Point Float| Rectangle Point Point deriving Showsurface :: Shape -&gt; Floatsurface (Circle _ r) = pi * r * 2surface (Rectangle Point(x1 y1) Point(x2 y2)) = abs (x2-x1) * abs (y2-y1)--用map构造一系列Circlemap (Circle 10 10) [4,5,6] 类型递归 123456789101112131415161718data Ls a = Empty | Cons a (Ls a) deriving Show--ABRdata Tree a = EmptyNode | Node a (Tree a) (Tree a) deriving ShowinsertNode :: a -&gt; Tree a -&gt; Tree ainsertNode x EmptyNode = singleton xinsertNode x (Node a left right) |x == a = Node x left right |x &lt; a = Node x (insertNode x left) right |x &gt; a = Node x left (insertNode x right) elemNode :: a -&gt; Tree a -&gt; BollelemNode x EmptyNode = FalseelemNode x (Node a left right) |x == a = True |x &lt; a = elemNode x left |x &gt; a = elemNode x right 也可以用大括号的形式 1data Person = Person {name::String,age::Int,height::Float} deriving Show 类型构造器：接收几个类型作为参数，生成一个新的类型，例： 12345Str::[Char]data Vector a = Vector a a a deriving ShowscalarM :: Vector t -&gt; Vector t -&gt; tscalarM (Vector i j k) (Vector l m n) = i*l + j * m + k * n deriving: 把构造的类搞成别的类型类的实例，就比如说上面的Person可以deriving(Eq) 然后去编它=的这样 类型同义词 type AssocListe k v = [(k,v)] 有点像说在自命名一个数据类型 Either a b class类型类定义了函数或者类型声明，类型类的实例可以使用这些函数 比如说haskell自带的Eq类里面就有定义==和/=的说明，instance Eq Int就是Eq类的一个实例，表示两个int类型可以进行比较。也可以对自定义的类型进行说明，比如 1234567891011data Signal = R | Y | Ginstance Eq Signal where (==) R R = True (==) Y Y = True (==) G G = True (==) _ _ = Flase instance Show Signal where show R = &quot;Red&quot; show Y = &quot;Yellow&quot; show G = &quot;Green&quot; YesOrNo Functor12345678class Functor f where fmap :: (a-&gt;b)-&gt; f a -&gt; f b--列表作为实例时，fmap与map相同fmap :: (a-&gt;b) -&gt; [a] -&gt;[b]--Maybe作为实例时fmap :: (a-&gt;b) -&gt; Maybe a -&gt; Maybe bfmap _ Nothing = Nothingfmap f (Just a) = Just (f a) P12：IOputStrLn, putChar, putLine(换行输出):: String -&gt; IO () print :接收任何一个实例的值，返回一个IO操作 = puStrLn.show getLine：获取用户在终端中输入的一行 getChar：获取用户在终端中输入的一个字符 多个IO操作可以用do绑定，用return不返回 sequence接收IO操作的列表 ls &lt;- sequence [getLine,getLine,getLine]","link":"/2022/09/01/HASK/"},{"title":"MATHS-TP1","text":"序MATHS_TP1: Initiation Matlab – Equation de la chaleur 1D Initiation注释：% 显示：disp、fprintf vecteur: x = [x1,x2……,xn] %空格或者逗号都可以；vecteur colonne 冒号：5：-1：1 %表示5到1以-1为间隔的vecteur linspace：是Matlab中的均分计算指令，用于产生x1,x2之间的N点行线性的矢量。其中x1、x2、N分别为起始值、终止值、元素个数。若默认N，默认点数为100","link":"/2022/02/22/MATH-TP1/"},{"title":"INDUR_MOOC","text":"MOOC课上要求看的MOOC Partie1: Introduction: Les impacts environnementaux du numérique Partie2: Des équipements non renouvelables Des services numériques très matériels Partie1: Introduction: Les impacts environnementaux du numériqueIntroductionLe numérique et l’environnement: le numérique nous offre une formidable capacité de collecter, stocker et traiter ces données. Et cela nous aide à comprendre notre impact sur l’environnement. Alors, que sait-on de l’impact environnemental de l’homme sur le climat ? Et que nous disent ces indicateurs sur l’impact environnemental du numérique ? Ensuite, nous vous proposons de vous familiariser avec des outils mathématiques et informatiques essentiels pour comprendre et analyser les indicateurs. 数字技术与环境：数字技术帮助收集数据，有助于我们更好的了解环境。那么，我们对人类对气候的环境影响了解多少？这些指标告诉我们数字技术对环境的影响是什么？要学会使用计算机工具对这些指标进行分析。 Que pensez-vous du numérique ?1.A l’heure où les problèmes environnementaux sont pointés du doigt, quel est l’impact du numérique sur l’environnement ? Là aussi, les avis divergent également : pour certains, le numérique est LA solution, pour d’autres, il ne ferait qu’aggraver le problème. Et vous qu’en pensez-vous ? -我觉得数字化对环境还是好的。数据的分析可以更直观发现问题并且提出有效的措施。 2.Indiquez quelques mots que vous associez spontanément[自发的] aux impacts environnementaux du numérique. Numérique et prise de conscience[意识] écologique[生态] : petite histoire建模等计算方式更好的模拟和预测环境，并给出更好的解决方法 IPCC悖论：数字化越成功，发现的问题就越多？观察的越多， 环境足迹 数字化没有成功转型，只是在叠加[使用电子设备的同时也没有减少对树木的砍伐，石油的使用] Fiche concept: 概念表数字不虚拟，有物理现实：光纤电缆 终端、云计算与数据中心[关于网络的另一端]—&gt;数据中心对环境的影响：2015 年，数字占全球温室气体排放量的 4%，而航空占 2.5%。在这 4% 中，有 25% 与数据中心相关联。数据中心的用电量约占全球用电量的 3%。 建模、数值模拟与环境 Quels indicateurs[指标] pour évaluer l’empreinte[足迹] numérique ? L’effet de serre[温室效应] provoque le réchauffement[变暖] de la plantet—&gt;OUI，没有的话地球在15°左右 Les activités humaines produisent-elles des gaz a effet de serre?—&gt;OUI Afin de comparer les effets sur le réchauffement global des différents gaz a effet de serre, les scientifiques ont choisi un gaz de référence. Lequel?—&gt;CO2 A ce jour, quel est approximativement le réchauffement global généré par les activités humaines depuis la révolution industrielle[1850-1900]?—&gt;+1°C，每10年+0.2°C Si ces émissions continuent a la vitesse actuelle, quand atteindrons-nous un réchauffement de +1.5°C depuis le début de la révolution industrielle?—&gt;2030到2052 Quelle est la consommation électrique mondiale liée aux usages numériques?—&gt;10%,每年增加6%，每12年翻一番 Fiche concept:Indicateur: est la traduction chiffrée d’un phénomène ou d’un concept. Indicateurs environnementaux: Les indicateurs peuvent être classés en fonction de l’enjeu écologique auquel ils correspondent. Par exemple le ministère de l’écologie a sélectionné 22 indicateurs essentiels pour suivre 4 enjeux écologiques majeurs : le changement climatique, la perte de biodiversité, la raréfaction des ressources et la multiplication des risques sanitaires environnementaux 生态部选择了 22 项基本指标来监测 4 大生态挑战：气候变化、生物多样性丧失、资源稀缺和环境健康风险倍增 Deux indicateurs environnementaux simples: Émissions de gaz à effet de serre et Empreinte en eau Un exemple d’indicateur environnemental synthétique : l’Empreinte Écologique (EE) 以国家为单位计算，生产+进口-出口 数字设备： L’empreinte environnementale du numérique mondial[数字环境足迹]：2019全球340亿台设备, 2.23亿吨。法国：6.31亿台设备，700万吨，数字消费占法国电力的8.3% Eco-avertis : Lire et questionner les indicateursÊtes-vous victime du biais exponentiel[指数偏差]? Quel lien peut-on faire entre performance environnementale et usage d’Internet ? 横坐标：互联网使用人口，纵坐标：碳足迹 La sobriété numérique[数字清醒]La sobriété consiste à faire décroître voire disparaître des usages, des valeurs ou des comportements. Elle ne nécessite pas le développement de nouvelles techniques ou technologies. Elle se rapporte au suffisant relativement aux besoins et aux enjeux d’équilibre écologique et d’équité. On pourrait parler de « faire moins avec moins ». 减少甚至消除用途、价值观或行为。它不需要开发新技术或新技术。它涉及与生态平衡和公平的需求和问题有关的充分条件。我们可以谈论“事半功倍”。 Conclusion全球变暖，环境衡量指标，数字行业的增长极其负面影响 Partie2: Des équipements non renouvelables数字化的背后的设备是不可再生的 Pour démarrer : Combien possédez-vous d’équipements connectés ? L’empreinte environnementale des équipements numériquesVie et mort d’un smartphone：手机制造需要贵金属，开采和制造手机会污染水土流失污染环境，废弃手机不可回收再次造成污染 Cycle de vie d’un smartphone 对环境污染的排序：Production &gt; Usage[电力消耗] &gt; Transport &gt; Traitement de fin de vie Fiche conceptACV: analyse de cycle de vie, est une méthode d’évaluation quantifiée des impacts environnementaux d’un produit (qui peut être un bien ou un service). 具有多标准和多步骤的特点： Multicritère : différentes catégories d’impacts environnementaux sont étudiées (potentiel de réchauffement climatique, épuisement des ressources abiotiques, création d’ozone photochimique, pollution de l’eau, de l’air, des sols, toxicité humaine, perte de biodiversité…). Ces impacts relèvent de différentes échelles spatiales (du local au global) et temporelles (du court terme au long terme). Multi-étapes : les différentes phases du cycle de vie sont prises en compte (extraction des matières premières, fabrication, transport, usage, fin de vie). 分下面4个主要步骤进行： Objectifs et champ de l’étude：研究的目标和研究结果的用途 Inventaire du cycle de vie：核心，分解特定功能单元生命周期中涉及的生产、转换或者消费阶段。 Évaluation des impacts environnementaux Interprétation et mise en forme des résultats Pourrons-nous continuer longtemps à fabriquer des équipements informatiques ?Mais fabriquer toujours plus se heurte aux limites de notre planète：不可再生资源，无限可回收的不现实[热力学第二定律和技术限制] —&gt; si le numérique pèse sur l’épuisement des ressources ou si finalement 数字化会让资源枯竭吗 一些问题： -Combien de smartphones ont été vendus dans le monde en 2019?—&gt;1.4 milliard d’unités. -Combien y a-t-il d’éléments différents dans un smartphone?—&gt;plus de 50 -Ou t -Pour quelles raisons utilise-t-on l’or[黄金] dans un smartphone?—&gt;Conductibilité, Ne rouille[生锈] pas -Ou trouve-t-on du tantale dans un smartphone?—&gt;Dans les condensateurs[电容器]. -Pour quelles raisons utilise-t-on du tantale dans un smartphone?—&gt;Il est extrement résistant et il permet la miniaturisation -Ou trouve-t-on de l’indium dans un smartphone?—&gt;Dans le film transparent[透明膜] qui recouvre l’écran. Fiche concept：DEEEQuels métaux dans les smartphones ? 稀土金属，集成电路需要半导体[硅] DEEE：废物，废弃的电气和电子设备，它们包括来自使用电源插座、电池或蓄电池的设备的所有废物，以及它们的所有组件和与之相关的消耗品。 Depuis 2018 en France, les EEE sont classés en 7 catégories d’équipements (échanges thermiques, écrans, lampes, gros électroménager, petit électroménager, informatique) avec un objectif de traçage et de suivi. 法国将 EEE 分为 7 类设备（换热器、屏幕、灯具、大型家用电器、小型家用电器、IT）。 DEEE的处理：La prise en charge des équipements collectés mène à plusieurs voies possibles : la préparation à la réutilisation (environ 2% en France en 2019) ; le recyclage (environ 75%) ; la valorisation énergétique (environ 10%) ; l’élimination c’est-à-dire mise en décharge et enfouissement, ou incinération sans récupération d’énergie (environ 14%). 准备再利用（2019 年在法国约为 2%）；回收（约 75%）；能量回收（约 10%）；处置，即填埋和填埋，或没有能量回收的焚烧（约 14%）。 实际上，只有 75% 的收集到的 WEEE 被注入到真正的 WEEE 回收系统中（这个数字根据设备的类型而变化很大）。考虑到法国的回收率（50%），这最终仅代表 WEEE 产生量的 38%（充其量）。回收的6个阶段：拆解，碎成小块，磁铁对铁元素进行电磁分离，光学分选分离电子卡，涡流分离有色金属，浮选或光学分离塑料。 限制：回收率低，回收的过程耗费能量，危害环境 Éco-consommateur : Recycler n’est pas gagner ![未完] Partie3: Des services numériques très matériels除了数字设备对环境的影响外，数字服务对环境也会造成影响 数字服务：services numériques ，包括nos applications, logiciels de messagerie, interface de streaming Quelle est la part du numérique qui a le plus d’impact environnemental ?Communication numérique: Le déploiement d’internet et des réseaux télécoms est à l’origine de nouveaux modes de communication. La communication virtuelle est l’un des services les plus répandus. En quelques clics, nous pouvons faire passer des messages quasi instantanément à l’autre bout du monde. 数字通信：互联网和电信网络的部署导致了新的通信模式。虚拟通信是最广泛的服务之一。只需点击几下，我们就可以几乎立即向世界的另一端发送信息。 petite sondage： -Combien de mails recevez-vous en moyenne par jour?—&gt;Une personne reçoit en moyenne 39 mails par jour, avant d’arriver dans votre boîte mail, le mail parcourt en moyenne 1500km -Mais nous sommes loin d’être seuls sur la planète. Selon vous, combien de mails transitent par minute dans le monde?—&gt;190 millions Toujours plus d’outils de communication: Dans les années 90, le SMS était limité à 160 caractères et le mail était envoyé uniquement depuis un ordinateur. 30 ans après, nos modes de communication ont bien changé. Nous avons multiplié nos outils et nous sommes passés de quelques caractères écrits à des centaines de photos et de vidéos envoyées quasi instantanément depuis nos mobiles. Alors, tout cela est-il virtuel? Cela n’q t’il pas d’impacts? Pas si simple… 越来越多的通信工具：在20世纪90年代，短信被限制在160个字符以内，电子邮件只能从电脑上发送。30年后，我们的沟通方式已经改变。我们的工具成倍增加，从几个书面字符到几百张照片和视频，几乎瞬间从我们的手机上发送。那么，这一切都是虚拟的吗？它没有影响吗？没有那么简单… 看到这里也并没有对标题[对环境影响最大的数字化部分是什么]做出回答嘛 Les services numériques sont-ils virtuels ?应用程序：在云服务器无法自己运行，背后一个完整的生态系统，包括一系列基础设施建设[电话，电缆，无线网络，手机信号塔，数据中心] 数字服务背后的一切：硬件；网络：海底电缆，光纤，路由器；数据中心：机器外处理，消耗电力，发热，发电机，备用电池； 数据越多，基础设施越多，基础设施越多，数据越多。 自动播放。占据。 Le voyage d’un mail Ce n’est pas magique, c’est technologique!L’envoi d’un mail nécessite une infrastructure[基础设施] complexe qui dépend des terminaux utilisés, des services de messagerie employés aussi bien par l’émetteur[发射器] que par le récepteur.Ici le schéma technologique est relativement simple. Mais si Bob avait mis en copie une dizaine d’amis, c’est comme si 10 messages étaient partis individuellement : chaque message va transiter par son propre serveur de réception, vers un récepteur différent. De quoi augmenter rapidement la complexité du schéma ! Idem pour les pièces jointes qui seront stockées autant de fois que nécessaire !Bref, même si tout cela se produit en seulement quelques secondes !Ce n’est pas magique ! Fiche concept: Qu’est-ce qu’un service numérique?Le service numérique désigne l’ensemble des ressources humaines, logicielles et matérielles nécessaire à la mise à disposition d’un service. 数字服务指定提供服务所需的所有人力、软件和物质资源。例如，提供电子邮件服务、在 Youtube 上观看视频、高性能计算的实现、加密货币金融交易的实现、网页的显示……行业标准ITU L. 1410将数字服务引入为使用数字设备和/或电信网络为一个或多个用户提供价值。 Ainsi, le service numérique est constitué d’un ensemble de logiciels, matériels, réseaux et infrastructures, et d’autres services numériques opérés par des acteurs. 因此，数字服务由一组软件、硬件、网络和基础设施以及由各种参与者（人力资源）（出版商、设计师、架构师、网络和服务运营商、互联网接入供应商、用户、 ETC）。这种通过数字服务进行的衔接使得满足一个或多个需求成为可能。 数字服务不是软件，由一组人力、材料和软件资源组成. Le cycle de vie d’un service numérique: 设计—&gt;生产—&gt;部署—&gt;使用—&gt;维护—&gt;报废 Les acteurs engagés dans le déploiement d’un service numérique: 用户，服务操作者，开发，架构，主机，网络运营商 Comment et pourquoi accumule-t-on autant de données ?数据的堆积：人类产生的 90% 的数据将在过去 2 年中产生，90% 的存储数据将无用。例如，假设每辆自动驾驶汽车每天为大约 1 小时 30 天的流量收集 4TB 的数据（即使只有一部分通过网络）。世界上有数百亿个连接对象也在捕获和传输数据, 传输和存储所有这些信息对环境的影响并非微不足道。数据增长需要处理、格式化、集中和共享，这既耗时又耗资源。 以照片为例：分享照片被上传至云端，但云端处理需要存储成本。 Quelle est l’empreinte environnementale d’un service numérique ?Dans cette activité, nous vous proposons d’analyser l’empreinte environnementale d’une navigation web et de matérialiserl’impact des différentes fonctionnalités proposées : lecture d’article, de vidéo, de présentation interactive.Pour effectuer cette activité, nous avons choisi l’outil Carbonalyser qui permet de visualiser la consommation électrique et les émissions de gaz à effet de serre associées à votre navigation internet. Il en existe d’autres.Attention les hypothèses et données de base ne permettent pas de se baser sur cet outil pour mesurer finement les émissions deg eq C02 liées à votre navigation. Le résultat n’est donc pas à prendre comme une mesure. Par contre, cet outil vouspermettra d’évaluer la différence relative d’impacts de sites web différents.Vous allez pour cela installer une extension sur votre navigateur, puis nous vous guiderons pour naviguer dans le web avant d’analyser les résultats de Carbonalyser. Cette application ne fonctionne que sur Firefox. 用火狐浏览器的拓展工具Carbonalyser分析浏览网页不同功能(文章，视频，交互)时的电力消耗和温室气体排放的比较。 问的一些问题： -Dans l’article Comment marche internet à quoi est comparé le navigateur[浏览器]？—&gt;voiture Comment marche internet: Internet 和 Web是不一样的。Internet相当于公路网，Web相当于商店。 -Dans la [vidéo][https://www.youtube.com/watch?v=GqD6AiaRo3U&amp;list=PLWvGMqXvyJAPvxp2IPUAbKmr_ULtR8Nbh&amp;index=4] comment accède-t-on au site www.ilovepigeon.com ?—&gt;un moteur de recherche. 网站的知识: web: 信息的集合，由数10亿个衔接文件组成。Le web c’est un réseau d’informations Internet: C’est le réseau informatique qui permet de les transporter. Site: C’est un ensemble de pages contenant de l’information. 也叫site web. 文档储存在Web服务器上，客户端和服务器通过 Web 进行通信，根据 HTTP 协议 -","link":"/2022/09/16/INDUR_MOOC/"},{"title":"PAPY_CM1","text":"PAPY_CM1Lucas Lestandi Introdution-mutiplateforme, langage interprété（解释） et interractif -python robuste,la lisibilité et la maintenance, paquet pour la distribution sur d’autres machines y compris des dépendances Plan1.python:安装环境啥的—&gt;2hCM+4hTP 2.数据结构：OPP,code robuste(architecture,introspection,exceptions)—&gt;2hCM+6hTP 3.avec modules:os,sys,subprocess,numpy,scipy,matplotlib,扩展包（conda或者pip） 4.看到个C++ CM1conda: python环境，anaconda划分python环境，miniconda IDE：vscode jupyter：mixe code, markdown et cellules “raw” 数据类型：complex表示复数 1234567891011121314import sysall_paths = sys.pathfor path in all_paths: print(path)def a(string): longueur=() try: assert(type(string) is str) longueur=len(string) except Exception as err: print(f&quot;Unexpected {err=},{type(err)=}&quot;) return longueurprint(a(all_paths[0]) assert: 断言, 用于判断一个表达式，在表达式条件为false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在Linux 系统下运行，可以先判断当前系统是否符合条件。 try…except结构：捕捉异常，更一般加else 函数 12def 函数名(参数):#这里的参数*arg就是表示随意取几个 函数体#不写的话加上pass占位","link":"/2022/09/06/PAPY_CM1/"},{"title":"MVDNet","text":"序记录第一次看论文与第一次独立运行深度学习代码~ 读论文脉络梳理于XMind中 CNN概述对图像进行识别 鲁棒性和抗干扰性都很强 卷积卷积核/特征提取器：将图像拆分成对应的特点，查看被识别图像有无对应的卷积核来确认是否为目标物体。 卷积运算：用卷积核对原图像素（矩阵）进行扫描（点乘和），形成的新矩阵就叫特征图。特诊图的一些值(如行列式的值这种)能够反映与卷积核的相似度。比如： 池化池化/下采样：多个卷积核(特征)会导致计算量增大，为解决这个问题提出的概念，本质是缩小特征图。池化方式有：最大池化（选择被扫描区域内的最大值）和平均池化（取被扫描区域内的平均值） 比如刚刚那个： 跑项目不太顺利 项目地址：https://github.com/qiank10/MVDNet 环境配置anaconda+linux+python3.7+cuda11.0+pytorch1.7 Pytorch 创建环境：conda create -n MVDNet python=3.7 激活/进入：conda activate MVDNet pytorch下载 1.查看cuda版本信息：nvcc —version或者nvidia-smi； 2.注意这里不能根据官网https://pytorch.org/get-started/locally/ 入口直接选择下载（如果正好是cuda10.2这种应该是ok的），不然后续不能配合cuda使用。 正确操作应该是到这里https://download.pytorch.org/whl/torch_stable.html 去找对应的下载进行安装(pip install就可以) 参数理解：cu110—&gt;cuda 11.0，torch版本自选，cp37—&gt;python3.7，后面就是win/linux了 检查 python—&gt;import torch—&gt;torch.cuda.is_available() Detectron2 Pycocotools挺好装的而且没啥幺蛾子 数据准备 下载数据集：https://oxford-robotics-institute.github.io/radar-robotcar-dataset/， 用学校邮箱注册 可恨！等了一个月才回复，然后还在垃圾邮箱里面找不到了=_= 最后下载免费的数据集来后续操作的 在这里疯狂报错，主要是缺包和语法更新两个问题 报错no module named scipy或者cv，装scipy和opencv库 12pip install scipypip install opencv-python 报错 AttributeError: ‘scipy.spatial.transform.rotation.Rotation’ object has no attribute ‘as_dcm’：要把所有的as_dcm改成as_matrix 训练 报错import，需要到detectron2执行 1python setup.py build develop 报错“No such file or directory: ‘data/RobotCar/object/radar/1547122770869274.jpg’”：没解决 结语武运昌隆","link":"/2022/05/20/MVDNet/"},{"title":"PAPY_CM1","text":"PAPY_CMS期末复习做的xmind CHAP 2 CHAP 3 CHAP 4 突然感慨2个月的python有种的会了很多有啥的不会的感觉 祈祷不挂！","link":"/2022/10/29/PAPY_CMS/"},{"title":"PFONC_CM1","text":"PFONC_CM1Introduction基于函数的编程，接近数学声明式编程（programmation déclarative） 属性:transparence référentielle：参考透明,immutabilité：不变性 ​ transparence référentielle:并行，没有指针，全局变量或者输入输出 ​ immutabilité：被操纵对象的值永远不能改变 Constructions de base复合函数12345square x = x*xinc x = x+1f x = inc(square x)f x = (inc.square) x 条件式if-then-else123f n = if n == 0 then 1 else if n == -1 then 2 else 3 然后不等于是 /= gardée(|+ otherwise)123456caculate' a b c | b == '+' = Just (a + c)--不太知道这里的just是啥 | b == '-' = Just (a - c) | b == '*' = Just (a * c) | b == '/' &amp;&amp; c == 0 = Nothing | b == '/' = Just (a / c) | otherwise = Nothing case-of123f n = case n of 0 -&gt; 1 _ -&gt; n * f (n-1)--下划线_表示任意 递归: récursivitéUne fonction récursive possède（有） : • un (ou plusieurs) cas général récursif • un (ou plusieurs) cas de base non récursif L’évaluation d’une fonction récursive se fait sur le modèle d’une pile[堆栈] Fonction récursive terminale 定义：Pour une fonction f définie en utilisant une fonction g, l’évaluation de g est dite terminale (tail évaluation/call) si elle fournit directement la valeur de f sans opération supplémentaire. 对于一个用函数g定义的函数f，如果g直接提供了f的值而没有任何额外的操作，那么g的évaluation被称为terminale 如果一个递归函数的所有递归的évaluation都是terminale的，那么他就是Fonction récursive terminale 例 123456f' 0 r = rf' n r = f' (n-1) (r*n)f n = f' n 1main = print(f 3) Exercices EX1: PUISSANCE 1.Écrire une fonction récursive qui calcule la puissance $n^e$ d’un nombre 12puissance x 0 = 1puissance x n = x * puissance x (n-1) Utiliser le fait que $x^{2n}=(x^2)^n$ pour améliorer la fonction. 12puissance' x 0 = 1puissance' x n = if even n then puissance' (x*x) (div n 2) else x * puissance' (x*x) (div n 2)--even应该是在说n是偶数，odd奇数 3.Quelles sont les complexités temporelles des deux versions ? 方法1是关于n的线性，方法2是关于$log_2n$ 的。 EX2: Fibonacci Écrire une fonction récursive terminale qui calcule le terme d’indice n de la suite de Fibonacci 12345678fibonacci 1 = 1fibonacci 2 = 1fibonacci n = fibonacci(n-1) + fibonacci(n-2)--terminalefibonacci' 0 _ n2 = n2--不是很懂这里fibonacci' n n1 n2 = fibonacci'(n-1) (n1+n2) n1fib n = fibonacci' n 1 0 EX3:La hauteur palindromique 1234567r' 0 m = mr' x m = r' (div x 10) (10*m + mod x 10)r x = r' x 0--判断回文数字:n == r(n)hpal n = if n == r n then 0 else 1 + hpal (n + r n)--太妙了太妙了太妙了","link":"/2022/09/06/PFONC_CM1/"},{"title":"PAPY_CM1","text":"PAPY_TPSPAPY的实验不完全汇总 TP11. 文件处理：统计说的话，删掉所有的e并将其写入新的文件1234567891011121314f = open(&quot;fable.txt&quot;,'r')fable = f.read()print(type(fable))#print(fable)nombre = fable.count(&quot;- &quot;)/2print(nombre)fabl = fable.replace('e','',fable.count(&quot;e&quot;))f1 = open(&quot;fabl.txt&quot;,'w')f1.write(fabl)f1.close()f.close() 2. 爬虫[parseur]1234567import urllib.request as equrl='https://fr.wikipedia.org/wiki/Python_(langage)'#抓取的网址file=eq.urlopen(url).read()#读取信息path=open('site.html','wb')#已写入二进制的方式创建文件path.write(file)#写入爬下的信息print(file)path.close()#关闭文件 3. Bonus反向猜数 123456789101112131415161718import randomdef fun(): goal = int(input(&quot;please input num:&quot;)) num = random.randint(0,100) bmin = 0 bmax = 100 while goal != num : print(num) if bmin&gt;bmax: break sym = input(&quot;please input sym:&quot;) if sym == '-' : bmax = num-1 elif sym == '+': bmin = num+1 else: pass num = random.randint(bmin,bmax) print(num) if goal == num : print(&quot;won&quot;) else : print(&quot;non&quot;) TP21. Listes et dictionnairesExercice1 : Ecrire un script qui transforme une liste de dictionnaires en dictionnaire de liste. Propser 2 méthodes a) bloucle for et b) compréhension. 1234567res = {}for item in data: keys = item.keys() for name in keys: if name not in res : res[name]=[]#初始化字典 res[name].append(item[name])#往字典添加元素print(res) 但这个只能处理data[0]里面有所有key的情况 1print({key: [i[key] for i in data] for key in data[0]}) Exercice2 : Ecrire un script qui renvoie les 10 mots les plus fréquents dans un texte avec la fréquence associée. L’appliquer à Zen of python (et en profiter pour lire le texte). 12345678910111213f = open('zen.txt',r)text = f.read()mots = text.split()res = {}sums = len(mots)for mot in mots: if mot not in res.keys(): res[mot] = mots.count(mot)/sumstrie = sorted(res.items(), key=lambda item: item[1],reverse=True)print(&quot;Percentage share of each word : &quot; )for item in trie[:10]: print(f&quot;{item[0]:20s}: {100*item[1]:.2f}%&quot;)f.close() Exercice 3: Ecrire une fonction qui calcule la moyenne d’un nombre inconnu d’arguments. 1234567891011121314151617def avgfun(*n:float)-&gt;float: &quot;&quot;&quot;Fonction qui calcule la moyenne d'un nombre inconnu d'arguments&quot;&quot;&quot; sums = 0 for t in n: sums = sums + t avg = sums / len(n) return avg # Driver Coderesult1 = avgfun(1, 2, 3)result2 = avgfun(2, 6, 4, 8) # Printing average of the listprint(round(result1, 2))print(round(result2, 2)) Exercice 4: Ecrire une fonction crier qui transforme un str en majuscules, une seconde chuchoter qui transforme le str en minuscules et enfin une troisième salutations (d’ordre supérieur) qui prend en argument une fonction et l’applique à un texte pré-défini. 1234567891011121314def crier(text): return text.upper() def chuchoter(text): return text.lower() def salutations(func): # storing the function in a variable greeting = func(&quot;Bonjour, je suis créé par une fonction passé en argument.&quot;) print(greeting) returnsalutations(crier) salutations(chuchoter) Exercice 5 : Ecrire une fonction décorateur log qui prend en argument une fonction et en extrait le nom, les arguments (positionnels et par mot-clé) ainsi que le résultat pour les afficher. 12345678def log(original_function,): def new_function(*args, **kwargs): result = original_function(*args, **kwargs) print(f&quot;&quot;&quot;Fonction {original_function.__name__} appelée avec les arguments positionnels \\{args} et les arguments par mot clé {kwargs}. Résultat:{result}\\n&quot;&quot;&quot;) return result return new_function 2. Programmation orientée objet2.1 vector 类装饰@property+@varname.setter 12345678910111213141516171819@property#把类方法当成属性调用,get方法 def x(self): return self._x @x.setter#set方法 def x(self,num): if isinstance(num,numbers.Real): self._x = num else: print(f&quot;val={num} must be a real&quot;) @property#把类方法当成属性调用,get方法 def y(self): return self._y @y.setter#set方法 def y(self,num): if isinstance(num,numbers.Real): self._y = num else: print(f&quot;val={num} must be a real&quot;) 迭代器: __iter__ 和 from_iterable 在python3中，如果定义了一个类，类中有 iter(self)，next(self)两个函数，则该类具有了迭代器的属性，具体性质体现在：如果该类的对象出现在一个for循环中，那么for循环会自动通过iter标志识别这是一个可迭代的类，继而自动调用next()函数 123456def __iter__(self): &quot;&quot;&quot;Iterateur sur les élements du vecteur, utilise yield&quot;&quot;&quot; #向量元素的迭代器 #return iter(array('d',[self.x,self.y])) yield self.x yield self.y 迭代器的作用在这里体现在：v1 = Vecteur(3, 4)x, y = v1这行print(x,y) 如果用的是直接return self.x, self.y，它报错：iter() returned non-iterator of type ‘tuple’, 所以这里用yield 1234567@classmethod#类方法 def from_iterable(cls, it): x = it[0] y = it[1] return Vecteur(x,y)#可以实现v2=Vecteur.from_iterable([1,5]) 打印__repr__ 和 __str__ repr: 定义解释器返回的对象表示形式 str: 对象的字符串表现形式, 如果未定义，则返回repr 123456def __repr__(self): &quot;&quot;&quot;Représentation textuelle de l'objet&quot;&quot;&quot; return 'Vecteur('+str(self.x)+','+str(self.y)+')'def __str__(self): return '('+str(self.x)+','+str(self.y)+')' v1_clone = eval(repr(v1))#eval:python内置函数，可以接受一个字符串str作为参数，并把这个参数作为脚本代码来运行 操作符重载： 123456789101112def __eq__(self, other): &quot;&quot;&quot;Surcharge de l'opérateur ==&quot;&quot;&quot; #运算 return type(self)==type(other) and (self.x==other.x) and (self.y==other.y)#右加法，处理vector+其他 --&gt;左加法：__radd__：处理其他加vecter def __add__ (self,other): if isinstance(other,Vecteur): return Vecteur(self._x+other._x,self._y+other._y) if isinstance(other,list) : return (self._x+other[0],self._y+other[1]) raise TypeError(f&quot;unsupported operand type(s) for +: {type(self)} and {type(other)}&quot;) 12345678910111213141516171819#取反def __neg__(self): return Vecteur(-self._x,-self._y) #左乘法，处理vector* def __mul__(self,other): if isinstance(other,numbers.Real): return Vecteur(self._x*other,self._y*other) if isinstance(other,Vecteur): return self._x*other._x+self._y*other._y raise TypeError(f&quot;unsupported operand type(s) for *: {type(self)} and {type(other)}&quot;) #右乘法，处理*vector def __rmul__(self,other): return self*other #减法 def __sub__(self,other): if isinstance(other,Vecteur): return Vecteur(self._x-other._x,self._y-other._y) raise TypeError(f&quot;unsupported operand type(s) for +: {type(self)} and {type(other)}&quot;) 2.2 printer继承后的方法重写 super().函数名 1234567class ColorPrinter(Printer): def __init__(self, devices=&quot;Printer 0&quot;,avail_paper=Printer.formats_dict.keys(),color=&quot;Black&quot;): super().__init__(avail_paper) self.color = color self.devices = devices def send(cls,strs,tallie=&quot;A4&quot;,color = &quot;Black&quot;): super().send(strs,color = cls.color) 2.3 afficher l’arborescence普通函数方法 123456789101112131415161718192021222324252627282930import osfrom pathlib import Pathspace = ' 'branch = '│ 'tee = '├── 'last = '└── 'res = &quot;&quot;length_limit = 1000level = 0def print_dirtree(pathname,step=0,flag=0): global res,level if level &gt; length_limit: return p = Path(pathname) is_last = last if flag else tee#判断是否是last res += branch*int(bool(step)) + space * (step-1)+ is_last + p.name+'\\n' level += 1 if not p.is_file(): for item in os.listdir(pathname):#返回一个列表，包含p下所有文件夹和文件 noveau_pathname = pathname+&quot;/&quot;+item print_dirtree(noveau_pathname,step+1,item == os.listdir(pathname)[-1])path = &quot;TP2&quot;print_dirtree(path)print(res) 封装成类 123456789101112131415161718192021222324252627282930313233import osfrom pathlib import Pathclass generate: space = ' ' branch = '│ ' tee = '├── ' last = '└── ' res = '' level = 0 length_limit = 1000 def __init__(self,pathname): self.pathname = pathname def print_dirtree(self,pathname,step=0,flag=0): if self.level &gt; self.length_limit: return p = Path(pathname) is_last = self.last if flag else self.tee#判断是否是last self.res += self.branch*int(bool(step)) + self.space * (step-1)+ is_last + p.name+'\\n' self.level += 1 if not p.is_file(): for item in os.listdir(pathname):#返回一个列表，包含p下所有文件夹和文件 noveau_pathname = pathname+&quot;/&quot;+item self.print_dirtree(noveau_pathname,step+1,item == os.listdir(pathname)[-1])test = generate(&quot;TP2&quot;)test.print_dirtree(&quot;TP2&quot;)print(test.res) TP3.11.np库处理矩阵linalg.det(A)：模,在有小数时有很多问题 linalg.inv(A):逆 2.模拟计算PI12345678910111213141516import mathdef monteCarlo(NumTest,N): my_pis = 0 for i in range(NumTest): ptsinterieur = 0 for i in range(N): #随机生成在正方形里面的点 x = np.random.random() y = np.random.random() #在半圆里面的 if (x*x + y*y) &lt;= 1: ptsinterieur += 1 my_pis += ptsinterieur/N * 4 my_pi = my_pis/NumTest return my_pi,abs(math.pi-my_pi)/math.pimonteCarlo(50,int(1e6)) 3.scipy库获取大小和通道 123456789101112131415#大小print(f.shape)#显示通道R = f[:,:,0]plt.imshow(R)plt.show()G = f[:,:,1]plt.imshow(G)plt.show()B = f[:,:,2]plt.imshow(B)plt.show() 获取灰度图[l’image en noir et blanc] 123gray = R * 0.299 + G * 0.587 + B * 0.114plt.imshow(gray, cmap=&quot;gray&quot;)plt.show() 镜像图[l’image en miroire] 1img_lr = np.fliplr(img) masque 12345678910111213141516x,y = gray.shapec_x = 300c_y = 600r = 100def inCircle(i,j): if (c_x-i)*(c_x-i) + (c_y-j)*(c_y-j) &gt; r * r: return True else: return Falsegray_circle = gray.copy() for i in range(x): for j in range(y): if inCircle(i,j): gray_circle[i][j] = 0plt.imshow(gray_circle,cmap='gray')plt.show() 二值化[binaire] 12345678910x,y = gray.shapegray_binaire = gray.copy()for i in range(x): for j in range(y): if gray_binaire[i][j] &gt; 100: gray_binaire[i][j] = 0 else: gray_binaire[i][j] = 255plt.imshow(gray_binaire,cmap='gray')plt.show() gradient 1234567def norm(x, axis=0): return np.sqrt(np.sum(np.square(x), axis=axis))gray = R *0.299 + G * 0.587 + B * 0.114gary_g = np.gradient(gray)gary_g = norm(gary_g)plt.imshow(gary_g,'gray') TP3.2用OPENSKY + pandas画飞机轨迹 1. pandas 2.opensky 画飞机画单个的飞机轨迹 123456789101112131415161718192021222324def drawJour(but): #先把这个avoin摘出来 tableau = df[df['icao24'] == but] liste_lat = tableau['lat'].tolist() liste_lon = tableau['lon'].tolist() print(&quot;liste ok&quot;) #画图 #地图 fig = plt.figure(figsize=(15,15)) # Create a GeoAxes in the tile's projection. stamen_terrain = cimgt.Stamen('terrain-background') ax = fig.add_subplot(1, 1, 1, projection=stamen_terrain.crs) #ax.set_extent([df['lon'].min()-6, df['lon'].max()+6, df['lat'].min()-6, df['lat'].max()+6], crs=ccrs.Geodetic()) # Add the Stamen data at zoom level 8. ax.add_image(cimgt.GoogleTiles(&quot;RGB&quot;), 8) #轨迹 ax.plot(liste_lon,liste_lat,color='red',transform=ccrs.Geodetic()) fig.savefig(&quot;1.jpg&quot;) plt.show() print(&quot;ok&quot;)drawJour('a7e152') 画所有飞机的 12345678910111213141516171819202122232425262728293031323334353637def drawAlltrace(dataset): #画图 #地图 fig2 = plt.figure(figsize=(15,15)) # Create a GeoAxes in the tile's projection. stamen_terrain = cimgt.Stamen('terrain-background') ax2 = fig2.add_subplot(1, 1, 1, projection=stamen_terrain.crs) #ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.Geodetic()) #Add the Stamen data at zoom level 8. ax2.add_image(cimgt.GoogleTiles(&quot;RGB&quot;), 8) print(&quot;map ok&quot;) #轨迹 #groupBy dataset_light = dataset[['icao24','lat','lon']] group = list(dataset_light.groupby(&quot;icao24&quot;)) print(len(group)) i = 0 for key, item in group: liste_lat = [] liste_lon = [] item = item.dropna(axis=0,how='any') liste_lat = list(item['lat']) liste_lon = list(item['lon']) if liste_lat and liste_lon: ax2.plot(liste_lon,liste_lat,color='red',transform=ccrs.Geodetic()) i+=1 print(liste_lat) print(liste_lon) fig2.savefig(&quot;Pic/&quot;+str(i)+&quot;.jpg&quot;) print(&quot;ax fini&quot;) plt.show() print(&quot;ok&quot;) #drawAlltrace(df) TP41.COO2.Mandelbrot12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import numpy as npimport matplotlib.pyplot as pltnp.warnings.filterwarnings(&quot;ignore&quot;)def is_in_Mandelbrot(c, max_iter=50)-&gt;bool: &quot;&quot;&quot;Verifier un point apres max_iter fois iteration est dans la suite Mandelbrot Args: c (complex,optional complex_array): le candidat max_iter (int): nombre d'iteration. Returns: bool: si dans la suite-&gt;True; sinon False &quot;&quot;&quot; z = 0 for _ in range(max_iter): z = z**2 + c return abs(z) &lt;= 2def is_in_Julia(z,c, max_iter=50)-&gt;bool: &quot;&quot;&quot;Verifier un point apres max_iter fois iteration est dans la suite Mandelbrot Args: c (complex,optional complex_array): le candidat max_iter (int): nombre d'iteration. Returns: bool: si dans la suite-&gt;True; sinon False &quot;&quot;&quot; for _ in range(max_iter): z = z**2 + c return abs(z) &lt;= 2def plot_mandelbrot(zmin=-2 - 2j, zmax=2 + 2j, pixel_size=0.001, max_iter=50, figname=&quot;Mandelbrot.png&quot;): &quot;&quot;&quot;afficher et save la figure de suite Mandelbrot Args: zmin (_type_, optional): _description_. Defaults to -2-2j. zmax (_type_, optional): _description_. Defaults to 2+2j. pixel_size (float, optional): _description_. Defaults to 0.001. max_iter (int, optional): _description_. Defaults to 50. figname (str, optional): _description_. Defaults to &quot;Mandelbrot.png&quot;. &quot;&quot;&quot; reals = np.arange(zmin.real, zmax.real, pixel_size) imags = np.arange(zmin.imag, zmax.imag, pixel_size) x, y = np.meshgrid(reals, imags) c = np.array(x + y * 1j, dtype=complex) plt.figure(figsize=(15, 15)) plt.imshow(is_in_Mandelbrot(c, max_iter), cmap=&quot;binary&quot;) plt.gca().set_aspect(&quot;equal&quot;) plt.axis(&quot;off&quot;) plt.tight_layout() plt.show() plt.savefig(figname)def plot_julia(c=-0.8 + 0.156j, zmin=-2-1j, zmax=2+1j, pixel_size=5e-4, max_iter=100, figname=&quot;Julia.png&quot;): &quot;&quot;&quot;afficher et save la figure de suite Mandelbrot Args: c (_type_, optional): _description_. Defaults to -0.8 + 0.156j. zmin (_type_, optional): _description_. Defaults to -2-1j. zmax (_type_, optional): _description_. Defaults to 2+1j. pixel_size (float, optional): _description_. Defaults to 0.0005. max_iter (int, optional): _description_. Defaults to 100. figname (str, optional): _description_. Defaults to &quot;Julia.png&quot;. &quot;&quot;&quot; reals = np.arange(zmin.real, zmax.real, pixel_size) imags = np.arange(zmin.imag, zmax.imag, pixel_size) x, y = np.meshgrid(reals, imags) z = np.array(x + y * 1j, dtype=complex) plt.figure(figsize=(15, 15)) plt.imshow(is_in_Julia(z,c, max_iter), cmap=&quot;binary&quot;,alpha=0.5) plt.gca().set_aspect(&quot;equal&quot;) plt.axis(&quot;off&quot;) plt.tight_layout() plt.show() plt.savefig(figname) __main__.py 12345678910111213141516171819202122232425262728293031323334353637383940414243&quot;&quot;&quot;Main call to mandelbrot. Mostly a parser.&quot;&quot;&quot;import argparsefrom .affichage import plot_mandelbrot,plot_juliadef MandelbrotPlot(): &quot;&quot;&quot;Draw la suite Mandelbrot with des arguments suivants&quot;&quot;&quot; parser = argparse.ArgumentParser(description='Draw mandelbrot') parser.add_argument('--zmin',metavar='zmin', type=complex,default=-2-2j, help='input zmin,default:-2-2j') parser.add_argument('--zmax',metavar='zmax', type=complex,default=2+2j, help='input zmax,default=2+2j') parser.add_argument('--pixel_size',metavar='pixel_size', type=float,default=0.001, help='input pixel_size,default:0.01') parser.add_argument('--max_iter',metavar='max-iter', type=int,default=50, help='input max_iter,default:50') parser.add_argument('-o',metavar='pathname', type=str,default='mandelbrot.png', help='input pathname') args = parser.parse_args() plot_mandelbrot(zmin=args.zmin,zmax = args.zmax, pixel_size = args.pixel_size,max_iter=args.max_iter, figname=args.o)def JuliaPlot(): &quot;&quot;&quot;Draw la suite Mandelbrot with des arguments suivants&quot;&quot;&quot; parser = argparse.ArgumentParser(description='Draw Julia') parser.add_argument('-c',metavar='c de Julia', type=complex,default=-0.8+0.156j, help='input c de Julia,default:-0.8+0.156j') parser.add_argument('--zmin',metavar='zmin', type=complex,default=-2-1j, help='input zmin,default:-2-1j') parser.add_argument('--zmax',metavar='zmax', type=complex,default=2+1j, help='input zmax,default=2+1j') parser.add_argument('--pixel_size',metavar='pixel_size', type=float,default=5e-4, help='input pixel_size,default:5e-4') parser.add_argument('--max_iter',metavar='max-iter', type=int,default=100, help='input max_iter,default:100') parser.add_argument('-o',metavar='pathname', type=str,default='julia.png', help='input pathname') args = parser.parse_args() plot_julia(c=args.c,zmin=args.zmin,zmax = args.zmax, pixel_size = args.pixel_size,max_iter=args.max_iter, figname=args.o)","link":"/2022/10/29/PAPY_TPS/"},{"title":"PFONC_CM4&amp;5","text":"PFONC_CM4&amp;5CHAP4 : Fonctions d’ordre supérieur -Les fonctions sont des objets de première classe : elles se manipulent comme les types de base：函数像基本类型那样被传递[参数和返回值] -Notion de fonction d’ordre supérieur : ensembles de fonctions dans le domaine ou le codomaine：域或共域中的函数[?] CurryficationHaskell 的所有函数都只有一个参数, 所有多个参数的函数都是 Curried functions，下面以max函数为例进行说明 1max x y = if x &gt; y then x else y 他的类型说明是：max::Integer -&gt;Integer -&gt;Integer，但按照我们一般的理解，它应该长这样：max::(Integer,Integer)-&gt;Integer -Pour tout x, (max x) est une fonction d’un entier qui donne un entier Haskell 的所有函数都只有一个参数 -Donc max est aussi une fonction d’un entier qui donne « une fonction d’un entier qui donne un entier » max函数的参数是(一个返回值为int的函数)—&gt;max :: Integer-&gt;(Integer -&gt;Integer) —哎这里为什么不是 max :: (Integer-&gt;Integer) -&gt;Integer Et comme -&gt; est associatif à droite :max :: Integer-&gt;Integer -&gt;Integer Toute fonction de plusieurs variables peut être transformée en une fonction d’une seule variable, pour tous types a,b,c, on peut définir deux fonctions, les fonctions sont « curryfiées » (curried) par défaut en Haskell 1234curry::((a,b)-&gt;c)-&gt;(a-&gt;(b-&gt;c))uncurry::(a-&gt;(b-&gt;c))-&gt;((a,b)-&gt;c)-- et on pourrait définir des versions pour tous-- les tuples de types possibles EXERCICE Quel est le type de map ? 12map _ [] = []map f (x:xs) = (f x):(map f xs) map :: (a-&gt;b)-&gt;list-&gt;list map :: (a-&gt;b) -&gt; [a] -&gt;[b] Écrire une fonction flip, avec son type, qui à partir d’une fonction d’arité 2, donne la même fonction avec les variables inversées. Par exemple : main = print (flip (-) 1 3) --2(pas -2) 123filp :: (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)--为什么不是((a-&gt;b)-&gt;c-&gt;d) -&gt;((a-&gt;b)-&gt;d-&gt;c) --为什么f不是(a-&gt;b)，为什么不是交换b和cfilp f x y = f y xmain = print (flip (-) 1 3) ​ 以及这个神奇的错误 Application de fonction($)L’application de fonction est une fonction. Elle est notée ($) en Haskell : 12($)::(a-&gt;b)-&gt;a-&gt;b($) f x = f x 函数调用符，空格的函数调用符是左结合，而 $ 则是右结合，用于减少代码中括号的数目 Elle est de faible priorité et associative à droite : 123main = print (square (inc 2))-- ou un peu plus concismain = print $ square $ inc 2 Elle sert pour définir certaines fonctions d’ordre supérieur : 将数据作为函数使用：映射一个函数调用符到一组函数组成的 List 12-- valeurs en 0 des fonctions f, g et hmap ($ 0) [f,g,h] Fonctions anonymes (Fonctions λ)On peut définir des fonctions anonymes, appelées fonctions λ : P. ex. λx.(x + 1) ou λx.(λy.(x + y)) En Haskell : 123456inc x = x+1map inc [1,2,3]-- ou simplementmap (\\x -&gt; x+1) [1,2,3]-- plusieurs variables:add = (\\x y -&gt; x+y) 编写 lambda: ，+用空格分隔的参数，+-&gt; 后面的函数体。通常用括号将其括起，要不然它就会占据整个右边部分。 Fermetures (Closures): 闭包On quantifie implicitement[隐式地量化了] x et y quand on écrit : 1f x y = x + y -- ∀x, ∀y La variable y est dite libre dans : 1f' x = x + y -- ∀x--不能这样子 On ne peut pas évaluer f’ x sans une valeur pour y. D’ailleurs, toute seule, ce n’est pas une déclaration correcte Une fermeture est une fonction avec variables libres plus une valeur pour ces variables libres : 12-- Pour tout y, g y est une fermeture，x是自由变量g y = (\\x -&gt; x + y) 那么怎么传参和调用呢？ Récursion sur les listesmap-Plutôt que de faire de la récursivité explicite, on utilise plutôt, autant que possible, des fonctions de plus haut niveau [与其说是显式递归，不如说是尽可能地使用了更高层次的函数] -On a déjà vu map qui permet d’appliquer une fonction à chaque élément d’une liste : 123map::(a-&gt;b)-&gt;[a]-&gt;[b]map _ [] = []map f (x:xs) = (f x):(map f xs) EXERCICE: En utilisant map, écrire une fonction an qui donne la liste de toutes les anagrammes d’un mot[找所有字母组合]. On pourra utiliser aussi : concat::[[a]]-&gt;[a] ,delete::Eq a =&gt;a-&gt;[a]-&gt;[a] 12345import Data.List (delete,nub)-- anagrammesan :: String -&gt; [String]an &quot;&quot; = [&quot;&quot;]an xs = concat $ map (\\x -&gt; map (x:) $ an $ delete x xs ) $ nub xs--nub拿来去重复的 filterfilter permet de ne garder que les éléments d’une liste qui satisfont un certain prédicat : 1234filter::(a-&gt;Bool)-&gt;[a]-&gt;[a]filter _ [] = []filter f (x:xs) = if f x then x:(filter f xs) else filter f xs EXERCICE Écrire une fonction premiers qui donne la liste des entiers premiers inférieurs à n. On pourra ne pas chercher à optimiser et : écrire une fonction diviseurs donnant une liste de diviseurs de n utiliser la syntaxe [x..y] pour la liste des entiers compris entre x et y ; et rem::Integer-&gt;Integer-&gt;Integer donnant le reste la division entière ; et null::[a]-&gt;Bool indiquant si une liste est vide ; ou length::[a]-&gt;Int donnant la taille d’une liste. 12345premiers n listes = filter (&lt;n) listes--找除数diviseurs n = filter ((==0).(rem n)) [1..n]--rem与mod差不多，但.的用法原则是什么？--找质数premiers' n = filter ((==2).length.diviseurs) [2..n-1] foldsfoldl et foldr permettent de réduire une liste à une valeur en appliquant une fonction d’arité 2 récursivement à tous les éléments : foldl réduit de la gauche vers la droite : 它从 List 的左端开始折叠，用初始值和 List 的头部调用这二元函数，得一新的累加值，并用新的累加值与 List 的下一个元素调用二元函数 123456789foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldl f x [] = xfoldl f x (y:ys) = foldl f (f x y) ysfoldl f z [x1, x2, ..., xn] == f (...(f (f z x1) x2)...) xn-- ou en notation infixefoldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2)...) `f` xn foldr réduit de la droite vers la gauche : 右折叠 foldr 的行为与左折叠相似，只是累加值是从 List 的右边开始 123456789foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldr f x [] = xfoldr f x (y:ys) = f y (foldr f x ys)foldr f z [x1, x2, ..., xn] == f x1 (f x2 (...(f xn z)...))-- ou en notation infixefoldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` (...(xn `f` z)...)) 右折叠可以处理无限长度的数据结构，而左折叠不可以。将 无限 List 从中断开执行左折叠是可以的，不过若是向右，就永远到不了头 foldl1,foldr1::(a-&gt;a-&gt;a)-&gt;[a]-&gt;a sont des versions sans élément de départ pour les listes non vides [没有起始元素的非空列表]; 无需明确提供初始值。他们假定 List 的首个 (或末尾) 元素作为起始值，并从旁边的元素开始折叠 以sum函数说明 1234suml::[Integer]-&gt;Integersuml xs = foldl (+) 0 xssumr::[Integer]-&gt;Integersumr xs = foldr (+) 0 xs EXERCICE: Écrire les fonctions suivantes (et tester à la main sur quelques exemples) : sum::[Integer]-&gt;Integer qui donne la somme des éléments d’une liste ; 上面 maximum::[Integer]-&gt;Integer qui donne le maximum des éléments d’une liste ; 123maxi'::[Integer]-&gt;Integermaxi' [] = error &quot;list: vide&quot;maxi' xs = foldl1 max xs and::[Bool]-&gt;Bool qui indique si tous les éléments sont vrais ; 12345and'::[Bool]-&gt;Booland' = foldr (&amp;&amp;) Trueor' :: [Bool] -&gt; Boolor' = foldr (||) False any::(a-&gt;Bool)-&gt;[a]-&gt;Bool qui indique si au moins un élément de la liste satisfait un prédicat donné ; 12any'::(a-&gt;Bool)-&gt;[a]-&gt;Boolany' f = or'.(map f) concat::[[a]]-&gt;[a] qui concatène une liste de listes. 12concat' :: [[a]] -&gt; [a]concat' = foldl (++) [] 问题集 Curryfication的max和例题的fild 闭包函数的调用和有什么用 P41的map全排列 上面的3,4,5怎么都不加列表参数，看不懂啊啊啊啊啊","link":"/2022/09/16/PFONC_CM4&5/"},{"title":"PFONC_CM2&amp;3","text":"PFONC_CM2&amp;3CHAP2:Types, 介绍haskell中的类型变量. Types de baseentiers: Integer/Int Réels virgule flottante: Double ou Float Booléens: Bool (valeurs True et False) Caractères Char Chaîne de caractères: String (alias[别名] pour [Char]—Char类型的列表) Types algébriques[代数]由基本类型构建 Types sommes : énumerations[枚举] 12data Bool = True | Falsedata Animal = Canard | Vache | Chat Types produits : tuples 12data AnimalMesure = Paire Animal Integer--Paire:值构造子(Value Constructor)和类型名(AnimalMesure)不同data Entiers3 = Entiers3 Integer Integer Integer Paire, True, False, Canard, etc. sont des constructeurs de données 都是值构造子，值构造可以与类型名同名，后面可以跟几个类型表示它包含值的类型 Ils peuvent avoir n’importe quel nom, y compris le même que le nom du type défini.Comme pour Entiers3 ; [可以同名] Les noms de types et de constructeurs commencent par une majuscule[大写字母] en Haskell.然后普通函数必须小写字母开头 Types algébriques: sommes de produits 12345678data PossibleReel = Rien | Valeur Doubleinversion :: Double -&gt;PossibleReelinversion 0 = Rieninversion x = Valeur (1/x)--Rien et Valeur sont implicitement[隐式地] définies avec ce type:--Rien:: PossibleReel--Valeur::Double -&gt;PossibleReel 这里注意一个问题，inversion的调用实现这里，直接调用 inversion n 报错 No instance for (Show PossibleReel) arising from a use of ‘print’，然后得在声明数据类型时加上deriving Show，具体原因不是很清楚哈哈哈哈 Plus de pattern-matchingOn peut utiliser les constructeurs pour faire du pattern-matching : 1234567opposePR :: PossibleReel -&gt;PossibleReelopposePR Rien = RienopposePR (Valeur x) = Valeur (-x)-- ou bien avec let ... inopposePR z = if z == Rien then Rien else let (Valeur x)=z in Valeur (-x) EXERCICE 1.Écrire une fonction et qui réalise le et logique entre deux Bool 12et True True = Trueet _ _ = False 2.Proposer la définition d’un type Point représentant un point du plan 1data Point = Point Double Double deriving Show 3.Écrire une fonction distance qui donne la distance entre deux Point 1234findDistance :: Point,Point -&gt; DoublefindDistance (Point x1 y1) (Point x2 y2)= sqrt ((x1-x2)^2+(x1-x2)^2)--调用：findDistance (Point 2 3) (Point 4 5) 4.Proposer la définition d’un type Figure qui est： ​ • soit un unique Point ; ​ • soit un cercle défini par son rayon &gt; 0 et son centre ; ​ • soit un carré défini par deux sommets opposés. 12data Vecteur = Vecteur Double Doubledata Figure = FigP Point |Cercle Point Double |Carre Point Vecteur 5.Écrire une fonction perimetre qui donne le périmètre[周长] d’une Figure. 1234perimetre (FigP _) = 0perimetre (Cercle _ r) = 2 * pi * rnorme (Vecteur x y)= findDistance (Point 0 0) (Point x y)perimetre (Carre _ (Vecteur x y)) = 4 * norme v --咋能这么算呢 Types paramétrés:参数化类型Le type PossibleReel existe, sous la forme d’un type paramétré, en Haskell : 123--对于所有的类型来说都有：data Maybe a = Nothing | Just a--Maybe est un constructeur de type 一些(仍然不太懂的)理解： 类型构造子可以取类型作参数，产生新的类型 所以给 Car 类型加类型参数貌似并没有什么必要。通常我们都是 都是在一个类型中包含的类型并不影响它的行为时才引入类型参数 12345data Either a b = Left a | Right bsafeTwice ::Int-&gt;Either Int IntsafeTwice n = if n &gt; (maxBound::Int) `div` 2 then Left n else Right (2*n)--报错了QAQ,加deriving Show也不行 Types en Haskelltype et newtype-type définit un type synonyme[同义] d’un autre：type String = [Char] -newtype est similaire à data mais ne fonctionne que pour un seul constructeur de données avec au plus une variable et fournit dans ce cas une petite optimisation (Synonymes mais crée un type distinct). 但只适用于最多只有一个变量的单一数据构造函数 TuplesUn tuple est un type produit, Haskell propose une syntaxe[语法] spécifique (et classique) pour les tuples: 12345678910-- fst et snd pour les couplesmaxi ::(Integer,Integer)-&gt;Integermaxi x = let a = fst x, b = snd x in if a &gt; b then a else b-- pattern matchingmaxi '::(Integer,Integer)-&gt;Integermaxi ' (a,b) = if a &gt; b then a else b-- pas que pour les couplesror::(Char,Char,Char)-&gt;(Char,Char,Char)ror (a,b,c) = (c,a,b) EnregistrementsUn enregistrement est un type produit avec accesseurs intégrés [内置的访问器？] (en lecture bien sûr) 构造方法 123456789data Canard = Coin { nom::String , enverg::Double }info::Canard -&gt;Stringinfo c = &quot;Oh le beau canard &quot; ++ (nom c) ++&quot; d'envergure &quot; ++ show (enverg c) ++ &quot;m &quot;main = let c1 = Coin &quot;Coincoin&quot; 0.8 c2 = Coin { nom=&quot;Grocoin&quot;, enverg =0.8 } c3 = c2 { enverg = 1 } in print (info c1 ++ info c3) Listes-Le type liste est natif à Haskell, la liste vide est [] -Le constructeur « élément plus liste donne liste » est noté : —追加的冒号 -Pour tout type a le type « liste de a » est noté [a] ; -Accès à l’élément i (commençant à 0) : xs!!i.—获取索引 Listes en compréhensionLes listes en compréhension (list comprehension) sont une facilité syntaxique pour créer des listes EXEMPLE 12345-- les nombres pairs inférieurs à n (on peut faire mieux...)evens n = [x+1 | x&lt; -[1..(n-2)], odd x]-- les produits de nombres impairs à trois chiffresproducts3 = [m*n | m &lt;- [101 ,103..999] ,n &lt;- [101 ,103..999]] EXERCICE Construire la liste des triplets pythagoriciens (a, b, c), c.-à-d. tels que a^2 + b^2 = c^2 , dont la somme des composantes vaut 1000 et tels que a &lt; b &lt; c. 1triplets = [(a,b,c) | a &lt;- [1..333],b&lt;-[a..666],c&lt;-[b..1000],a*a + b*b = c*c, a+b+c == 1000] Écrire une fonction reverse qui inverse une liste 123reverse' :: String -&gt; Stringreverse' [] = []reverse' (x:xs) = reverse' xs ++ [x] --列表的拼接是++，[x]表示转为列表 Écrire une fonction delete qui efface la première occurrence d’un élément dans une liste 12delete' x []=[]delete' x (y:xs) = if x == y then xs else y: delete' x xs--记住这里的y： Écrire une fonction maximum qui trouve le maximum dans une liste d’entiers 123456maxi :: Liste -&gt; Integermaxi [] = error &quot;list vide&quot;maxi [x] = x --这行很重要！maxi (x:xs) = if x &gt; maxi xs then x else maxi xs--或者写成maxi (x:xs)= max x (maxi xs) Écrire une fonction trimax qui réalise le tri par extraction du maximum dans une liste d’entiers 1234567trimax :: Liste -&gt; Listetrimax [] = []trimax [x] = [x]trimax xs = maxi xs : trimax (delete' (maxi xs) xs)--或者写成trimax xs = let y = maxi xs in y : trimax(suppr y xs) Types algébriques récursifs12-- arithmétique de Peanodata Nat = Zero | Succ Nat EXERCICE Écrire une fonction addition qui réalise l’addition de deux Nat. 12345678data Nat = Zero | Succ Nat deriving Showeval :: Nat -&gt; Integereval Zero = 0eval (Succ n) = 1 + eval naddition Zero n = naddditon (Succ n1) n2 = addition n1 (Succ n2) ArbresEXERCICE Écrire un type Liste représentant une liste d’entiers 1data Liste = Vide | Cons Integer Liste deriving Show Écrire une fonction sum qui fait la somme des éléments d’une liste d’entiers 123somme :: Liste -&gt; Integersomme Vide = 0somme (Cons x xs) = x + somme xs Écrire un type ArbreBinaire représentant un arbre binaire d’entiers 1data Arbre = Vide | Cons Integer Arbre Arbre deriving Show Écrire une fonction hauteur qui calcule la hauteur d’un arbre binaire d’entiers. 123hauteur :: Arbre -&gt; Integerhauteur Vide = 0hauteur (Cons _ gauche droit) = 1 + max (hauteur gauche) (hauteur droit) Types génériquesOn peut définir les fonctions de façon générique : 123-- pour tout type afsquare ::(a-&gt;a)-&gt;(a-&gt;a)fsquare f = f.f Et des types algébriques de façon générique (paramétrée) : pour tout type a, le type [a] est une liste de a et Maybe a est la possibilité d’un a ; 代数类型以通用（参数化）的方式：对于任何类型的a，[a]是一个a的列表，Maybe a是一个a的可能性。 Et des fonctions génériques sur des types algébriques génériques : 12345678-- pour tout type ahead::[a]-&gt;ahead [] = error (&quot;head: Empty list&quot;) -- fct. partielle!head (x:xs) = x-- dans Data.MaybelistToMaybe::[a]-&gt;Maybe alistToMaybe [] = NothinglistToMaybe (x:xs) = Just x [没太看懂这啥呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜] 问题 参数化类型 Types génériques 正方形面积","link":"/2022/09/16/PFONC_CM2&3/"},{"title":"PRO20","text":"序趁着可能对P2E有点用处的东风，把上学期一个很有意思的softskill给整理了。 中间就是一个教怎么组织项目的课，具体实例是建养鸡场，选址、选鸡蛋品种（bio或者非bio）、然后风险评估啥的。以下是一些有趣的概念的大略整理。 DéfinitionsProject: Un ensemble de tâches coordonnées accomplies par des personnes utilisant des moyens dans le but de répondre au besoindu client avec la qualité demandée en temps et coûts maitrisés Gestion de projet: La Gestion de projet s’assure du déroulement opérationnel prévu dans la planification. Elle reporte à la fonction de pilotage de projet sur l’avancement, elle sollicite des prises de décisions et remonte des alertes Management de projet: Direction + Gestion = Management Cadrage(框架) du Project L’identité du client Les objectifs du projet 目标应该满足的原则：S(Spécifique)M(Mesurable)A(Atteignable)R(Réaliste)T(Temporel) Les délais à respecter Les limites du budget à investir L’utilité du projet La rentabilité escomptée du projet Décomposer le projetWBSWBS : Work Breakdown Structure. Décomposition hiérarchique, axée sur les livrables, du travail que l’équipe de projet doit exécuter pour atteindre les objectifs du projet et produire les livrables souhaités. 做法： Spécifier les objectifs du projet Identifier spécifiquement les produits, services ou résultats Identifier les travaux Subdiviser les éléments jusqu’au niveau qui permet laplanification et le contrôle PBSProduct Breakdown Structure 注：当时好像是上课没咋讲这个，后来是按照网上(ZHIHU)的文章说，WBS是以项目结果为导向的工作过程的结构分解，PBS是项目交付结果本身为对象进行的层级结构分解来做的。具体到这道题，就是，WBS包含整个项目管理，PBS只是按照养鸡场本身按照地基、外部建筑、内部建筑、服务设施这样子分级。 Diagramme de GanttC’est un outil que peut aider à définir un planning réaliste. 貌似就是一个项目的时间的进程表，找出要做的事情，然后分析发生的先后或者并行关系，搞成条状表就行了。 Exemple(红色表示关键事件) : PERTC’est un outil souvent utilisée pour la gestion de projets importants et à long terme. PERT = Program Evaluation and Review Technic (ou CPM: Critical Path Method) 就是把上面那个Gantt图给这样子表示，然后往里面写时间就行，然后选时间最大的那条线（不是我说，这好像算法里面的那个啥图 Exemple: Les risquesPrincipaux risques incluent Risques financiers, Risques marchés, Risques technologiques, Risques liés à l’équipe. Pour gestion des risques, on peut utiliser le table comme ça, 就是两部分：严重程度+发生概率 对，记得当时有个文化shock还蛮有趣的小点就是，当时有个风险是员工absent，然后写应对措施，我说搞时刻表，然后其他人：推迟上班的时间或者改变工作环境。 结语其实这个项目还有超级多的东西，当时TD课第一节课搞WBS、PBS和GANTT的图，第二节课搞投资和收益计算，第三节课是风险评估，参与程度递减，到最后一节课就除了汇报叭叭两句就完全没太参与进去，不知道在干嘛了T^T 反正最后结论就是要养bio的鸡，唔。","link":"/2022/02/07/PRO20/"},{"title":"PYTHON_入门学习","text":"PYTHON_入门学习b站搜python出来的第一个：https://www.bilibili.com/video/BV1wD4y1o7AS?p=25&amp;spm_id_from=pageDriver&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 一般推荐，有点拖，但是一节很短看起来不累 CHAP_0编码bit byte: 8 bit kb: 1024 byte mb : 1024kb ASCII码，GB2312(中文)，Unicode,UTF-8 变量有一些保留字keyword不能用作变量名，list啊class啊这些 定义和实际组成 一些常见的数据类型:int,float,bool,str 获取数据类型: type(变量名) 类型转换:str(age) 可以用单引号’age‘实现 注释多行注释：三引号 中文注释：#coding:gbk input()将输入内容存储到变量，注意一般存储的是str类型的 def 函数名(参数):#这里的参数*arg就是表示随意取几个 函数体#不写的话加上pass占位python print数字不加引号 字符串加单双引号三引号都行，三引号可以在代码里面换行 可以输出含有运算符的表达式：print(3+5)，print(‘我叫’+name)。注意：1.浮点数，以及一个奇怪的解决方法 2.一定是同类型才能相加 输出到文件： 123fp = open('D:/text.txt','a+')#a+表示如果文件不存在就创建，存在就在文件内容里面追加print('输出内容1',file=fp)fp.close() \\n:换行,print(‘hello\\nworld’) \\t:空格 r:输出原字符,print(r’\\n’) 运算符算术运算符：+,-,,/(是有小数的),//(整除),%,*(幂运算) 赋值运算符：=，支持+=这种，支持解包赋值：a,b,c=20,’nana’,5.5——-&gt;交换就可以这样子写a,b = b,a，支持链式赋值，链式赋值指向的存储地址一致 比较运算符：&gt;,&lt;,!=,==,结果是bool类型 布尔运算符：and(与 &amp;&amp;),or(或 ||),not(非 !)； ​ in,not in 可以用于字符匹配 位运算：$按位与，|按位或，&lt;&lt;左移（2倍），&gt;&gt;右移（1/2） 运算符的优先级： pycharm打断点+shift和f9就是调试模式 CHAP_1程序的组织结构：顺序，选择，循环 空列表:[],list() 空元组:(),tuple() 空字典:{},dict() 空集合:set() 选择结构12345678a = int(input('please input a: '))if a &gt; -10 and a &lt; 5: a += 1elif a &gt; 5 : a -= 1else : a = 0print(a) 和C++区别不大，注意elif、冒号和缩进，空的话写pass 简写的那种写法: x if 判断条件 else y 1print(str(a)+'大于'+str(b) if a &gt; b else str(a)+'小于等于'+str(b)) 循环结构range()用于创建一个整数序列,在循环中很重要 创建方式 123r = range(10)#0到9r = range(1,10)#1到9r = range(1,10,2)#1到9，步长为2 创建的是迭代器(?)，打印的话转成list,可以使用in和not in 12if 9 not in r: print('wa') while例：1到100的偶数和 123456a = 0count = 0while a &lt; 101: a += 2 count += aprint(a) for-infor 自定义变量 in 可迭代对象: ​ 循环体 自定义变量: 当它不被使用时可以使用 _ 可迭代对象: 字符串，range() 例：1到100的偶数和 1234count = 0for item in range(0,101,2): count += itemprint(count) break 和 continuebreak直接退出循环，continue就是不管后面的直接执行下一次循环（好像也可以用pass？）都是本层循环，和c++蛮像的 else就是说循环体后面可以接着写else，表示在没有break时执行else 123456789for item in range(3): pwd = input() if pwd = '888': print('wa') break else: print('non')else: print('冻结') 嵌套循环例：打印99乘法表 1234for i in range(1,10): for j in range(1,i+1): print(j*i,end='\\t')#特别注意这里表示不换行打印 print() CHAP_2: list,dict,tuple,set,str列表存储多个元素，相当于数组，但可以存不同类型的元素 创建：直接使用中括号，或者调用内置函数list() 12lst = ['hello',98,'world']lst2 = list(['hello',98,'world'])#?有点感觉没太必要的样子 或者列表生成式 lst=[i for i in range(1,10)] 获取元素index()函数，返回元素在list的索引，相同的返回第一个出现的地方 12lst.index('hello')lst.index('hello',1,4) 单个元素：取某个元素就是lst[0]这样子，lst[-1]表示最后一个，就是负的话就从右开始 多个元素：切片 1234567lst3=lst[1:6]#默认步长为1lst3=lst[1:6:2]lst3=lst[:6:2]#默认从0开lst3=lst[1::2]#默认到最后#step为负表示倒着取lst3=lst[::-1]lst3=lst[7:2:-1] 增删改查查：in 和 not in，遍历直接循环就行，list是可迭代变量, for item in lst这样子就可以 增： 1234567lst = [10,20,30]lst.append(100)lst2 = ['hello','world']lst.extend(lst2)lst.insert(1,90)#切片lst[1:]=lst2#就是把位置1以后的全换成lst2了，但感觉是修改 删： 1234567lst=[10,20,30,30,40]lst.remove(30)lst.pop(-2)#默认是最后一个lst.clear()lst.del()#切片lst[1:3]=[]#感觉也是修改 改：直接索引或者切片改 排序：sort()函数或者sorted() 123lst=[70,20,50,30,40]lst.sort(reverse=ture)#默认升序，这样是降序lst_ = sorted(lst)#不改变原列表 字典是一个可变(值可以增删改这样子)的无序序列，以键值对的形式存储，使用花括号定义 类比C++的哈希(那个map 注意：键值不能重复，不可变 创建：花括号直接定义，内置函数dict() 12scores = {'张三':98,'王五':45,'李四':78}student = dict(name='jack',age=20)#多个咋整嘞，不管 zip()函数把两个列表组合成字典： 123items = ['A','B','C']prices=[9,6.2,3.1]d = {item:price for item,price in zip(items,prices)} 获取元素获取value：[]、get() 123scores['张三']#没有的话会报错scores.get('张三')#没有的话输出nonescores.get('张三',56)#没有的话输出56 获取视图： 123keys = scores.keys()#列表values = scores.values()#列表items = scores.items()#列表,但元素是元组 增删改查查：查的是key，in 与 not in，比如 if ‘张三’ in scores : print(scores[‘张三’]),遍历也是直接循环就行：for item in sorce 删: del scores[‘张三’]，清空scores.clear() 添加: 增加键值对，scores[‘张一’]=97 修改：scores[‘张三’]=96 集合没有value的字典—&gt;意味着集合中的元素不能重复，无序可变，也是用{}或者set()来定义 12345s = {5,6,3,'yu'}s = set(range(6))s = set([5,6,3,'yu'])#列表转集合s = set((5,6,3,'yu'))#元祖转集合s = set('yu')#字符串转集合 生成式：s = {i for i in range(6)}和列表一样，改个花括号就是，不过出来时无序的 增删改查查：in 与 not in,遍历也是直接循环就行：for item in s 增：add:加一个和update:加很多 1234s = {5,6,3,'yu'}s.add(80)#无序的，不知道在哪儿s.update(80,'ll')s.update(lst) 删：remove，discard,pop,clear 123s.remove(5)#没有的话会报错s.discard(4)#没有的话不会报错s.pop()#随机删 数据操作判断：相等：==或者!=，子集关系: issubset()和issuperset(),有没有交集isdisjoint() 取交集：s1.intersection(s2) 或者 s1 &amp; s2 取并集：s1.union(s2) 或者 s1 | s2 取差集：s1.difference(s2) 或者 s1 - s2 取对称差集(就是s1和s2的全集减交集)：s1.symmetric_difference(s2) 或者 s1 ^ s2 注s1和s2都是不发生变化的 元组是不可变序列（没有增删改操作），使用小括号定义 不可变可以保证安全性 创建：(),tuple() 没有生成式哟 1234t = 'python','world',98t = ('python',)#一个元素记得加逗号t = ('python','world',98,[7,8])t = tuple(('python','world',98)) 其实不是指元组就不能改了，简单理解是数据类型不能改，就是指向的地址不能改，但地址里面的value是可以改的，比如说t[4]是列表，它的那些增删改啊也是能用的 获取元素直接使用索引：t[0]这样子就可以 查in 与 not in, 遍历也是一样循环for item in t: 4种数据结构的小结 CHAP_3: 字符串不可变序列，可以使用单引号、双引号、三引号进行定义 查找子串 12345s = 'hello,hello's.index('lo')#3s.rindex('lo')#9s.find('lo')#没有不会报错s.rfind('lo') 大小写转换 12345s.upper()s.lower()s.swapcase()#小写转大写，大写转小写s.capitalize()#变成第一个字符大写，其余小写s.title()#变成每个单词的第一个字符大写，其余小写 对齐 12s = 'hello,python's.center(20,'*')#结果***hello,python*** split() 123456s = 'hello,python's.split()#默认分割符为空格，返回列表['hello',',','python']s.split(sep=',')s.split(,maxsplit=1)#可以指定最大劈分次数s.rsplit()#从右侧开始劈分 判断 123456s.isspace()#空白字符s.isalpha()#是不是由字母组成s.isnumeric()#是不是由数字组成s.isalnum()#是不是由数字+字母组成s.isdecimal()#十进制数字s.isidentifier()#合法标识符：字母数字下划线 replace() 123s = 'hello,python,python,python's.replace('python','java')s.replace('python','java',2) join:可以把列表、元祖连成字符串 1234lst=['hello','python']'*'.join(lst)#输出字符串：hello*python#也可以连字符串，不过比较怪--&gt;+'*'.join('python')#输出是p*y*t*h*o*n 比较：直接用算术运算符的＞&lt;这些 切片：和列表类似，s1 = s[:6:2]#开始切到6（不包含6），步长为2（负数表示从后往前） 占位符 {}做占位符或者% 12345name = 'A'age = 20print('我是%s，今年%d岁' % (name,age))#可以指定精度宽度啥的%7d,%.3fprint('我是{0}，今年{1}岁'.format(name,age))print(f'我是{name}，今年{age}岁') CHAP_4: 函数创建和调用 123def calc(a,b): return (a*a-b*b)print(calc(10,20)) 注意冒号和空格 参数参数的默认值：def fun(a,b=10):#表示说可以传1个参数，传两个就该啥啥 参数传递 python中的参数传递有两种方式:位置实参和关键字实参 1234#位置实参calc(10,20)#关键字实参calc(b=10,a=20) 注意 不可变对象(int，字符串，元组)在函数体的修改不会影响实参的值，可变对象（列表，字典，集合）会影响 123456789101112def fun(a,b): print(a) print(b) a=10 b.append(10) print(a) print(b)a = 11b = [7,8,9]fun(a,b)#a不会变，b会print(a)print(b) 个数可变的参数 位置参数：*,结果是元组 关键字参数：**，结果是字典 12345678def fun(*args): print(args)fun(10)fun(10,20,30)def fun(**args) print(args)fun(a=10,b=20,c=30) 注意：可变的参数只能有1个，但可变的位置参数和可变的关键字参数能一起存在 函数支持参数时，调用能用*这样子搞 返回值多个时以元组形式返回 例题：斐波那契数列12345678910def fabo(i): if i &lt;= 0: return elif i == 1 or i == 2:#注意or，写成|愣了好久 return 1 else: return fabo(i-1)+fabo(i-2)print(fabo(6)) CHAP_5: 类与对象面向过程与面向对象 类与对象类类：多个类似事物组成的群体的总称 类的组成：属性，实例方法，静态方法和类方法【类里面的函数叫做方法】 类属性：直接定义在类里面（类方法外）的变量，被类的所有对象共享，可以使用类名直接访问 初始化方法（注意是两个下划线）:相当于构造函数，self理解为this指针 实例方法：类里面的函数 静态方法：用@staticmethod进行修饰，使用类名直接访问的方法（Student.cm()） 类方法：用@classmethod进行修饰，使用类名直接访问的方法 对象类的实例化就是对象的创建 stu1 = Student(‘张三’，20) 其实stu1由3部分组成，name，age和类指针（指向了Student类） 动态绑定直接使用对象名添加属性并赋值，也可以给他添加方法 123456def show() print('')stu1.gender = '男'stu1.show = showstu1.show() 好任性啊感觉 封装、继承与多态封装私有属性没有专有修饰符，在前面打两个下划线表示私有属性 123456789class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def show(self): print(self.name,self.__age)stu1 = Student('张三'，20)stu1.show()print(stu1.__age)#就不行 硬要使用也是可以的，用dir(stu1)去读然后有个啥就可以用了，不过说不推荐 继承 python支持多继承，如果一个类没有继承任何类，则默认继承object类 子类的构造函数(init)必须调用父类的构造函数：super()._init__（） 123456class HaoStudent(Student): def __init__(self,name,age,score): super().__init__(name,age) self.score=scorestu2 = HaoStudent('张一',20,98)stu2.show() 方法重写：调用+重写—&gt;super().xxx()，然后后面加就成 OBJECT类：所有类的父类 多态没懂 特殊属性与特殊方法 123456789101112class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def __len__(self): return len(self.name) def __add__(self,other): return self.name+other.namestu1 = Student('张二'，20)stu2 = Student('张四'，20)print(len(stu1))print(stu1.__add__(stu2)) new那个不太懂，不太想懂 赋值、浅拷贝、深拷贝赋值：只是形成两个变量，实际还是指向同一个对象 浅拷贝：包含的子对象内容不拷贝，源对象与拷贝对象引用同一个子对象 12345678910111213141516171819202122232425262728class CPU: passclass Disk: passclass Computer: def __init__(self,cpu,disk): self.cpu = cpu self.disk = disk#赋值--&gt;内存地址是一致的cpu1 = CPU()cpu2 = cpu1print(id(cpu1))print(id(cpu2))#浅拷贝--&gt;computer不一样但cpu和disk是一样的disk = Disk()computer = Computer(cpu1,disk)import copycomputer2 = copy.copy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer2),id(computer2.cpu),id(computer2.disk))#深拷贝--&gt;computer,cpu,disk都不一样computer3 = copy.deepcopy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer3),id(computer3.cpu),id(computer3.disk)) 深拷贝：递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同 CHAP_6: 文件，模块化编程文件 1234567891011121314151617181920file = open('a.txt','r')#只读file.read()#读所有file.read(3)#读3个file.readline()#读一行file.readlines()#读所有行到列表file.seek(2)#从第几位开始读，默认0file.tell()#返回文件当前指针位置file.close()file2 = open('b.txt','w')#只写，如果文件不存在则创建，覆盖写,追加写是afile2.write('python')file2.flush()#缓冲file2.writelines('python')#不加换行符写file2.close()file3 = open('a.png','rb')#二进制读,可以读图片file4 = open('b.png','wb')#二进制写file4.write(file3.read())file3.close()file4.close() with：上下文管理器，不用写close() 12with open('a.txt','r') as file: file.read() 也可以用在类上 12with A() as file: file.__init__('5',5) OS模块：操作系统和文件系统模块 1234567import os#可以执行exeos.startfile('d:\\\\qq.exe')os.mkdir('newdir')#创建目录#os.pathimport os.path()os.path.abspath()#返回绝对路径 模块化编程一个.py的文件就是一个模块，导入模块 12import mathfrom math import pi#注意一下顺序哟 自定义模块报错时：在目录文件右键：mark directory—&gt;sources root 主程序：就是这下面的内容只有在运行这个py文件时才运行，调用时不运行 12if __name__ = '__main__': print()","link":"/2022/08/31/PYTHON/"},{"title":"SSTEM_DS","text":"SSTEM期末自救 TDTD1Question: Après avoir défini les différentes parties prenantes du Système, identifiez les différentes utilisations et modélisez les sous forme d’un diagramme des cas d’utilisationDiagramme des cas d’utilisation 的 étape: Finalité,Missions,Objectifs(套话) Finalité: Assurer le fonctionnement des systèmes d‘information de réseau ferroviaire. Missions:具体任务，得在问题中找，可能用到的词：définir,assurer,informer Objectifs: Pendre des dispositions raisonnable pour tous les trains grace à la coopération mutuelle entre [……] Les parties prenantes 找实体，可以画个方框图 comme ca： Les cas d’utilisation 画小人图 一些值得注意的点：方框+标题，拓展的include和extend(都是虚箭头画的) include: Celles qui sont incluses dans une action existante —-&gt;obligatoirement,一定被执行 ​ 1.任务与子任务 ​ 2.小人的任务与任务间 extend: Celles qui étendent une action existante—&gt;éventuellement,可能被执行 Les interfaces 随缘 TD2Question: 1.Identifier les parties prenantes et leur rôle dans ce processus关键是区分ACTEUR OU COLLABORATEUR—&gt;看是否有开启或者终止活动 然后在行为中找出触发事件(Délencheur)和终止事件(Final) 可能用到的一些词：envoyer,refuse,annulation,verifier 2. Modéliser ce processus en BPMN表示判断：sinon,valide 表示发信：envoyer,demande 表示收信：recevoir 终止和起始：都是空心圆但终止的要粗一点 TD3Question: 1.Concevoir le diagramme Entités-Associations de ce système.​ 画ER图等价于画MCD: Modèle Conceptuel des Données(概念模型) ER(MCD):主体+关系+实体与关系的比 objet &lt;=&gt;entité Propriété &lt;=&gt;attribut，属性，列 没有外键 lien &lt;=&gt;association 记得加比例，关于比例—&gt;est le lien entre l’entité et l’association 是minimum+maximum minimum:0:peut ne pas apparaître ​ 1:doit apparaître maximum:1:ne peut pas apparaître plus d’une fois ​ n:peut apparaître plusieurs fois 一些典型的关系及其比例：être: chefdegare和être是1:1，être和personne是0:1 ​ detype: salle和detype是1:1,detype和typedesalle是0:n TD3的2到5题是对ER的评价和补充，暂时不想展开看（TO BE ADDED） TD4Question: Cet exercice s’appuie sur la modélisation de gestion de réseau ferroviaire mis en place lors des TDs précédents. Il a pour but de pratiquer SQL à travers l’écriture d’un certain nombre de requêtes. Le MCD utilisé est joint ci-dessous. 1.À partir du MCD, mettre en oeuvre le modèle physique de la base de données (MPD)逻辑模型MLD: Modèle logiques与物理模型MPD: Modèle physiques：物理模型有数据类型 MPD:含实体的外键+箭头+数据类型 实体 标出主键（PK）与外键（FK） 箭头 箭头指向：从表指向主表的外键所在的位置 从表：以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询.箭头：从表外键➡️主表 数据类型 integer/float character varying(256/128) date/datetime/timestamp 2.查询基本语句： 1234SELECT (DISTINCT) 列名 FROM 表名 NATURAL JOIN 表名WHERE: 1.UPPER(Nom) LIKE '%TER%' 2.EXTRACT(YEAR/MONTH/DOW/HOUR/MINUTES FROM 表名)=…… TD51.表的创建1234567891011121314CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY/NOT NULL/或其他 --联合主键 CONSTRAINT 约束名 PRIMARY KEY(列名1,列名2) --外键约束 CONSTRAINT 约束名 FOREIGN KEY(外键名) REFERENCES 表名(外键名) ON DELETE NO ACTION ON UPDATE CASCADE) 2.表的增删改 INSERT 12INSERT INTO 表名 VALUES ('','','')--若插入的列为空，写NULL DELETE 12345678910DELETE FROM 表名WHERE --where里面写查询--EXMPLEWHERE trajet_id in (SELECT trajet_id FROM arret WHERE EXTRACT(YEAR FROM arret_horaireprevu) = 2016 AND EXTRACT(MONTH FROM arret_horaireprevu) = 2 AND EXTRACT(YEAR FROM arret_horaireprevu) &lt; 9) UPDATE 123UPDATE 表名SET 列名WHERE …… TPTP1查询工作SELECT 1.UNION SELECT: Donner la/les fonction(s) de Yvon Manac’h 123456789101112SELECT 'Mecanicien' FROM Mecanicien NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Agent' FROM Agent NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Conducteur' FROM Conducteur NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'ChefDeGare' FROM ChefDeGare NATURAL JOIN PersonneWHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' 2.嵌套查询:Donner les horaires en gare de Nantes, pour les trains qui relient Nantes à Lyon pour la journée de demain. En pratique, on regardera quels trajets s’arrêtent à Nantes et Lyon. Attention, les gares de Lyon ne s’appellent pas ‘Gare de Lyon’ mais comporte Lyon dans leur nom. 12345678910111213141516SELECT DISTINCT train_id,trajet_id,arret_horaireprevuFROM train NATURAL JOIN trajet NATURAL JOIN arretWHERE trajet_id IN( SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%NANTES%' INTERSECT SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%LYON%')ORDER BY arret_horaireprevu--关于intersect:取交集--&gt;并集：union,差集：except TP2继续写select(聚集函数) 1.Combien y a-t-il de conducteurs dans la base ? 12SELECT COUNT(*) --COUNT(*)拿来统计列FROM conducteur 2.De combien de gare chaque chef de gare est-il responsable? 12SELECT personne_nom,personne_prenom,personne_id,count(*) FROM gare NATURAL JOIN chefdegare NATURAL JOIN personne GROUP BY personne_nom,personne_prenom,personne_id ORDER BY count 注意点：GROUP BY上写除函数之外的所有的select,聚集函数后可以直接命名，comme ca 3.MAX、AVG TP3SELECT + 导出PDF Générez un document, nommé rapport05.pdf, avec la liste des 5 propriétaires possédant les plus grandes superficies,triés en ordre décroissant des sommes de superficie de terrain qu’ils possèdent. On utilisera pour cela la fonction ST_AREA（算面积使用） 1234SELECT personne_nom,SUM(ST_AREA(parcelle_geometry)) AS area,COUNT(parcelle_id)FROM culture NATURAL JOIN parcelle NATURAL JOIN appartient NATURAL JOIN personneGROUP BY personne_nomORDER BY area DESC PROJECTTD6&amp;7 et TP 4&amp;5","link":"/2022/01/27/SSTEM-DS/"},{"title":"SSTEM01","text":"概要介绍SysML和其简单应用,对TD1的内容进行简单的总结与归纳。 定义SysML: un outil pour modéliser les Systèmes But: Analyse et description des systèmes( Besoin, Description de sous-systèmes, Chîne d’information) But pour cet TD: Analyse externe d’un systèmes Etape（以exemples进行更好说明）0.ExemplesAnalyse externe d’un radio-réveil. 1.Identification de la finalité des missions et objectifs du système​ finalité: Qu’est-ce qu’apporte le Système?à quoi sert-il? ​ missions: Comment le Système contribue-t-il à la finalité. Sur quels principes reposent la mise en oeuvre de la finalité? ​ objectifs: Comment le Système met-il en oeuvre ses missions? Exemples: ​ finalité: réveiller une personne endormie ​ missions: réveiller l’utilisateur à l’aide d’un signal sonore (bip ou radio choisie) à une heure prédéfinie. Diffuser le signal sonore émit par une station radio. ​ objectifs: Émettre un son suffisamment fort pour le réveil (ex: &gt; 90db). 2.Identification de interacteurs ou parties prenantes du système Faire une liste des parties prenantes: les éléments qui sont relies au Systèmes (systèmes physiques, personnes…) via une action sur ce système. Note: Les éléments interne du Système ne font pas partie des ‘parties prenantes’ Exemples: Faire un diagramme de bloc Le système est placé au centre du schéma. Il est relié aux parties prenantes. Sur le lien, on peut faire figurer la nature du lien 3.Les cas d’utilisationLe cycle de vie du Système peut comporter: conception, implémentation, implémentation, utilisation, démantèlement, recyclage. ​ Règles de dessin Les parties prenantes qui utilisent ou ont une action sur le Système seront représentées comme des acteurs, un petit bonhomme Le Système est représenté comme un bloc Dans le bloc figurent les actions(fonctionnalités) que peuvent faire les acteurs. Elles sont représentées par une ellipse. Dans le bloc, on doit dessiner les actions importantes et les liaisons entre les actions. 2 types: extend, include(obligatoirement). 4.Les interfacesCertaines des parties prenantes alimentent/sont alimentées par le Système. Pour chacune d’elle, on peut définir le/les flux(matière-énergie-information) qui sont échangés. ​ Règles de dessin Le système est un bloc au centre du schéma. Les flux entrants et sortants du système sont indiqués par des boites de connexion sur le bord du bloc central. Les flux sont également décrits par des boites sur le coté du diagramme. TD TD1小结：用学长的拼拼凑凑的搞上去的，但自己的第一次思考并没有把finalité,missions,objectif给找好。在理解上存在偏差。希望之后能够有所改进 单词Outil:工具 Radio-réveil:收音机闹钟 Sert:服务、帮助 Apporte：带来，提供 Mise:安装 oeuvre:工作 Diffuser:扩散、传播 Schéma:图解、提纲 Figurer:画出、代表 conception, implémentation, implémentation, utilisation, démantèlement, recyclage：设计，实施，实施，使用，拆卸，回收。 Flux:流动 Obligatoirement：必须的 结语来法国后的第一篇博客真的太多想说了的。（虽然在国内也没写几篇 首先就是上这节课的那天下午是流体的期末，所以对课上很多内容都不知道，包括TD1的实例，也有其他许多待修正的部分。 其次就是很多地方都是照搬的PPT，没有起到一个很好的总结和思考。 这篇博客完成的也是磕磕绊绊，对法语键盘的不熟悉（比如打不出oe和^i)和法语的不熟悉。 最后的最后，希望自己坚持下去，做好记录，出现越来越少不认识的单词和行文中越来越少的中文。 就祝自己能以此为新开始，用Blog的形式见证我在南特这两年的跌跌撞撞的成长。","link":"/2021/12/06/SSTEM01/"},{"title":"Voyage-Paris","text":"行程铁塔$\\longrightarrow$迪士尼$\\longrightarrow$卢浮宫$\\longrightarrow$奥赛$\\longrightarrow$先贤祠 Day 1下午到的 铁塔上看的夕阳 超好看！ 顺便打卡盗梦空间的桥 Day 2迪士尼好玩的 未来的日子永远爱跳跳虎 Day 3卢浮宫真的好大就是说 法国斥巨资修建这座宫殿或许比里面的展品还要了不起。 雕塑真的好厉害。 伊斯兰教的艺术印象蛮深。 然后镇馆三宝打卡成功：维纳斯、蒙娜丽莎、胜利女神 画的话，宗教类、宫廷很多。一开始很震撼，看多了，嗯，装不下。 Day 4奥赛博物馆的话就是好看的画 梵高好看 莫奈也好好看 还有个点彩画派 很喜欢的画买了明信片但忘记画家了T^T 出来时的公园，好看到分不清是不是在画中 （或许还记得出来一家商店里面的9000欧的衣服？ Day 5先贤祠 外面比里面好看 只记得里面的钟摆了 看到了一群穿正装的未来大佬们 听说隔壁是很法国很厉害的大学 站在那里真的会有 一种学术的 很厉害的感觉 听说建筑仿的是意大利的万神庙 那就正好 下一站意大利！ 最后巴黎再会~","link":"/2021/12/08/Voyage-Paris/"},{"title":"algorithm-绪论","text":"算法_第一章__绪论 1.算法的五大特征输入、输出、确定性、有穷性、可行性 2.算法的描述方法 自然语言描述 流程描述 伪代码描述 3.算法的重要问题排序、查找、字符串匹配、图问题、组合问题、几何问题、数值问题 4.算法基本的数据结构线性结构、数结构、图结构、集合 5.算法设计的方法策略蛮力法、递归与分治、动态规划、贪心算法、回溯与分治","link":"/2021/12/06/algorithm01/"},{"title":"Voyage-Italie","text":"行程马耳他$\\longrightarrow$罗马$\\longrightarrow$米兰 马耳他好看！ 看到海就真的超级开心 能在这个岛上过暑假的小孩应该很幸福吧 但就是住的好远（晕车真的难顶 体验了壁炉和烤鸡 还有偷偷摘下来的仙人掌的果 整体风格蛮中东的 但又特别电影 穷途末路的英雄的流浪故事 碰到的司机大叔也人超级好 希望这两年间能再去一次 带着夏企和橘子汽水 想念夏天 罗马西班牙台阶$\\longrightarrow$总统府（？maybe）$\\longrightarrow$圣天使堡$\\longrightarrow$梵蒂冈$\\longrightarrow$万神庙$\\longrightarrow$斗兽场$\\longrightarrow$什么祭坛 DAY1西班牙台阶，总统府和一个喷泉(and 张女士) 夕阳好看！ 龙虾意面好吃！ 冰淇淋好吃！ DAY2圣天使堡+法院+梵蒂冈+万神庙 夕阳好看！ 在梵蒂冈被骗了10欧QAQ 但暴走了两次不亏！（Cappella Sistina 看到了前前前手机壁纸，开心 DAY3斗兽场+祭坛 中餐好吃！ 臭鸟拉屎（猖狂到当地老太太会打伞的程度，可恶 米兰个人不官方的宣布 米兰就是旅游荒漠 只就去了大教堂，然后有猥琐的偷偷喂鸽子 但是！ 米兰火锅！好好吃！店名：“巴倒辣”。人生建议：不能点中辣不能点中辣不能点中辣！（上次被辣成瓜娃子还是在重庆的时候了 结语虽然没去佛罗伦萨和威尼斯，但得歇一段时间不看人文类风光啦~ 意大利再见 ε≡٩(๑&gt;₃&lt;)۶","link":"/2022/02/01/Voyage-Italie/"},{"title":"戛纳动机信","text":"Cannes!!! 开头Je suis une étudiante en double diplôme à l’Ecole Centrale de Nantes, en vue d’obtenir un diplôme d’ingénieur. Je suis très intéressé par le projet “Trois jours à Cannes” et j’aimerais partager avec vous ma principale motivation. 喜欢电影J’ai 22 ans et je viens d’une petite ville de Chengdu, une province centrale de Chine. Influencé par mes parents, j’aime regarder des films depuis que je suis enfant. Je suis particulièrement reconnaissant aux films de m’avoir fait découvrir un monde après l’autre pendant mon enfance. Je me souviens du choc que j’ai ressenti en regardant Harry Potter pour la première fois quand j’étais enfant, et je n’ai pas pu me calmer longtemps après. Jouer au Quidditch avec Ron dans mes rêves, m’allonger sur le balcon en attendant ma lettre d’acceptation à Poudlard, lutter pour trouver le quai 9 et 3/4 en prenant le train. Je me souviens aussi d’avoir regardé Les Chroniques de Narnia et d’avoir joué à cache-cache avec mes amis pour ensuite me cacher dans l’armoire, désireuse de s’embarquer dans une aventure où il faut aussi faire preuve de courage. Il n’est pas exagéré de dire que les films ont construit mon enfance. 我今年22岁，来自中国中部省份成都的一个小镇。受父母影响，我从小便喜欢看电影。我特别感谢电影给我童年带我走进了一个又一个的世界。我记得我小时候第一次看哈利波特时的震撼，看完以后久久不能平静。在梦里和罗恩打魁地奇，趴在阳台等霍格沃兹的录取通知书，在乘坐火车时努力的寻找9又3/4站台。我也记得我看完纳尼亚传奇后，从此和朋友玩捉迷藏只躲在衣柜，渴望也能开启一段关于勇气的冒险。毫不夸张的讲，电影构建了我的童年。 Lorsque je suis entré dans l’enseignement secondaire, les films n’étaient jamais absents non plus. Je me souviens d’un cours de musique où le professeur de musique nous a montré un extrait de Les choristes, et depuis lors, les films français, ou plutôt la France, ont commencé à entrer dans mon univers. Après avoir regardé Le fabuleux destin d’Amélie Poulain, j’ai été captivé par la romance créée par le film et en même temps déterminé à faire l’expérience du pays et de la culture française par moi-même pendant mes années d’université. Mais je dois admettre que lorsque j’étais jeune, j’étais immature et j’avais une vision unilatérale du monde, mais ces films sur différents sujets m’ont énormément aidé à construire un système de pensée selon lequel le monde est divers, la beauté est diverse et la vie est diverse, et ces films ont façonné ma tolérance. 升入中学后，电影也从未缺席。还记得那时一节音乐课，音乐老师给我们放了放牛班的春天选段，自此法国电影或者说法国开始进入我的世界。在看完天使爱美丽后，我被电影创造出的浪漫所深深吸引，同时坚定了自己要在大学期间亲历这片土地和法国文化。但我不得不承认，年轻时我的思想并不成熟，看世界的角度也很片面，但这些不同题材的电影给我带来了巨大的帮助，让我建立了一个世界是多元的、美是多元的、生活是多元的思维体系，这些电影塑造了我的宽容。 Le célèbre réalisateur français, Abel Gance a dit : “Ce n’est pas l’image qui fait le film, c’est l’âme de l’image”. Je me rappelle encore comment je me suis sentie chez moi cet après-midi de 2020, lorsque j’ai fini de regarder Le grand bleu de Luc Paul Maurice Besson. La scène où Jean-marc regarde tendrement son amant puis se retourne et se jette dans les bras de la mer est gravée dans mon esprit. Peut-être que les gens viennent au monde avec un but, la vie n’est 1/2 qu’un processus, et suivre son cœur au maximum est aussi une façon de vivre. Jean-marc est né seul et ne pouvait pas combler sa solitude dans la foule, préférant se plonger dans l’obscurité de la mer pour profiter d’un moment de paix. 法国著名导演阿贝尔-甘斯说：”拍摄电影的不是影像，而是影像的灵魂”。我仍然记得2020年的那个下午，当我看完吕克-保罗-莫里斯-贝松的《Le grand bleu》时，我在家里的感觉。让-马克温柔地看着他的爱人，然后转身投入大海的怀抱，这一幕深深地刻在我的脑海里。也许人们来到这个世界上是有目的的，生活是1/2个过程，充分跟随自己的心也是一种生活方式。让-马克生来孤独，在人群中无法填补他的孤独，他宁愿将自己沉浸在黑暗的大海中，享受片刻的宁静。 想来戛纳J’ai travaillé dur et j’ai pu poursuivre mes études en France comme je le souhaitais, les mots ne peuvent décrire mon excitation lorsque j’ai appris que j’aurais peut-être l’occasion d’aller au Festival du film de Cannes et de voir les meilleurs films du monde entier dans cette belle ville du sud, par une belle journée de mai. Le Festival de Cannes est pour moi un sanctuaire pour le pèlerinage des fidèles, un trésor si beau et si désirable pour les gourmands qui le cherchent tant. Mais aussi comme un bon ami, si familier, qui m’a rencontré dans mes rêves à travers d’innombrables films. C’est peut-être notre seule chance de nous rencontrer dans cette vie. Je pense que je n’oublierai jamais cette rencontre avec le Festival de Cannes et que ce sera l’une des expériences les plus importantes de ma vie. C’est pourquoi je demande au comité de me donner la possibilité de réaliser mon rêve de raconter mon histoire d’été à Cannes. Je vous en serais très reconnaissant. 现在我通过努力，如愿在法国开启我的学习生活，当我得知我可能有机会去参加戛纳电影节，在这个美丽的南方城市看到来自世界各地的最佳影片时，我的兴奋之情难以言表。戛纳电影节对我来说是一个供信徒朝圣的圣地，是一个如此美丽、如此令人向往的宝藏，让那些追求它的饕餮之徒欲罢不能。但也像一个好朋友，如此熟悉，通过无数的电影在梦中与我相遇。这可能是我们今生唯一的见面机会。我想我永远不会忘记这次与戛纳电影节的会面，这将是我人生中最重要的经历之一。这就是为什么我请求委员会给我机会实现我的梦想，在戛纳讲述我的夏季故事。我将非常感激。 结尾 Veuillez agréer, Mesdames, Messieurs, l’expression de ma considération distinguée. Li NI","link":"/2022/05/20/%E6%88%9B%E7%BA%B3%E5%8A%A8%E6%9C%BA%E4%BF%A1-1/"},{"title":"PAPY_CM2","text":"PAPY_CM2是老师的ipynb文件啦 Structuration et types de données Contenu Variables, références et gestion de la mémoire Programmation fonctionnelle Programmation orientée objet (OOP) : les classes Conseils généraux pour la programmation Rappel : les types de base en python int (entier) float (flottant) str (chaîne de caractères) bool (booléen) list (liste) tuple (tuple) complex (complexe) Variables, références et gestion de la mémoireVariables et affectation En python tout est objet $\\Longrightarrow$ la variable v peut changer de type. Definition: Une variable est un identificateur associé à une valeur. En Python, c’est une référence d’objet. 123456v=1print(f&quot;{v=},{type(v)}&quot;)v=&quot;bonjour&quot;print(f&quot;{v=},{type(v)}&quot;)def v(param) : return Noneprint(f&quot;{v=},\\t{v(1)=},\\t{type(v)}&quot;) Sytème d’affectation des variables immutables[可变的和不可变的不可更改的变量的分配系统] 12345678a=1b=2c=3print(f&quot;{a=}, {b=}, {c=}&quot;)c=bprint(f&quot;{a=}, {b=}, {c=}&quot;)a='z'print(f&quot;{a=}, {b=}, {c=}&quot;) Mutables et non-mutables Les variables simples vue jusqu’ici sont dites non-mutable i.e. on ne modifie jamais le contenu d’une case mémoire on affecte la variable à une nouvelle case Il existe des objets dits mutables, dont le contenu est directement modifié. Par exemple les listes ma_liste=[1,&quot;chaine&quot;] Les listes, mutable par excellence 123L=[1,2,3]L2=L #on crée une nouvelle référenceprint(L==L2)--&gt;True ⚠️ Toute modification par l’un des “pointeurs” entraine une modification de la liste pointée. 任何一个 “指针 “的修改都会导致对被指向的列表的修改。 123L2[2]=10print(L==L2, id(L)==id(L2))#True Trueprint(L) 12L2=4 #on change l'affectation de la variableprint(L==L2)#Flase 123456#Si on veut créer une copie de la liste et pas un pointeur#Copie simpleLcopie=L[:]print(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L))#Flase 123456# Par le module copie import copyLcopie=copy.copy(L) #shallowprint(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L)) Les dictionnaires : “listes” clé/valeur12valeur=10dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]} 1dictionnaire[&quot;clé&quot;] 1234dic2=copy.copy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire) ⚠️ La “shallow” copy n’a créé de copie que pour le niveau supérieur. Pour tout copier, on utilise copy.deepcopy() 深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同。 12345678dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]}dic2=copy.deepcopy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire)#on utilise l'opérateur ** pour &quot;unpack&quot; un dictionnaire, très utile pour en concaténer deux#**操作符用于解压一个字典，这对于连接两个字典非常有用new_dic={**dictionnaire,**{&quot;var&quot;:1.2}} Le tuple, une liste non-mutable1234# exemple de tuplevecteur=(1,0,0)print(f&quot;{vecteur=}, {type(vecteur)=}&quot;)vecteur[1]=2#会报错，因为不能被修改 L’opération précédente est illégale puisque le tuple n’est pas modifiable après sa création. Il faut réallouer la variable par un nouveau tuple contenant la valeur souhaitée. 123vecteur=(vecteur[0],vecteur[1],2)#que l'on peut remplacer par l'opération suivantevecteur=(*vecteur[:1],2) Quelques autres types qui peuvent etre utile set est une collection itérable non ordonnée d’éléments hachables uniques 集合，无序 module collections collections是Python内建的一个集合模块，提供了许多有用的集合类和方法。可以把它理解为一个容器，里面提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。 defaultdic du propose des dictionnaires avec valeur par défaut：当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值，可以是list、set、str等，用法 12from collections import defaultdictdict1 = defaultdict(int) counter bien pratique pour des dictionnaires de dénombrement: 作用是计算出字符串或者列表等中不同元素出现的个数，返回值可以理解为一个字典 deque pour des listes à accés rapide des extrémités (file,tas ):可以实现双端队列 module heapq pour des opérations efficaces sur les tas：实现堆栈 Plus d’infos dans Programmation Python Avancée, X. Olive Gestion de la mémoire Contrairement aux langages plus bas niveau, python gère “automatiquement” la mémoire. Il l’alloue et la libère tout seul. 自动管理内存：自己分配和释放内存 Garbage collector si une donnée en mémoire n’est plus référencée, le garbage collector gc de Python la supprime automatiquement (car son nombre de références tombe à zéro) 12345import sysdonnee=[1,2,3]print(sys.getrefcount(donnee)) # le texte lui meme plus le passage à getrefcountmaliste=donneeprint(sys.getrefcount(donnee)) la fonction del permet de supprimer une référence, pas son contenu. 1del(donnee) Le contenu est nettoyé par le garbage collector automatiquement. On peut néanmoins accéder au gc ainsi 123import gcgc.collect() # fait le ménagegc.get_threshold() # un second mécanisme &quot;générationel&quot; traite les récursions, avec les propriétés suivantes Evaluation de l’usage mémoire Pour des programmes complexes ou traitant de grandes données, on peut suivre l’usage mémoire par profiler Il existe une multitude de solution, la plupart vont aller chercher activement l’usage mémoire à interval regulier (ou lors des allocations) pour obtenir une bonne estimation de l’usage mémoire. Ici, on peut installer l’outil memory_profiler qui s’intègre facilement à jupyter.1234!mamba install -c conda-forge memory_profiler -y%load_ext memory_profiler# que l'on appelle ensuite ainsi%memit [i for i in range(100000)] Il existe une version ligne par ligne %mprun qui ne fonctionne que pour les fonctions définies dans des fichiers externe. (cf TP) Programmation fonctionelleFonctionsOn défini une fonction de la façon suivante: 12345def fonc(x, y=0, *args, **kwargs): &quot;&quot;&quot;Un docstring est fortement recommandé ---docstring?&quot;&quot;&quot; x*y return # même si on ne renvoie rien! Que l’on appèlerai ainsi: 1234567fonc(10,20)#oufonc(10,y=20)#ou, avec les arguments surnuméraires en supposant args et kwargs bien définisargs=[]kwargs={}fonc(10,args, kwargs) Les arguments d'une fonction peuvent etres passés nommés ou non. S'ils ne le sont pas l'ordre est important. Détails sur le passage des arguments1234def fonc(x, y=0, *args, **kwargs): #actions return &gt;&gt;&gt; fonc(10,args, kwargs) Le passage se fait par assignation et pas par références en soi. C'est à dire, qu'un nouvel alias est créé, pointant vers la case mémoire concernée. Deux cas de figure suivant que l'objet est: immutable : toute modification dans le corps de la fonction entraine une nouvelle assignation/allocation. mutable : toute modification dans le corps de la fonction entraine une modification de l'objet pointé. Donc de l'objet dans l'espace global. ??????? > ⚠️ Ne pas utiliser des mutables en valeur par défaut. Leur durée de vie dépasse l'appel de la fonction! 1234567def ajout_liste(L=[],elem=&quot;elem&quot;): #une liste inutile qui ajoute un élément à une liste L.append(elem) print(L)ajout_liste(elem=1)ajout_liste(elem=2) #quel résultat est attendu? Les fonctions sont des objets/variables comme les autres! Mais on peut les appeler (callable). ➡️ On peut passer une fonction comme argument 函数和其他的对象/变量一样！但它们可以被调用（可调用）。➡️ 可以将一个函数作为参数传入 12def fonc2(fonc): return 2*(fonc(100)) On dispose même des fonctions anonymes lambda function qui sont définies à la volée, tant qu’elles sont mono-instruction. 1fonc2(lambda x: x+1) En pratique on les utilisera seulement si l’instruction est très simple et facile à comprendre. Sinon on déclare une nouvelle fonction! 在实践中，只有在指令非常简单和容易理解的情况下才应使用它们。否则，将声明一个新的函数. Type hinting python&gt;=3.512def hello_name(name: str) -&gt; str: return(f&quot;Hello {name}&quot;) Portée[范围] des variablesVariables locales, variables globales Les variables définies (ou passées) à la fonctions sont locales i.e. accessibles uniquement depuis la fonction et détruites ensuite. Les variables définies à l’extérieur d’une fonction sont des variables globales. Leur contenu est « visible » de l’intérieur d’une fonction, mais la fonction ne peut pas le modifier. 在一个函数之外定义的变量是全局变量。它们的内容在一个函数中是 “可见的”，但函数不能改变它们。 12345x = &quot;global&quot;def foo(): x = x * 2 #会报错，改成1也不行 print(x)foo() On peut aussi utiliser (rarement) le mot clé global pour s’assurer que l’on modifie une variable globale du programme. 123456789x = &quot;global &quot;def foo(): global x # Essayer avec et sans! y = &quot;local&quot; x = x * 2#字符串也有乘法的 print(x) print(y)foo() Le cas nonlocal pour les fonctions imbriqués 123456789def outer(): x = &quot;local&quot; def inner(): nonlocal x x = &quot;nonlocal&quot; print(&quot;inner:&quot;, x) inner() print(&quot;outer:&quot;, x)outer() Paradigme[范式] : La programmation fonctionnelleUn petit peu de théorie de la programmation La programmation impérative 命令式编程 est le paradigme le plus répendu. On découpe le programme en une séquence d'instructions à exécuter. C'est une description de l'algo à exécuter pour résoudre le problème. 🚀 Offre un bon controle de la performmance. La programmation déclarative声明式编程 considère le programme par une description du problème. Le moteur du language met en oeuve l'algo permettant la résolution. C'est un paradigme de programmation sans effet de bord c.à.d. sans état interne permanent. Exemple : Latex, CSS. ✔️ Formel donc permet de prouver que les résultats sont corrects. La programmation fonctionnelle est une variante de programmation déclarative. La programmation est vue comme l'évaluation de fonctions mathématiques sans effet de bord. ☞ Langages fonctionnels : Haskell, Scala, OCaml Par exemple: 12L=[1,3,7,10,-1]L.sort(),L 12L=[1,3,7,10,-1]sorted(L),L La méthode .sort est impérative[命令]. Elle modifie l’input avec une série d’instructions. La fonction sorted suit un modèle fonctionnel, sans effet de bord. Deux appels successifs ne changent pas le résultat. Un programme utile aura toujours des effets de bords, il interragit avec le monde extérieur. Python n’est pas un langage fonctionnel. Cependant, les recommandations de la programmation fonctionnelle: limiter les effets de bord et états internes limiter les mutables programmation qui caractérise la solution plutot que la procédure permettent un style modulaire et donc compsable. En pratique cela facilite aussi le teste et les débugs et certaines accélérations (jit, parallèlisme, GPU). Les bibliothèques pandas et altair ont une approche très fonctionnelle. numpy beaucoup moins comme on le verra. Fonctions pures et d’ordre supérieur Une fonction pure est une fonction dont le résultat dépend uniquement de ses arguments, donc sans effets de bord. En programmation foncitonnelle on utilise que des fonctions pures Une fonction d'ordre supérieur est une fonction qui prend en argument une fonction ou renvoie une fonction. Exercice: Ecrire une fonction pure fibonacci(et récursive) qui calcule le n-ème terme de la suite de Fibonacci. Rappel $f_0=1,f_1=1$ et $\\forall n >1, \\quad f_n=f_{n-1}+f_{n-2}$. 1234def fibonacci(n:int)-&gt;int: if n in [0,1]: return 1 return(fibonacci(n-1)+fibonacci(n-2)) Exercice: Ecrire une fonction d'ordre supérieur n_premiers qui renvoie une fonction qui calcule les n permiers termes de la suite de Fibonacci. 1234from typing import Listdef n_premiers(func: &quot;int -&gt; int&quot;, n: int) -&gt; List[int]:#注意这里参数的是函数 return [func(i) for i in range(n)]print(n_premiers(fibonacci,10)) Exercice: Ecrire une fonction d'ordre supérieur premiers qui renvoie une fonction qui calcule les n permiers termes d'une suite et l'appliquer Fibonacci. 12345#关于这里声明的理解，输出是函数，然后输出的函数式int做输入，list做输出def premiers(func: &quot;int -&gt; int&quot;) -&gt; &quot;int -&gt; List[int]&quot;: def n_premiers_func(n: int) -&gt; List[int]: return n_premiers(func,n) return n_premiers_func 12n_premiers_fibonacci=premiers(fibonacci)n_premiers_fibonacci(10) ### Deux mots sur les décorateurs Un décorateur de fonction (d'ordre supérieur) est un outil qui permet de marquer une fonction afin d'en modifier le comportement. Il est marqué par le `@décorateur` avant une fonction. 12345678910111213141516171819from time import timedef timer(func:&quot;fonction&quot;)-&gt;&quot;fonction&quot;: name=func.__name__ def timed_func(*args): t1=time() arg_str=', '.join(repr(arg) for arg in args) resultat=func(*args) elapsed=time()-t1 print(f&quot;{name}({arg_str}) elapsed time [{elapsed:0.8f}s]&quot;) return resultat return timed_func@timerdef factorielle(n: int)-&gt;int: res=1 for i in range(1,n): res*=i return resprint(factorielle(20)) Attention aux fonctions réccursives, l'appel sera affiché à chaque fois! 123456@timerdef factorielle_rec(n: int)-&gt;int: if n in [0,1]: return 1 return n*factorielle_rec(n-1)print(factorielle_rec(20)) ### Itérateurs et générateurs > En programmation fonctionelle, la récursion joue souvent le role d'**itérateur** à la place des boucles `for`. Si on voit l'itération comme *une structure générique qui fourni un service*, alors les structures itérables fournissent des élément un à un sans avoir à les charger intégralement en mémoire. On peut: - les parcourir avec un `for` - construire des structures en les *consommant* - les manipuler par compréhension - les déballer 12type(range(10))#rangelist(range(10)) #### Retour sur l'écriture en compréhension On peut utiliser les listes en compréhension pour créer des nouvelles structures et améliorer (un peu) la performance. 1234567%%timeit L=[2*x**3 for x in range(1000000)]#等价于%%timeit #可以用于计时L=[]for x in range(1000000): L.append(2*x**3) #### Créer ses propres itérateurs avec le mot clé `yield` > *Une fonction qui contient le mot-clé `yield` renvoie un générateur.* Lorsqu'une fonction rencontre `yield`: - elle renvoie la valeur courante - attend la prochaine itération dans la boucle - reprend le programme la ou il s'était arrété La suite de Syracuse est définie ainsi: Pour tout entier $n$, l'entier suivant est défini par $$ \\mathrm{new} \\; n = \\begin{cases} \\frac{n}{2} &\\text{si } n \\; \\text{est pair} \\\\[4px] 3n+1 & \\text{if } n \\text{ sinon}.\\end{cases}$$ Exercice: Ecrire un générateur de al suite de Syracuse grâce au mot-clé yield. Y ajouter une fonction qui calcule la longueur jusqu'à atteindre 1 length et celle qui donne la hauteur max max 123456&gt;&gt;&gt; def syracuse(n: int)-&gt;&quot;generator&quot;:&gt;&gt;&gt; ...&gt;&gt;&gt; yield n&gt;&gt;&gt;&gt;&gt;&gt; list(syracuse(10))[10, 5, 16, 8, 4, 2, 1] 123456789101112131415def syracuse(n: int)-&gt;&quot;generator&quot;: yield n #première itération, renvoie simplement l'input (pas de récursion ici) while n!=1: # le programme s'interrompt lorsque n=1, comme prévu if n%2==0: n=n//2 else: n=3*n+1 yield n # renvoie la nouvelle valeur de n à chaque passagelist(syracuse(10)) #[10,5,16,8,4,2,1]def length(iterable): return sum(1 for _ in iterable)length(syracuse(27))#122# trick&quot;-&gt;&quot;.join(str(i) for i in syracuse(27)) Pour aller plus loin : le module itertools permet des manipulations poussées des itérateurs la fonction next renvoie la première valeur du générateur les coroutines consomment des éléments à chaque appel Des “built-ins” et functoolmapmap(func, sequence) applique une fonction à tous les éléments d’une séquence avec évaluation paresseuse (lazy). 12map(fibonacci,[1,10,20])list(map(fibonacci,[1,10,20])) filterfilter(func,x) fonctionne de la même façon et renvoie les éléments de x pour lesquels func renvoie vrai. 123def paire(n:int)-&gt;bool: return(n%2==0)list(filter(paire,[1,10,11])) reducereduce(func,x) applique de façon cummulative [累积] la fonction func aux éléments de x. 12345from functools import reducefrom operator import addreduce(add,[1,10,100])#sum fait le meme travail...sum([1,10,100]) Dans le meme esprit on a : any et all pour les opérations booléennes Programmation orientée objet Python est un langage fondamentalement orienté objet (OOP), les classes, instances et méthodes étant omniprésentes. A reprendre au tableau Quelques notions à avoir en tete avant de commencer : encapsulation: l’objet embarque toutes ses propriétés (varibales, méthodes) dans un espace de nommage 封装 interface: on part du service rendu qui est présenté à l’utilisateur pour concevoir la machinerie interne 接口 factorisation [结构化]: on mutualisera au maximum les portions de code similaires grace aux concepts d’héritage[继承] et de composition[组合] Les classes On va suivre l’excellente présentation du livre de Xavier Olive, “Programmation python avancée” qui utilise les “Boids” Un Boid (bird-oid) est une représentation simplifiée proposée par Craig Reynolds pour modéliser le comportement d’oiseaux avec les regles suivantes : de séparation pour préserver une distance minimum entre les individus de cohésion pour que les boids volent en groupe d’alignement pour qu’ils volent dans la meme direction [博伊德（鸟类）是克雷格-雷诺兹提出的一种简化表示法，用于模拟鸟类的行为，其规则如下。 隔离*以保持个人之间的最小距离 凝聚力*，从而使boids成群结队地飞行 对齐*，使它们飞向同一方向] Création d’une classe123import numpy as npclass Boid: pass 12b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1 Attention: Il n'y a pas de notion d'attributs publics et privés en python[没有私有或者公有的概念] ! On utilisera des attribus pseudo privés notés par _x Une méthode est une “fonction” définie dans le corps de la classe et qui vie dans son espace de nommage. 1234567class Boid: def module_vitesse(self): return np.sqrt(self.v_x**2+self.v_y**2) b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1b.module_vitesse() La méthode réservée __init__ est le constructeur de la classe. Il est appelé chaque fois que cette classe est instanciée. 123456789101112class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y 123b=Boid((0,0),(1,2))b.avance()b __repr__(self) -&gt; str définie une représentation de l’objet qui est renvoyée par l’interpréteur __str__(self) -&gt; str est l’affichage renvoyé par print(). Renvoie __repr__ si non défini 1234567891011121314class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y def __repr__(self)-&gt;str: return f&quot;Boid({self.x,self.y}, {self.v_x,self.v_y})&quot; 123b=Boid((0,0),(1,2))b.avance()b On peut choisir de programmer des méthodes qui modifient ou non l'état interne. De même, on peut choisir des méthodes qui renvoient ou non un résultat. Arguments par défaut. On veut pouvoir initialiser automatiquement nos instances (avec un peu de hasard). C’est l’idée programmatique de factory. Une variable de classe est une variable qui est liée à la classe et non à l’instance. 1234567891011121314151617181920212223242526class Boid: taille = 300 # dimension du domaine des positions count = 0 def __init__(self, position=None, vitesse=None) -&gt; None: self.x = ( position if position is not None else np.random.uniform(-Boid.taille, Boid.taille, 2) ) self.dx = vitesse if vitesse is not None else np.random.uniform(-5, 5, 2) Boid.count +=1 def __repr__(self) -&gt; str: return f&quot;Boid({self.x.round(2)}, {self.dx.round(2)}, parmi {Boid.count})&quot; def vitesse(self)-&gt; float: return np.linalg.norm(self.dx) def avance(self) -&gt; &quot;Boid&quot;: return Boid(self.x+self.dx, self.dx) def __del__(self): #on implémente un destructeur pour s'assurer que count est mis à jours correctement Boid.count-=1 print('__del__ was called') 123b=Boid()c=b.avance()b, c 123b=0del(b)c=None 1Boid.count ☣️ Nous n'avons pas de contrôle direct sur le garbage collector. Le comportement est plus reproductible sur un appel python type python file.py Décorer ses objetsA défaut d’attributs privés, on peut imposer certains comportements: @property définit un raccourcis qui s’utilise comme une variable. (utile de l’ustiliser avec _var_name pour “protéger” une variable. @var_name.setter pour pouvoir modifier la valeur de la variable On défini une propriété vitesse de la façon suivante1234567@propertydef vitesse(self) -&gt; float: return np.linalg.norm(self.dx)@vitesse.setterdef vitesse(self, value: float) -&gt; None: self.dx = self.dx * value / self.vitesse De même il est parfois utile de définir une nouvelle façon d’initialiser une instance de notre classe. Le décorateur @classmethod le permet:123@classmethoddef polaire(cls, r, theta, v, direction): return cls(r*np.array([np.cos(theta),np.sin(theta)]),v*np.array([np.cos(direction),np.sin(direction)])) Enfin, on peut souhaiter encapsuler une “fonction” dans une classe par exemple pour controler sa visibilité. On utilisera le décorateur @staticmethod lors de la déclaration de la fonction.123@staticmethoddef scene(n:int) -&gt; &quot;list[Boid]&quot;: return [Boid() for _ in range(n)] Exercice : Make'em fly Avec le squellette de classe fourni dans boid_partial.py, faire voler la nuée. Appel pour exécuter le script et tracer la figure. La classe animation est déjà écrite.1234567891011fig, ax = plt.subplots(figsize=(7, 7))simulation = Simulation(n=100, ax=ax)anim = animation.FuncAnimation( fig, simulation.iteration, frames=range(0, 200), interval=150, blit=True, repeat=True,)anim.save(&quot;boids.mp4&quot;) On pourra aussi jouer avec les variables de classes qui modifient le rapport de force entre les composantes qui dirigent le vol.1234sep_coef=10align_coef=8cohere_coef= 100centripete_coef= 200 Héritage et compositionUne classe fille peut hériter des propriétés (et méthodes) d’une classe mère. Ceci permet de factoriser efficacement le code. Attention, dans bien des cas, une relation de composition est plus judicieuse. Dans ce cas, un des attribus de la classe est un objet d’une autre classe. 123456789101112131415161718192021222324# exemple d'héritage: class Personne: def __init__(self, nom, prenom, age): self.nom=nom self.prenom=prenom self.age=age def __repr__(self): return f&quot;{self.nom} {self.prenom} ({self.age}ans)&quot; def gen_ID(self): return (self.nom+self.prenom[0]).lower() def anniversaire(self): self.age+=1 print(&quot;Joyeux anniversaire&quot;) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; 123eleve=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)print(eleve.anniversaire())print(super(eleve).name) 123456789101112131415161718192021#Exemple de compositionclass Bulletin: def __init__(self, date, notes :&quot;ndarray&quot;): self.date=date self.notes=notes def moyenne(self): return np.average(notes) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() self.bulletins=[] def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; def meilleure_note(self): return np.array([B.notes for B in self.bulletins]).max() 1234jean=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,2,1])))jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,20,1])))jean.meilleure_note() Quelques conseils de structurationBien comprendre le problème et le cahier des charges analyser le problème quels sont les objectifs quel structure générale est nécessaire exécutable script API quelles sont les classes/variables de haut niveau choisir le bon environnement de travail Ebauche écrire un petit code test n’est pas interdit créer les grandes structures et fonctions en premier, quitte à les laisser vide mais commentées “simple is beautiful” -&gt; zen of python Dev / Test si possible écrire les tests / appels API en premier -&gt; contraint le dev dans la bonne direction test driven programming? s’assurer du bon fonctionnement des briques élémentaires au fur et à mesure Rappel : développer c'est environs 90% de débuggage => Il faut absolument écrire du code lisible!! Vers un code en production : Optimisation et parallèlisme Optimisation ne pas chercher à optimiser dès le départ mais avoir en tête un ensemble de pratiques favorables utiliser des outils de profiling Améliorer son code python / algo Utiliser (mieux) des libraries Chercher des améliorations techniques (JIT, langages compilés) Parallèlisation python n’est pas très propice au // un bon code séquentiel est un prérequis absolu dans quelques cas, on pourra avoir un gain de performance pour les tableaux : calcul GPU","link":"/2022/09/16/PAPY_CM2/"},{"title":"排序算法(一)","text":"排序算法浅学排序[基于对大一数据结构的整理] 3种$T(n) = O(n^2)$的基本排序选择排序找最大/最小与头或尾交换 123456789101112131415161718192021222324void SelSort(int R[],int n){ for(i=0;i&lt;=n-2;i++) { m = i; for(j=i;j&lt;n;j++)//找最值 { if(R[j]&lt;R[m]) m = j; } if(m != i) swap(R[i],R[m]) }}//递归实现void SelSort(int R[],int n,int i){ if(i &gt; n-2) return ; m = i; for(j=i;j&lt;n;j++)//找最值 if(R[j]&lt;R[m]) m = j; if(m != i) swap(R[i],R[m]) SelSort(R,n,i+1)} 插入排序1.教案版 算法描述： 排第i个时用j去找位置，找到位置后插入并使别的元素移动。每次循环完前i个数按升序排列 算法实现 12345678910111213void InsertSort(ElemTp R[],int n){ for(int i = 1 ; i &lt; n;i++) { j = 0; while(j&lt;i &amp;&amp; R[j].valeur &lt;= R[i].valeur) j++; //把R[i]插入到位置R[j]左边 //这里用的是vector的insert函数，有后移操作，复杂度为O(n) R.insert(R.begin()+j,R[i]); R.erase(R.begin()+i+1); }} 时间复杂度为O(n^2) 2.网上看到的 //从后往前，查找的时候就进行后移操作 12345678910111213void insertion_sort(int arr[],int len){ for(int i=1;i&lt;len;i++) { int key=arr[i]; int j=i-1; while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; }} 冒泡排序每次循环进行两两比较和交换，第i次循环结束，第i大（小）的数排序完成。 算法实现 123456789101112131415161718192021void bubble_sort(int arr[], int len){ for(int i=0;i&lt;len;i++) { int flag=0； for(int j=0;j&lt;k;j++) { if(arr[j]&gt;arr[j+1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = 1； pos = j; } } k = pos; if(!flag) return; }} 时间复杂度为O(n^2) 冒泡排序的优化： 加入flag判断当前是否已经排序完成。 加入记录上次循环发生交换的最后位置pos,说明后(或者前)pos个是已经排好了，下次循环只需比到k即可 希尔排序将待排序列分割成子序列[序号相同的是一个子序列]，对子序列进行插入排序，当增量为1时，排序完成。 例子： 一般来讲增量序列的size是3或者4//循环次数 代码实现： 1.赵宏宇版 1234567891011121314151617void shell_sort(vector&lt;int&gt; arr[],vector&lt;int&gt; d[])//d里面存增量序列{ for(int i=0;i&lt;d.size;i++) { for(int j=0;j&lt;d[i];j++) { //进行插入排序,从后边查边移,真难看，(bushi for(int k = j+d[i];k&lt;arr.size;k+=d[i]) { int temp = arr[k]; for(int t = k-d[i]; t&gt;=j &amp;&amp; arr[t]&gt;arr[j];t-=d[i]) arr[t+d[i]] = arr[t]; arr[t+d[i]]=temp; } } }} 2.网络版 排两次，增量序列为(4,1) 123456789101112131415161718192021222324252627template&lt;typename T&gt;void shell_sort(T array[], int length) { int h = 1; //[就是说，length为2和3是直接插入排就行了] while (h &lt; length / 3) { h = 3 * h + 1;//增量序列为(4,1) } //增量序列为1是排序完成 while (h &gt;= 1) { //插入排序，对array[0,h] for (int i = h; i &lt; length; i++) { for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) { swap(array[j], array[j - h]); } } //减小增量序列 h = h / 3; }} 时间复杂度分析 增量为2时，$T(n) = O(n^{1.5})$ n在某个特定范围内，$T(n) = O(n^{1.3})$ n趋于无穷时，$T(n) = O(n(log_2n)^2)$ 快排找支点，比支点小的放左边，比支点大的放右边。对放左边，放右边的子序列执行同样的操作。直到不能拆分出子序列为止 比支点小的放左边，比支点大的放右边的实现：一个i从头到尾，一个j从尾到头，j遍历到小于支点的位置停下，然后i遍历到大于支点的位置停下，交换。然后重复先j然后i，直到i=j,将基准数与i交换 12345678910111213141516171819void quicksort(int left,int right){ int i,j,t,temp; if(left&gt;right) return; //排序完成 temp = a[left]//支点 i = left; j = right; while(i != j) { while(a[j] &gt;= temp &amp;&amp; i &lt; j) j-- while(a[i] &gt;= temp &amp;&amp; i &lt; j) i++ if(i&lt;j) swap(a[i],a[j]) } //支点归位 swap(a[left],a[i]) //递归 quicksort(left,i-1) quicksort(i+1,right)} 时间复杂度为$O(nlogn)$ 堆排序什么是堆n个元素组成的序列$\\{R_0,R_1,…,R_{n-1}\\}$时,但满足$R_i.K &gt;= R_{2i+1}.K and R_i.K &gt;= R_{2i+2}$时该序列就是堆[或者同时小于] 存储结构是一维数组，逻辑结构是完全二叉树[插入顺序必须为从上到下从左到右] 大根堆就是每个父节点都比子节点要大，小根堆同理 下标为i的节点的父节点：(i-1)/2,子节点2i+1和2i+2 堆性质的维护 12345678910111213141516void heapify(int arr[], int len, int i){ int largest = i; int lson = i * 2 + 1; int rson = i * 2 + 2; if (lson &lt; len &amp;&amp; arr[largest] &lt; arr[lson]) largest = lson; if (rson &lt; len &amp;&amp; arr[largest] &lt; arr[rson]) largest = rson; if (largest != i) { swap(&amp;arr[largest], &amp;arr[i]); heapify(arr, len, largest);//递归维护剩余位置，注意这里的largest是交换后的那个位置 }} 算法基本思想：建堆。堆顶与最后一个元素交换，它就是最大了的，然后维护剩余元素的性质。然后循环。 1234567891011121314void heap_sort(int arr[], int len){ int i; // 建堆 for (i = len / 2 - 1; i &gt;= 0; i--) heapify(arr, len, i); // 排序 for (i = len - 1; i &gt; 0; i--) { swap(&amp;arr[i], &amp;arr[0]);//堆顶与最后一个元素交换 heapify(arr, i, 0);//维护剩余元素 }} 时间复杂度是$O(nlogn)$ 归并排序二分到子序列只有一个元素位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 合并void merge(int arr[], int tempArr[], int left, int mid, int right){ int l_pos = left; // 标记左半区第一个未排序的元素 int r_pos = mid + 1;// 标记右半区第一个未排序的元素 int pos = left;// 临时数组元素的下标 //合并 while (l_pos &lt;= mid &amp;&amp; r_pos &lt;= right) { if (arr[l_pos] &lt; arr[r_pos])// 左半区第一个剩余元素更小 tempArr[pos++] = arr[l_pos++]; else // 右半区第一个剩余元素更小 tempArr[pos++] = arr[r_pos++]; } // 合并左半区剩余的元素 while (l_pos &lt;= mid) tempArr[pos++] = arr[l_pos++]; // 合并右半区剩余的元素 while (r_pos &lt;= right) tempArr[pos++] = arr[r_pos++]; // 把临时数组中合并后的元素复制回原来的数组 while (left &lt;= right) { arr[left] = tempArr[left]; left++; }}// 归并排序void msort(int arr[], int tempArr[], int left, int right){ if (left &lt; right)//只有一个元素不需要划分 { //找中间点进行划分 int mid = (left + right) / 2; msort(arr, tempArr, left, mid); msort(arr, tempArr, mid + 1, right); //合并已经排序的部分 merge(arr, tempArr, left, mid, right); }}// 归并排序入口void merge_sort(int arr[], int n){ // 分配一个辅助数组 int tempArr[n]; // 调用实际的归并排序 msort(arr, tempArr, 0, n - 1);} 时间复杂度是$O(nlogn)$ 计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 把这个新的数组还原回去就可以了 1234567891011121314151617def countingSort(arr,maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) #计算频率 for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 #把它还原回去 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 适用于整数，但容易存在空间浪费 时间复杂度是: $O(n+r)$ 基数排序基本思想在于：将整数按位数切割成不同数字，然后按照每个位数进行比较 取得数组中的最大数，并取得位数； 对数位较短的数前面补零； 分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中; 收集，再将放置在0~9号桶中的数据按顺序放到数组中; 重复3~4过程，直到最高位，即可完成排序。 1234567891011def radix_sort(arr:List[int]): n = len(str(max(arr))) #记录最大值的位数 for k in range(n):#n轮排序 # 每一轮生成10个列表 bucket_list=[[] for i in range(10)]#因为每一位数字都是0~9，故建立10个桶 for i in arr: # 按第k位放入到桶中 bucket_list[i//(10**k)%10].append(i) # 按当前桶的顺序重排列表 arr=[j for i in bucket_list for j in i] return arr 时间复杂度是$O((n+r)*k)$ [n是待排序列的长度，k是最大数字的位数，十进制的基数r为10] 基数排序的本质是依据LSD排序准则的排序[关键字组排序]，关键操作是分配和收集 分配：按最低位关键字[个位，秒]将其排序[相同的放在一个桶] 收集: 得到的新序列按最低位关键字排好序了，同组的先取第一个加进去的","link":"/2022/05/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/"},{"title":"序言","text":"序太晚了，明天写。 截断测试 图片测试： 数学公式测试 T(n)=\\sum_i C_{opi} * C_i(n)公式测试2 T(n)=\\sum_i C_{opi} * C_i(n)Flags： 侧边栏多级分类 FLUID整理 Pro20整理 SSTEM一周一记","link":"/2021/12/05/hello-world/"},{"title":"遗传算法","text":"遗传算法帮ZZ做SRTP学的一些东西 1.简介一些生物学常识基因型、表现型 进化：群体，个体，适应度(Fitness) 优化问题—&gt;优化问题模型f(X)目标函数+约束条件 求最优化问题的方法：枚举，启发式算法（？），搜索 遗传算法中的基本过程 选择：按照个体适应度，按照一定的规则，从t代群体P（t）中选择优良个体遗传到P（t+1） 交叉 ：将P（t）内的各个个体随机搭配成对，以每一对个体，以某个概率交换 变异：对群体P（t）中的每一个个体，以某一概率改变某一个或者某一些值 流程 群体：可行解编码成基因的个体的一个集合 模拟遗传算法的简单实例 个体编码 初始群体的产生 选取起始搜索点的初始群体数据，需要选取群体规模，这里选4。个体则随机产生 适应度计算 这里直接以目标函数为适应度 第6列表示适应度概率，7进行选择，注意选择完成时，群体规模是保持不变的 ​ 9,10,11进行交叉的过程：配对的第2位进行交叉（等位基因） ​ 12,13进行变异 ​ 13产生子代群体，完成一次迭代。 最优解可由迭代次数决定 2.基本的遗传算法遗传算法解决TSP问题问题抽象1.如何将答案编码成基因 旅行路线—&gt;一个数组 2.如何定义个体适应度 路程（目标函数）","link":"/2022/07/29/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"title":"那些细碎而美好的存在","text":"序一个持续更新的日常记录 2022_2_1我画画真好看，嘿嘿 以及，新的学期新的摸鱼 2022_2_2-经过一天的讨论，滑雪假兜兜转转起起伏伏，最终成为了和学长一起的法国自驾游（开心期待 -希望快点长大到可以开着车向着随机方向选择随机地点随机停留的那天 -莫名其妙的去测了MBTI，第三次了吧，真的好神奇，还是INFJ，从高考填志愿到大一再到今天。 2022_2_3安然给的国家爸爸发的大白兔，四舍五入我也收到大使馆的春节礼物啦 2022_2_4很难不记录 2022_2_7周六周末没有学习，可恶 看到一个好有意思的财神爷饭，周五做给大家吃，期待复刻，嘿嘿 2022_2_9关于财神饭的复刻,成功! 2022_2_10谷爱凌nb！！！！！以及抓摸鱼的zwl子 2022_2_11摸了一个谷爱凌和意外好吃的番茄牛奶辣椒粥 2022_2_12旅行途中遇到的可可爱爱的善意们 2022_2_21春天来了 2022_3_4可以做梦不补考吗(靓女流泪 2022_3_7好好听 2022_8_8突然更新 和学长们告别 和贺文城告别 不喜欢告别 2022_8_20想记录遇见的可爱的人们的那些陌生的善意。 去罗卡角火车上疯狂葡萄牙语输出的阿姨 一直说着CHINA和FRIENDSHIP大概是巴基斯坦的里斯本纪念品店老板 巴塞罗那机场把叫住我们的爷爷奶奶 领着我们走到地铁站的伏林航空的空姐 去往圣家堂小路上因为给窗台上的猫猫打了招呼，抱起了第二只猫猫向我们挥手的叔叔 酷酷又温柔的音乐人房东的香香的洗衣液 热情良善家庭美满的司机师傅 我想记住这些 宇宙温暖，人间也值得 2022_8_22千山茶客的女将星好好看！ 又哭又笑的看了一整个通宵 肖钰：“凉州城外，有一处峰台，名曰乘风。这些女子生前身不由己，笼鸟池鱼。葬在此处，愿她们来生自由乘风，啸傲湖山吧。” 宴宴：”手中执剑之人，更应该明白剑锋所指何处，是对着身前的人，还是身后的弱者。 我绝不向弱者拔剑。 手中执剑之人，更应该明白剑锋所指何处，是对着身前的敌人，还是身后的弱者。”故在生死间救下女俘虏，提着剑挡在她们面前。“……你若让那些女子也如我一般，见过凉州卫的雪，见过济阳城的水，见过大漠长月，见过江海山川，你说，她们还会不会甘心困在争风吃醋的宅院，还会不会沾沾自喜，麻木愚昧？……因为他们也知道，一旦女子们有了‘选择’的机会，是决计不肯成为后宅里一位伸手等着夫君喂养的花瓶的。那些优秀的女子，会成为将领，成为侠客，成为文士，成为幕僚，与他们争夺天下间的风采，而他们，未必能赢。” 如同背着大刀跨过洗墨江，劈开黑暗的周翡 我真的永远喜欢和敬佩这些女孩，也愿意相信贤昌馆少年郎们真的存在过。 2022_8_27微博看到的句子 “为什么开学要庆祝” “庆祝有学上，有书读，有知识，有成长，有前途，有未来” 突然也就没有那么怕了 2022_8_29救命好久好久好久没有这么撑过了","link":"/2022/02/01/%E7%BB%86%E7%A2%8E%E8%80%8C%E7%BE%8E%E5%A5%BD/"}],"tags":[{"name":"循环不变量","slug":"循环不变量","link":"/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"},{"name":"图灵机","slug":"图灵机","link":"/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"},{"name":"SAT","slug":"SAT","link":"/tags/SAT/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"全排列","slug":"全排列","link":"/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"实验汇总","slug":"实验汇总","link":"/tags/%E5%AE%9E%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"name":"指针与引用","slug":"指针与引用","link":"/tags/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"},{"name":"BBC_6mintues","slug":"BBC-6mintues","link":"/tags/BBC-6mintues/"},{"name":"DNN","slug":"DNN","link":"/tags/DNN/"},{"name":"haskell","slug":"haskell","link":"/tags/haskell/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"模型融合","slug":"模型融合","link":"/tags/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"},{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"SOFTSKILLS","slug":"SOFTSKILLS","link":"/tags/SOFTSKILLS/"},{"name":"SysML","slug":"SysML","link":"/tags/SysML/"},{"name":"Paris","slug":"Paris","link":"/tags/Paris/"},{"name":"算法基础","slug":"算法基础","link":"/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"生活区","slug":"生活区","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/"},{"name":"NANTE_EI2|1","slug":"NANTE-EI2-1","link":"/categories/NANTE-EI2-1/"},{"name":"杂谈","slug":"生活区/杂谈","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/%E6%9D%82%E8%B0%88/"},{"name":"SWJTU","slug":"SWJTU","link":"/categories/SWJTU/"},{"name":"ALGOA","slug":"NANTE-EI2-1/ALGOA","link":"/categories/NANTE-EI2-1/ALGOA/"},{"name":"ALGORITHM","slug":"SWJTU/ALGORITHM","link":"/categories/SWJTU/ALGORITHM/"},{"name":"NANTE_第一年","slug":"NANTE-第一年","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/"},{"name":"ANG","slug":"NANTE-第一年/ANG","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ANG/"},{"name":"ALGORITHM","slug":"NANTE-第一年/ALGORITHM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ALGORITHM/"},{"name":"CCUBE","slug":"NANTE-第一年/CCUBE","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/CCUBE/"},{"name":"学习区","slug":"学习区","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/"},{"name":"INDUR","slug":"NANTE-EI2-1/INDUR","link":"/categories/NANTE-EI2-1/INDUR/"},{"name":"MATHS","slug":"NANTE-第一年/MATHS","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/MATHS/"},{"name":"PYTHON","slug":"NANTE-EI2-1/PYTHON","link":"/categories/NANTE-EI2-1/PYTHON/"},{"name":"PFONC","slug":"NANTE-EI2-1/PFONC","link":"/categories/NANTE-EI2-1/PFONC/"},{"name":"PRO20","slug":"NANTE-第一年/PRO20","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/PRO20/"},{"name":"SSTEM","slug":"NANTE-第一年/SSTEM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/SSTEM/"},{"name":"Voyage","slug":"生活区/Voyage","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/Voyage/"},{"name":"暑假的乱七八糟","slug":"学习区/暑假的乱七八糟","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/%E6%9A%91%E5%81%87%E7%9A%84%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"个人详细介绍","link":"/about/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"}]}