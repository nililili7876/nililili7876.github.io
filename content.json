{"posts":[{"title":"ALGOA_CM1&amp;2","text":"ALGOA_CM1&amp;2 Algorithmique avancée_CM1&amp;2 Introduction Pourquoi étudier l’algorithmique ? Résoudre plus facilement les problèmes (Problem solving) ; Ne pas réinventer[再次创作] la roue ; Produire des programmes : corrects, efficaces, et lisibles（可读性）. Pourquoi faire des programmes efficaces ? Pour optimiser l’utilisation des ressources : temps de calcul, mémoire, énergie. 下面是一个提高算法效率的例子（斐波那契） 123456789101112def fib1 (n): if n == 0 or n == 1: return 1 else : return fib1 (n=1) + fib1(n=2)def fib2 (n): x = 1 y = 1 for i = 2 to n: y = x + y#后两个数相加得第三个数 x = y - x#舍弃第一个数 return y Objectifs du cours • Prouver la correction de programmes ; • Analyser leur performance ; • Connaître et savoir utiliser les principales stratégies génériques de résolution de problèmes (algorithmiques) ; • Connaître et savoir utiliser les principaux types abstraits（抽象的） ; • Comprendre le fonctionnement de leurs principales implémentations（实施方法） et leurs limites. Analyse d’algorithmes Prouver des propriétés Propriétés des algorithmes (et programmes)： Propriétés non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] Performances Prouver des propriétés： exhaustif:全面，formelles:正式的 Invariants de boucles：循环不变量 Pour prouver ce type de propriétés[什么属性？] : ​ • Invariants de boucles : ​ • Propriétés inductives[归纳的，电感的，感应的] ; ​ • À prouver par induction[归纳] sur les itérations. ​ • Contrats de type assume-guarantee : ​ • Sous réserve de la précondition[前提条件] X, la postcondition[后置条件] Y est vraie ​ • Version informelle des triplets de Hoare dans la logique du même nom. 源于网上的一些解释 在计算机科学中，循环不变量，是一组在循环体内、每次迭代均保持为真的某种性质，通常被用来证明程序或算法的正确性。 我们使用循环不变量帮助我们理解一个算法为什么是对的。对于一个给定的循环不变量，我们必须遵循以下三个属性： 初始化：在循环的第一次迭代之前，循环不变量为真。 保持：如果在循环的一次迭代之前循环不变量为真，那么在下一次迭代之前循环不变量同样为真。 终止：当循环结束时，不变量能够提供我们有用的属性，用于帮助我们证实算法是正确的。 当保证前两个属性时，循环不变量在循环的任意迭代之前都满足。注意它与数学归纳法的相似性，当你想证明一个属性存在时，你需要证明一个基准和一个归纳步。相应的，我们第一次迭代之前保证不变量成立对应于一个基准，我们在每次迭代之间保证不变量成立对应于一个归纳步。 因为我们用循环不变量证明算法正确性，所以第三个属性或许是最重要的。通常，我们必须保证在循环结束时“循环不变量”和“循环终止条件”同时成立。 这与数学归纳法有所不同。数学归纳法常采用无限的归纳步，而循环不变量的归纳往往随着循环的终止而结束。 EXEMPLE 对于插入算法的12到14行，有如下分析 après la nen^ene itération, on a 0 ≤ j &lt; x vrai pour n = 0, par la ligne 11 et l’hypothèse x ≥ 1 si vrai pour n ≥ 0, alors : • soit j = 0 (ou A[x] ≤ A[j]), la boucle s’arrête et pas d’itération n + 1 ; • soit j &gt; 0 (et A[j] &lt; A[x]) et après la ligne 14, au début de l’itération n + 1, on a bien 0 ≤ j &lt; x. EXERCICE 1.插入排序 123456789101112def sort (A, n): for i = 1 to n = 1: insert(i , A) def insert (x , A): key = A[x] j = x - 1#j从后往前遍历 while j &gt; 0 and A[j] &gt; key:#比key大的都往后移 A[j + 1] = A[j] j = j - 1 A[j] = key#放入key 1.quel invariant pour la boucle dans sort ? --回答第n次迭代会发生什么事情，从功能上和参数变化上来考虑 Après kek^eke iteration, les k+1 premieres cases de A sont par ordre croissant. 2.quelles préconditions et postconditions pour insert ? Après kek^eke appel de insert: ​ préconditions: les k permiers triés ​ postconditions: les k+1 permiers triés 3.quel invariant pour le while d’insert ? après la mem^eme itération du while: j=x−1−mj = x -1 - mj=x−1−m les m éléments d’indice plus grand que j sont &gt; key soit A[j] &gt; key, soit (A[j] &lt;= key et pour tout i&lt;=j, A[i]&lt;=key) soit A’ la valeur de A au début de itération ​ si $ i &gt; j , A[i+1] = A’[i]$ ​ si i&lt;=j,A[i]=A′[i]i &lt;=j, A[i] = A'[i]i&lt;=j,A[i]=A′[i] 2.Algorithme d’Euclide#相减求最大公约数 12345678# pour a et b strictement positifsdef euclid (a , b): while a != b: if a &gt; b: a = a - b else : b = b - a return a On note ai la valeur de a à la n de l’itération i (donc a0 est la valeur initiale) et on définit bi de façon similaire. Quel invariant de la boucle while pour la correction de l’algorithme?–从功能上解释：Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] ​ après iei^eie itération: pgcd(ai,bi)=pgcd(a,b)pgcd(a_i,b_i) = pgcd(a,b)pgcd(ai​,bi​)=pgcd(a,b) Quel invariant de la boucle while pour la terminaison ? --从参数上解释：non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. ​ 0&lt;ai&lt;ai−10&lt;a_i&lt;a_{i-1}0&lt;ai​&lt;ai−1​ ou 0&lt;bi&lt;bi−10&lt;b_i&lt;b_{i-1}0&lt;bi​&lt;bi−1​ Conclure quand à la terminaison et la correction de l’algorithme en utilisant les deux invariants. Invariants pour les programmes récursifs EXEMPLE: 123456# Pour i &lt; n = len(A)def maximum(i, A): if i == len(A) - 1: return A[i] else : return max(A[i], maximum(i + 1, A)) EXERCICE: 123456789# pour a et b strictement positifsdef euclid (a , b): if a == b: return a else : if a &gt; b: return euclid (a - b, b) else : return euclid (a , b - a) Invariants et problèmes insolubles On peut aussi utiliser les invariants pour démontrer qu’un problème n’a pas de solution ; L’invariant est satisfait[满足] par les itérations de tout hypothétique algorithme ; Il n’est pas satisfait par la configuration finale recherchée. EXERCICE: 第一个是奇数不行–&gt;每次循环增加的一个多米洛是2 第二个是缺同色的不行–&gt;每次循环增加的是一黑一白，但棋盘缺了两白色 Preuve automatique et indécidabilité[不可决定性] Peut-on écrire un programme qui prend un programme quelconque[任何] en entrée et décide s’il a une propriété donnée ? 比如说，我们Écrire un programme qui décide si un programme quelconque s’arrête (sur une entrée donnée). • Supposons qu’un tel programme existe : on l’appelle H ; • Pour un programme P et une entrée i donnés, H(P, i) vaut vrai si P s’arrête pour l’entrée i et faux sinon • Soit le programme H‘ , qui prend en entrée un programme P dont l’entrée est un programme, et défini par : 1234if H(P,P): while True: passelse: print(&quot;coin !&quot;) Que se passe-t-il pour l’exécution de H’ pour le programme H’? H’ est bien un programme qui prend un programme en entrée • Si l’exécution se termine alors H(H’, H’) est vrai… et on devrait aller dans le while qui ne s’arrête jamais ; • Si l’exécution ne se termine pas, alors H(H’, H’) est faux… et on devrait s’arrêter en affichant “coin !”. –&gt;Donc le programme H‘ ne peut pas exister ! Indécidable Un problème algorithmique dont la réponse est vrai ou faux est appelé problème de décision ; Un problème de décision pour lequel il n’existe pas d’algorithme qui le résout est dit indécidable ; Le Théorème de Rice dit (informellement) que toute propriété non-triviale[琐碎，平凡] sur les programmes est indécidable. 下面是3个Indécidable的例子 le 10e problème de Hilbert 不定方程又称丢番图方程[ Une équation diophantienne]的可解性 Problème de correspondance de Post (PCP) Machines à deux compteurs Complexité 定义 La complexité d’un problème est celle du meilleur algorithme[最佳算法] qui le résoud ; Deux mesures principales : 1 temps de calcul ; 2 mémoire maximale utilisée. Ces mesures dépendent de l’instance du problème considéré : 1.on mesure en fonction de la taille de l’entrée ; 2. meilleur cas ou pire cas ; 3.cas moyen (espérance) ; Elles dépendent aussi du modèle de calcul considéré : Informatique théorique : machines de Turing. Par exemple le problème de décision du voyageur de commerce est NP-complet Analyse pratique : modèle RAM. Par exemple le tri fusion opère[归并排序] en O(nlog2n)O(nlog_2n)O(nlog2​n) Machines de Turing EXEMPLE 负数的补码计算：取反+1 EXERCICE Écrire une machine de Turing sur l’alphabet {a, b} qui décide si un mot est un palindrome. Par exemple abba ou ababa sont acceptés mais abbaa est rejeté. 本质思想还是第一个和最后一个比。 Complexité d’une machine de Turing -Les machines de Turing sont le modèle le plus simple d’algorithme -Un seul type d’instruction, un seul type de données (symbole) 单一指令单一数据类型 -La taille de l’entrée est le nombre de cases initialement non vides -Les notions de complexité sont simples et naturelles : Complexité temporelle : nombre d’instructions réalisées avant arrêt[执行的指令数] Complexité spatiale : nombre maximal de cases non vides simultanément[同时最大数量的非空方格] SAT quelques classes de complexité des problèmes de décision PTIME: temps polynomial --&gt; O(nk)O(n^k)O(nk) ​ existence d’une solution dans un programme linéaire PSPACE: espace polynomial ​ décider si on peut passer d’un conguration à une autre dans Rush Hour ou Sokoban[独木桥] EXPTIME: temps exponentiel --&gt; O(2n)O(2^n)O(2n) ​ déterminer si le 1er joueur gagne pour une position de Go[围棋] (en fonction de la taille du plateau) EXPSPACE: espace exponentiel ​ déterminer si 2 expression régulières (simples) ont le même langage (a∗b∗+c)∗=(a+b+c)∗(a^*b^*+c)^* = (a+b+c)^*(a∗b∗+c)∗=(a+b+c)∗ PTIME⊂PAPACE⊂EXPTIEM⊂EXPSPACEPTIME⫋EXPTIEMPTIME\\subset PAPACE \\subset EXPTIEM \\subset EXPSPACE\\\\ PTIME\\subsetneqq EXPTIEM PTIME⊂PAPACE⊂EXPTIEM⊂EXPSPACEPTIME⫋EXPTIEM Le problème SAT 布尔可满足性问题: 确定是否存在满足给定布尔公式的解释的问题。 -Entrée: une formule booléenne avec des variables propositionnelles. -Sortie: existe-t-il une valeur des variables telle que la formule est vraie ? EXEMPLE：8皇后问题的SAT表示 Le problème des huit reines : Placer huit reines sur un échiquier telles qu’elles ne soient pas en prise. Comment résoudre ce problème avec le problème SAT ? X11∨X12∨...∨X18∧X21∨X22∨...∨X28∧...∧X11=¬X22∧¬X33∧...∧¬X88∧...X_{11} \\vee X_{12} \\vee ... \\vee X_{18}\\\\\\land\\\\X_{21} \\vee X_{22} \\vee ... \\vee X_{28}\\\\\\land\\\\...\\\\\\land\\\\ X_{11} = \\neg X_{22} \\land \\neg X_{33} \\land ... \\land\\neg X_{88}\\\\\\land\\\\... X11​∨X12​∨...∨X18​∧X21​∨X22​∨...∨X28​∧...∧X11​=¬X22​∧¬X33​∧...∧¬X88​∧... Complexité de SAT -问题是时间复杂度是EXPTIME: temps exponentiel --&gt; O(2n)O(2^n)O(2n) -On peut encoder une partie d’échecs ou de go avec SAT ⇒ mais avec une formule de taille exponentielle ! -Si on donne une valeur des variables, il est facile de vérifier que c’est une solution ou non -De nombreux problèmes utiles ont cette propriété : existence d’un cycle hamiltonien dans un graphe orienté ; #有向图的哈密顿回路[一笔画] coloration de graphes[着色] problème du sac-à-dos (Knapsack) [背包问题]; problème des cartons (Bin packing) [装箱问题]; programmation linéaire en nombre entiers (ILP)[整数线性规划]. -Pour les étudier : abstraire la recherche de la solution[将问题答案01编码] Permettre à la machine de deviner[猜想，尝试] une solution avant de la vérifier ; Permettre à la machine de se dupliquer[赋值] et vérifier plusieurs candidats en même temps → Machine non-déterministe Machines de Turing non-déterministes 就是读到的东西一样可能导致不同的操作 Dans ce cas, la machine se duplique[自我复制] et chaque copie exécute l’une des possibilités. La machine accepte si l’une des copies atteint l’état accept, mais la machine rejette si toutes les copies atteigent l’état reject. EXEMPLE Écrire une machine de Turing non-déterministe qui étant donnée une séquence de 0, 1 et x décide s’il existe une valeur de x ∈ {0, 1} telle que la séquence est un palindrome sur {0, 1}. NP La classe de complexité NP -Une machine non-déterministe résout SAT en temps polynomial：[PTIME: O(nk)O(n^k)O(nk)] -NPTIME (ou NP) : les problèmes qu’on peut résoudre en temps polynomial . ​ ex. SAT, knapsack, ILP, etc. -Mais aussi NPSPACE, NEXPTIME, NEXPSPACE, etc. Le Théorème de Savitch implique que PSPACE = NPSPACE et EXPSPACE = NEXPSPACE. P⊆NP⊆PSPACEP ⊆ NP ⊆ PSPACE P⊆NP⊆PSPACE Une question ouverte importante est P=NP? Bornes inférieures et complétude -Soit un problème P tel que : on peut transformer toute instance d’un problème quelconque de la classe de complexité C en une instance de P la transformation n’est pas trop coûteuse[昂贵] (typiquement polynomiale, ou logarithmique pour PTIME) -P est C-dificile ; -Si de plus P ∈ C alors P est C-complet ; -Les problèmes C-complets sont les plus dificiles de la classe C ; -Le Théorème de Cook-Levin dit que SAT est NP-dificile (et donc NP-complet). EXERCICE Le problème de décision ILP est : étant donnée une intersection de demi-espaces, contient-elle un point entier ? Montrer que ILP est NP-dificile. 证明所有的SAT问题都能转换成ILP问题。 任何SAT:X1∧ ¬X2∧¬X3转化为ILP:0&lt;=X1&lt;=1,0&lt;=X2&lt;=1,0&lt;=X3&lt;=1X1+(1−X2)+(1−X3)&gt;=3任何SAT: X_1 \\land \\ \\neg X_2 \\land \\neg X_3\\\\ 转化为ILP:0 &lt;= X1 &lt;= 1, 0&lt;= X2 &lt;= 1 , 0 &lt;= X3 &lt;= 1\\\\ X_1+(1-X_2)+(1-X_3)&gt;=3 任何SAT:X1​∧ ¬X2​∧¬X3​转化为ILP:0&lt;=X1&lt;=1,0&lt;=X2&lt;=1,0&lt;=X3&lt;=1X1​+(1−X2​)+(1−X3​)&gt;=3 RAM Les opérations arithmétiques ont une complexité polynomiale pour une machine de Turing Idem pour l’accès à une case particulière de la mémoire Pour l’analyse pratique des algorithmes, on considère un modèle plus réaliste : opérations arithmétiques simples, indexage [索引] (Random access memory), etc. en temps constant#简单的算术运算、索引（随机存取存储器）等，在恒定的时间内进行。 accès direct à des variables (registres) #直接访问变量[寄存器] contrôle du ot d’exécution (branchements) types de données classiques à précision innie (en général) #精度不高 On peut adapter le modèle en fonction de ce qu’on cherche à mesurer.","link":"/2022/09/06/ALGOA_CM1&2/"},{"title":"ACWing","text":"ACWing 跟着Y佬学算法 6_22: hello word 题目 算法 把对应矩阵的对应行加过去 注意getchar()的问题 6_27: 行程表排序 题目 未AC(超时) 数据结构：结构体+vector； ​ 结构体是两个string和一个flag用来标记有没有排序 算法描述：蛮暴力的，当排序做的，每次遍历把头和尾加上 时间复杂度: O(T∗n3)O(T*n^3)O(T∗n3), 属实有点子高了 正解 视频 救命，说这个题非常简单T^T 用图论去解的 数据结构：用两个哈希表存储后继和前驱 算法：1.找起点：起点入度为0；2.通过next数组找剩下所有点 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;int main(){ int T; cin&gt;&gt;T; for(int cases = 1; cases &lt;= T; cases++) { int n; cin&gt;&gt;n; unordered_map&lt;string,string&gt; next;//搜索关键字K是出发地 unordered_set&lt;string&gt; S;//存目的地 while(n--) { string a,b; cin&gt;&gt;a&gt;&gt;b; next[a] = b; S.insert(b); } //找头结点 string head; for(auto&amp; [a,b]:next)//这写法属实第一次见了 { if(!S.count(a))//统计a出现的次数 { head = a; break; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cases&lt;&lt;&quot;: &quot;; while(next[head].size()) { cout&lt;&lt;head&lt;&lt;&quot;-&quot;&lt;&lt;next[head]&lt;&lt;&quot; &quot;; head = next[head];//wow } cout&lt;&lt;endl; } return 0;} 大一数据结构回顾 图 存储结构：邻接矩阵，邻接表(头结点+表结点)，有向图的十字链表（多了入度的表），无向图的邻接多重表(类十字链表) 哈希表 由关键字K检索数据元素(对象)时，数据元素(对象)的存储地址可以由函数H(K)直接计算得到，这样可 以大大加快查找速度。若查找表中的所有数据元素均 存储到函数H(K)指定的地址，称为哈希(Hash)表。时间复杂度为O(1) #include&lt;unordered_map&gt; 概念：unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。key值应该是唯一的，key和value的数据类型可以不相同。unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。可以使用[]操作符来访问key值对应的value值。 常见操作： 12345678910111213//定义unordered_map&lt;string, int&gt; umap; //表示&lt;K,T&gt;，调用是.first和.secondumap.insert(Map::value_type(&quot;test&quot;, 1));////增auto n = umap.erase(&quot;test&quot;) //删auto it = umap.find(key) //改 if(it != umap.end()) it-&gt;second = new_value; umap.find(x) != map.end()//查for(auto x:unomap)//遍历{ cout&lt;&lt;x.first&lt;&lt;x.second&lt;&lt;endl;} #include&lt;unordered_set&gt; Y佬 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;//模板typedef pair&lt;string, string&gt; PSS;const int N = 10010;int n;PSS P[N];int R[N];//记录排序结果int main(){ int T; scanf(&quot;%d&quot;, &amp;T); for (int i = 1; i &lt;= T; i ++ ) { scanf(&quot;%d&quot;, &amp;n); unordered_map&lt;string, int&gt; S,D;//存起点终点以及他们对应的位置 for (int i = 0; i &lt; n; i ++ ) { cin &gt;&gt; P[i].first; cin &gt;&gt; P[i].second; S[P[i].first] = i; D[P[i].second] = i; } // find the begin for (int i = 0; i &lt; n; i ++ ) { if (D.find(P[i].first) == D.end())//在终点里面没有找到起点说明是头 { R[0] = i; break; } } for (int i = 1; i &lt; n; i ++ ) R[i] = S[P[R[i-1]].second];//找下一机票P的下标--&gt;(起点是上一张机票的终点) printf(&quot;Case #%d: &quot;, i); for (int i = 0; i &lt; n; i ++ ) { cout &lt;&lt; P[R[i]].first &lt;&lt; &quot;-&quot; &lt;&lt; P[R[i]].second &lt;&lt; ' '; } printf(&quot;\\n&quot;); } return 0;} 绕但好厉害T=T 6_28: 放苹果 DFS的题！我会！ 题目 题解 1234567891011121314151617181920void dfs(int step,int res){ if(step == n+1) { if(res == m) count++; return; } for(int i=0;i&lt;=m;i++) { if(i&gt;=r[step-1]) { r[step] = i;res += i; dfs(step+1,res); r[step] = 0;res -= i; } } return;} 不输出重复的规定采用的方法是让结果必须升序 7_18: 正方形数组 本质是去掉重复的全排列 思想：先对输入进行排序（algotithm的sort），设置last变量记录上次该位置的数值，保证（同一节点的）每一层不会出现重复数据 代码 12345678910111213141516171819void dfs(int step){ if(step == n) { if(judgment(result))sum++; return; } int last=-1; for(int i=0;i&lt;n;i++) { if(!book[i] &amp;&amp; input[i] != last) { result[step]=input[i]; book[i] = 1;last = input[i]; dfs(step+1); book[i] = 0; } }} 但是它超时了救命！！！！！！！！！！！！ 解决办法：不要排好了再判断，边加就边判断。 12345678910111213141516171819202122void dfs(int step){ if(step == n) { sum++; return; } int last=-1; for(int i=0;i&lt;n;i++) { if(!book[i] &amp;&amp; input[i] != last) { if(judgment(result[step-1],input[i]) || !step) { result[step]=input[i]; book[i] = 1;last = input[i]; dfs(step+1); book[i] = 0; } } }} 7_19: 伪二叉树 题 题解 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int m,n;int main(){ cin&gt;&gt;m&gt;&gt;n; while (1) { if (m &gt; n) m /= 2; else if (n &gt; m) n /= 2; else break; } cout &lt;&lt; m &lt;&lt; endl; return 0;} 碎碎念 不用真的去构建二叉树然后找所有父节点这样子。 构建二叉树的方法： 1234567891011121314void CreeTree(node* &amp;root,int val){ if(val &gt; max(n,m)) { root = CreeNode(val); } else { root = new node; root-&gt;val = val; CreeTree(root-&gt;gauche,2*root-&gt;val); CreeTree(root-&gt;droite,2*root-&gt;val+1); }} 找父节点的方法：1.用哈希表存储所有节点的父节点，根节点的父节点设为nullptr；2.然后利用节点的父节点信息从target节点开始不断往查找，并将当前结点的值存储到ans中，直到查找到nullptr。 123456789101112131415161718192021222324252627//存储所有节点的父节点unordered_map&lt;int, node*&gt; parents;void dfs(node* root){ if (root-&gt;gauche) { parents[root-&gt;gauche-&gt;val] = root; dfs(root-&gt;gauche); } if (root-&gt;droite) { parents[root-&gt;droite-&gt;val] = root; dfs(root-&gt;droite); }}//查找vector&lt;int&gt; findPath(node* root,node* target){ vector&lt;int&gt;ans; while(target!= nullptr) { ans.push_back(target-&gt;val); target=parents[target-&gt;val]; } reverse(ans.begin(),ans.end()); return ans;} 7_20: 约瑟夫环问题 题 题解 数组实现 123456789101112131415161718192021222324void tableaux(){ int n,m; int a[N]={0}; cin&gt;&gt;n&gt;&gt;m;//n表示总人数,m表示报道第几出局 int sum=0;//用来统计出局的人数 int k=0;//报数 for(int i=1;sum&lt;n;i++)//来遍历所有人 { if(i == n+1) i=1;//绕了一圈 if(!a[i])//表示对没有出局的人的操作 { k++; if(k == m)//出局 { a[i]=1; sum++; cout&lt;&lt;i&lt;&lt;&quot; &quot;; k=0; } } } cout&lt;&lt;endl; }","link":"/2022/11/12/ACWing/"},{"title":"ALGOA_CM6&amp;7","text":"ALGOA_CM6&amp;7 programmation dynamique et algorithmes gloutons Programmation Dynamique 子问题不独立–&gt;最优子结构，自下而上的递归 Exemple: Problème du change. On dispose de pièces (autant qu’on veut) de 1, 3, 4, 10, 30 et 40¤. Pour n donné, quel nombre minimum de chaque pièce faut-il pour obtenir n¤ ? Par exemple, pour n = 25, il faut une 2 × 10 + 1 × 4 + 1 × 1. Pour n = 6, il faut 2 × 3. 状态转移方程： c(n)={1+minp∈L c(n−p), si n &gt;00, si n =0+∞, si n &lt;0c(n) = \\left\\{ \\begin{array}{rcl} 1+min_{p\\in L}\\ c(n-p), \\ si &amp;\\ n\\ &gt; 0 \\\\ 0, \\ si &amp;\\ n\\ = 0 \\\\ +\\infty, \\ si &amp;\\ n\\ &lt; 0 \\end{array} \\right. c(n)=⎩⎪⎨⎪⎧​1+minp∈L​ c(n−p), si0, si+∞, si​ n &gt;0 n =0 n &lt;0​ 代码 123456789101112131415def change(n, L): if n &lt; 0: return (math.inf, []) # inf est un réel... elif n == 0: return (0, []) else: c = math.inf for p in L: (x, R) = change(n - p, L) if x &lt; c: c = x S = R q = p return (1 + c, S + [q]) 看不懂嘤嘤嘤 矩阵连乘 将乘积AiAi+1...AjA_iA_{i+1}...A_jAi​Ai+1​...Aj​简记为A[i:j],其中AiA_iAi​的维度计为pi−1∗pip_{i-1}*p_ipi−1​∗pi​, 目的是求解A[1:n]的最优解，而一个最优策略也应该是最优的，A[i:j]又从中间插个K，然后问题转化为A[i:k]再加上A[k+1:j]的计算量–&gt;建立状态转移方程： i=j时,A[i:j]=Aii=j时, A[i:j]=A_ii=j时,A[i:j]=Ai​,然后 dp[i,j]=0dp[i,j]=0dp[i,j]=0 i&lt;j 时，dp[i,j]=min (dp[i,k]+dp[k+1,j]+pi−1pkpj)dp[i,j] = min\\ (dp[i,k]+dp[k+1,j]+p_{i-1}p_kp_j)dp[i,j]=min (dp[i,k]+dp[k+1,j]+pi−1​pk​pj​) algorithmes gloutons 子问题可以独立也可以不独立，独立的话能得到全局的最优解 定义 Plutôt pour des problèmes d’optimisation ; Comme dans le backtracking, on décompose le problème en deux : 1.Faire un choix 2.Résoudre le sous-problème resultant de choix. À chaque étape on fait le choix qui optimise localement l’objectif ; On construit donc une seule solution. 子问题最优，不一定能得到全局最优 例题 Choix des activités. Étant donnée une liste d’activités caractérisées par une date de début et une date de n, trouver un ensemble maximum d’activités à faire tel qu’il n’y ait aucun chevauchement. 1234567891011def activities (D, F, n): # tri selon F A = sortBy(F, [0..( n=1)])#根据F去排序 resultat = [A[0]]#去选F最小的 date = F[A[0]] for i = 0 to (n=1): if D(A[i]) ≥ date:#如果这个活动的开始日期小于上一个的结束日期就加 date = F(A[i]) resultat = resultat ++ [A[i]] return resultat Un problème d’ordonnancement[调度]. On dispose de n tâches à exécuter. Chaque tâche τi a un temps d’exécution Ci : le temps qu’elle met a s’exécuter en isolation. Le temps de réponse de τi est le temps entre son activation et sa n (incluant les temps d’attente). On suppose qu’une tâche commencée ne peut pas être interrompue (ordonnancement non-préemptif) et que toutes les tâches sont activées à l’instant initial. Donner un algorithme qui ordonnance les tâches en minimisant le temps de réponse moyen 一直选任务时间最小的任务 12def sjf(C, n): return sorted(list(range(0,n)), key=lambda x: C[x]) On suppose maintenant l’ordonnancement préemptif[抢占式] : une tâche peut être interrompue le temps que d’autres s’exécutent. Elle reprend là où elle s’était arrêtée quand elle est choisie à nouveau pour s’exécuter. On suppose également que chaque tâche τi a maintenant une date d’activation di qui peut ne pas être 0. Donner un algorithme qui ordonnance les tâches en minimisant le temps de réponse moyen. 我们现在假设抢占式调度[抢占式]：一个任务可以在其他任务运行时被打断。当它再次被选择运行时，它将继续运行。还假设每个任务τi现在有一个激活日期di，这个日期可能不是0。给出一个算法，通过最小化平均响应时间来安排任务。 12345678910111213141516171819202122232425262728293031#找到有新任务准备好的下一个时刻def next_srtf(D, t, n): m = math.inf for x in D: if x &lt; m and x &gt; t: m = x return mdef srtf(C, D, t, n):#D表示任务的开始时间，C表示任务的持续时间，n是size if t &lt; math.inf: m = math.inf k = -1 for x in range(0, n): if D[x] &lt;= t and C[x] &lt; m: k = x m = C[x] if k == -1: # on a pas trouvé de tâche à ordonnancer, c'est fini return [] else: t2 = next_srtf(D, t, n) #la tâche en cours sera finie avant la prochaine activation if t2 &gt;= t + C[k]: t2 = t + C[k] D[k] = math.inf C[k] = C[k] - (t2 - t) return [k] + srtf(C, D, t2, n) else: return [] Un autre problème d’ordonnancement. On dispose de n tâches de durée 1 activées à l’instant initial. À chaque tâche τi est associée une échéance di et une pénalité pi : la tâche doit avoir été exécutée avant di , sinon il faut payer la pénalité pi Par exemple. Si on exécute les tâches dans l’ordre des indices on obtient que τ5 et τ7 sont en retard et la pénalité totale est donc 50 + 70 = 120. Modéliser sous la forme d’un matroïde le problème d’obtenir un algorithme calculant un ordonnancement minimisant la pénalité totale.","link":"/2022/11/12/ALGOA_CM6&7/"},{"title":"ALGOA_CM3","text":"ALGOA_CM3 Complexité asymptotique et Algorithmes probabilistes Complexité asymptotique 对O，Ω，Θ等的一些理解 EXEMPLE 求解插入排序在最坏情况下的时间复杂度 EXERCICE 求解下面两个算法的时间复杂度 On veut évaluer en un point x un polynôme de degré n en donné par la liste A de ses coefficients. On considère deux approches : 12345678910111213def naive(A,x,n): s = [0] for i = 1 to n: p = A[i] for j = 1 to i: p = p*x s = s+p return sdef horner(A,x,n): s = 0 for i = n downto 0: s = s*x + A[i] return s Calculer proprement la complexité des deux approches. naive:1+2∗n+∑1n∑1i1=1+2n+∑1ni=1+2n+n(n−1)/2=Θ(n2)1+2*n+\\sum^n_1\\sum^i_1 1 = 1 + 2n + \\sum^n_1 i = 1 + 2n + n(n-1)/2 = Θ(n^2)1+2∗n+∑1n​∑1i​1=1+2n+∑1n​i=1+2n+n(n−1)/2=Θ(n2) horner: 1+n=Θ(n)1+n=Θ(n)1+n=Θ(n) Quelle est la complexité du tri par insertion en fonction du nombre d’inversions I (le nombre de couples (i, j) tels que i &lt; j et A[i] &gt; A[j]) et de n ? 移动的次数就是等于翻转对的个数：移动一次就少一个翻转对，直到排序完成 然后需要加上定位到所有位置的一个遍历的复杂度n O(n+l) Complexité pire cas des algorithmes récursifs -On peut les résoudre parfois directement : récurrences linéaires à coefficients constants ; deviner une expression et la prouver[归纳法归纳法] ; Théorèmes dédiés : Master Theorem (voir divide and conquer), récurrences d’Akra-Bazzi. 不能直接解决的那种证明可以用归纳法！ EXEMPLE 阶乘 12345def fact(n): if n == 0: return 1 eles: return n * fact(n-1) T(n)=T(n−1)+1T(0)=1−−&gt;T(n)=n+1=Θ(n)T(n) = T(n-1)+1 \\quad T(0)=1 --&gt; T(n)=n+1=Θ(n)T(n)=T(n−1)+1T(0)=1−−&gt;T(n)=n+1=Θ(n) fib: 12345def fib(n): if n == 0 or n == 1: return 1 else: return fib(n-1)+fib(n-2) T(n+2)=T(n+1)+T(n)+1&gt;=T(n+1)+T(n)etT(0)=1,T(1)=2T(n+2) = T(n+1) + T(n) +1 &gt;= T(n+1) +T(n) \\quad et \\quad T(0)=1,T(1)=2T(n+2)=T(n+1)+T(n)+1&gt;=T(n+1)+T(n)etT(0)=1,T(1)=2 x2−x−1&gt;=0x^2-x-1 &gt;= 0x2−x−1&gt;=0 是因为偏微分方程 EXERCICE Montrer que la complexité de fib est O(2n)O(2^n)O(2n) 归纳法归纳法 假设∃C、N，tq∀n&gt;Nf(n)&lt;=c∗2n现在证n+1:f(n+1)=f(n)+f(n−1)+1&lt;=c12n+c22n−1+1&lt;=max(c1,c2)2n&lt;=max(c1,c2)2n+1假设\\quad{\\exists} C、N，tq\\quad{\\forall}n&gt;N\\quad f(n)&lt;=c*2^n\\\\ 现在证n+1: f(n+1)=f(n)+f(n-1)+1&lt;=c_12^n+c_22^{n-1}+1&lt;=max(c_1,c_2)2^n&lt;=max(c_1,c_2)2^{n+1} 假设∃C、N，tq∀n&gt;Nf(n)&lt;=c∗2n现在证n+1:f(n+1)=f(n)+f(n−1)+1&lt;=c1​2n+c2​2n−1+1&lt;=max(c1​,c2​)2n&lt;=max(c1​,c2​)2n+1 Complexité moyenne -Pour calculer la complexité moyenne, il faut une distribution de probabilité[概率分布] sur les données d’entrée -On calcule, l’espérance de la complexité selon cette distribution.[期望] EXEMPLE:引例 1234567# on suppose n&gt;0def maximum(A,n): r = A[1] for i = 2 to n-1: if A[i] &gt; r : r = A[i] return r Combien de fois le if est-il pris[prendre] ? -Au pire cas, la liste est triée dans l’ordre ascendant, et le if est pris à chaque fois (n − 1 fois) Mais en moyenne ? –但是感觉这里讨论应该是if下面那条交换语句，就不管怎样if都得执行n-1 fois variables aléatoires indicatrices: 随机指标变量 -Soit XiX_iXi​ la variable aléatoire indicatrice de l’événement EiE_iEi​ = le if est pris à l’itération i XiX_iXi​是随机变量,EiE_iEi​表示if在第i次迭代被prendre的事件 -Le nombre total de prises est : X=∑i=2n−1XiX=\\sum^{n-1}_{i=2}X_iX=∑i=2n−1​Xi​ -L’espérance de X est donc (linéarité de l’espérance) : $E(X) = \\sum^{n-1}_{i=2}E(X_i) $ -Par construction, E(Xi)E(X_i)E(Xi​) est la probabilité que que l’événement soit vrai : E(Xi)=P(Ei)Xi(Ei)+P(¬Ei)Xi(¬Ei)=P(Ei)×1+P(¬Ei)×0=P(Ei)E(X_i) = P(E_i)Xi(E_i) + P(¬Ei)Xi(¬Ei) = P(Ei ) × 1 + P(¬Ei ) × 0 = P(Ei )E(Xi​)=P(Ei​)Xi(Ei​)+P(¬Ei)Xi(¬Ei)=P(Ei)×1+P(¬Ei)×0=P(Ei) Donc : E(X)=∑i=2n−1P(Ei)E(X) = \\sum^{n-1}_{i=2}P(Ei)E(X)=∑i=2n−1​P(Ei) Reste à calculer P(Ei)P(E_i)P(Ei​). 有了这些概念再回去看刚刚那个exemple： -Sans information supplémentaire[进一步的], on suppose que chaque permutation des éléments de A est équiprobable[等效的]. -Pour simplifier, on suppose les éléments de A tous distincts[不同的]; -Comme tous les ordres pour A sont équiprobables : 随时牢记：EiE_iEi​ 表示执行第i次迭代的概率 il y a autant de séquences avec A[1] &gt; A[0] qu’avec A[1] ≤ A[0] donc P(E2)=12P(E_2)=\\frac12P(E2​)=21​ on peut découper[切出] les séquences possibles en trois groupes de même taille : dans les 3 premiers chiffres, le 1er est le plus grand : E3E_3E3​est faux 2 dans les 3 premiers chiffres, le 2e est le plus grand : E3E_3E3​est faux 3 dans les 3 premiers chiffres, le 3e est le plus grand : E3E_3E3​ est vrai donc P(E3)=13P(E_3)=\\frac 13P(E3​)=31​ plus généralement, P(Ei)=1iP(E_i)=\\frac 1iP(Ei​)=i1​ -Et finalement E(X)=∑i=2n−11iE(X) = \\sum^{n-1}_{i=2}\\frac 1iE(X)=∑i=2n−1​i1​ et donc : E(X)=lnn+O(1)E(X) = lnn+O(1)E(X)=lnn+O(1)[牛顿欧拉啥的近似] Exercices On réalise une permutation aléatoire uniforme de la la liste [1, 2, . . . , n] ? Quel est l’espérance du nombre de points fixes ? (le nombre d’éléments qui sont toujours à la même place). E(X)=∑inP(Ei)=∑in1n=1E(X)=\\sum_i^nP(E_i)=\\sum_i^n\\frac1n=1 E(X)=i∑n​P(Ei​)=i∑n​n1​=1 On a vu que le nombre d’échanges faits par le tri par insertion est égal au nombre d’inversions dans le tableau A : le nombre de couples (i, j) tels que i &lt; j et A[i] &gt; A[j]. Quel est l’espérance du nombre d’inversions si on suppose le tableau A est une permutation aléatoire uniforme de l’ensemble [1, 2, . . . , n] ? E(X)=∑i≠jnP(Eij)P(Eij)=P(i&lt;j)P(Eij∣i&lt;j)E(X)=\\sum_{i\\neq j}^nP(E_{ij})\\quad P(E_{ij})=P(i&lt;j)P(E_{ij}|i&lt;j) E(X)=i=j∑n​P(Eij​)P(Eij​)=P(i&lt;j)P(Eij​∣i&lt;j) Écrire un algorithme pour trouver un élément dans une liste de longueur n non triée ; Quelles sont les complexités au meilleur cas, au pire cas et en moyenne de cette algorithme ? (Pour la moyenne, on suppose x borné par une valeur N ≥ n) 算法[老师写的真的超级厉害！] 123456789def find(x,A): lens = len(A) find = false i = 0 while i &lt; lens and not find: if x == A[i]: find = true i++ return find meilleur cas:1; pire cas: n en moyenne: EiE_iEi​ 表示执行第i次迭代的概率–&gt;1.x n’est pas dans la liste; 2.il y a l’indice i ou après. P(Ei)=P(Ei∣x dans la liste)P(x dans la liste)+P(Ei∣x n′est pasdans la liste)P(x n′est pasdans la liste)=n−in∗nN+1∗(1−nN)P(A)=P(A∣B)P(B)+P(A∣¬B)∗P(¬B)P(E_i)=P(E_i|x\\ dans\\ la\\ liste)P(x\\ dans\\ la\\ liste) + P(E_i|x\\ n'est\\ pas dans\\ la\\ liste)P(x\\ n'est\\ pas dans\\ la\\ liste)\\\\=\\frac{n-i}n*\\frac nN+1*(1-\\frac nN)\\\\P(A)=P(A|B)P(B)+P(A|\\neg B)*P(\\neg B)P(Ei​)=P(Ei​∣x dans la liste)P(x dans la liste)+P(Ei​∣x n′est pasdans la liste)P(x n′est pasdans la liste)=nn−i​∗Nn​+1∗(1−Nn​)P(A)=P(A∣B)P(B)+P(A∣¬B)∗P(¬B) ​ E(X)=∑i=1nP(Ei)=∑i=1n(1−iN)=(n−1)(1−n2N)E(X) = \\sum^{n}_{i=1}P(Ei)=\\sum_{i=1}^n(1-\\frac iN)=(n-1)(1-\\frac n{2N})E(X)=∑i=1n​P(Ei)=∑i=1n​(1−Ni​)=(n−1)(1−2Nn​) Algorithmes probabilistes: 概率算法 -Pour la complexité, le cas moyen est souvent plus favorable que le pire cas, pour ne pas tomber systématiquement sur des cas défavorables, on peut mélanger aléatoirement les données[为了避免系统地找到不利的案例，可以将数据随机地混合起来] -Un algorithme probabiliste est un algorithme qui utilise des instructions random ou similaires qui fournsissent leur résultat en suivant une certaine distribution de probabilité ; -L’exécution d’un algorithme probabiliste est caractérisée par son temps d’exécution attendu[预期执行时间] -La complexité attendue au pire cas est l’espérance de la complexité quand on résoud les choix non-probabilistes de la façon la plus défavorable ; -L’espérance du nombre de fois où le if est pris au pire cas dans maximum_alea est O(ln n) quelles que soient les données d’entrée même si elles sont fournies par une entité adverse EXEMPLES Monte-Carlo Les algorithmes de décision de type Monte-Carlo fournissent toujours une réponse mais peuvent se tromper[可能是错误的] 123456def fermat_prime(x,n): for k = 1 to n: x = random_int(2,n-2) if x^(n-1) != 1 (mod n):#1 mod n永远等于0 return false#所以在说x取到0返回flase？ return true#永远vari Pour les problèmes d’optimisation, ils donnent une réponse approchée (typiquement avec une garantie probabiliste[概率保证]) 12345678def eval\\_pi(n):# estimer la valeur de π r = 0 for k = 1 to n: x = random(0,1) y = random(0,1) if x^2+y^2 &lt;= 1:#x,y在圆[(0,0),1]里面 r = r + 1 return 4*r/n #？？？？？？ Las Vegas Les algorithmes de type Las Vegas peuvent échouer à trouver une solution.[可能无法找到解决方案] Mais s’ils en renvoient une elle est correcte. L’espérance de leur temps d’exécution est finie 1234567891011def random_queen(L,i,n): if i == n: return L else: M=[] for j=1 to n-1: if not aligned(L,i,j): M = M ++ [j] j = random_int(0,len(M)-1)#就是说把所有可以的j全加进去然后随机选，不太对怎么觉得len(M)这里 random_queen(L++[(i,j)],i+1,n) return DO_NOT_KNOW EXERCICES 1.On dispose d’une fonction biased_random() qui renvoit 1 avec une certaine probabilité p inconnue. Écrire un algorithme qui renvoit 1 avec probabilité 0.5 et 0 avec probabilité 0.5. 12345while true: x = biase_random() y = biase_random() if x != y : return x 假设P(x=0 et y=1)=r=P(x=1 et y=0) P(ret=0)=r+(1−2r)r+(1−2r)2r+..=r∑n=0∞(1−2r)n=r∗11−(1−2r)=0.5P(ret = 0)=r+(1-2r)r+(1-2r)^2r+..=r\\sum_{n=0}^{\\infty}{(1-2r)^n}=r*\\frac1{1-(1-2r)}=0.5P(ret=0)=r+(1−2r)r+(1−2r)2r+..=r∑n=0∞​(1−2r)n=r∗1−(1−2r)1​=0.5 Donner l’espérance de sa complexité temporelle. E(x)=∑E(Xi)=∑i=1nP(Ei)E(x)=\\sum E(X_i)=\\sum^{n}_{i=1}P(Ei)E(x)=∑E(Xi​)=∑i=1n​P(Ei) P(Ei)=(1−2r)iP(E_i)=(1-2r)^iP(Ei​)=(1−2r)i E(x)=∑(1−2r)i=12r=12p(1−p)E(x)=\\sum (1-2r)^i=\\frac1{2r}=\\frac 1{2p(1-p)}E(x)=∑(1−2r)i=2r1​=2p(1−p)1​ 2.On considère la function suivante : 123def permutation_aleatoire(A, n): for i = 0 to n = 1: swap(A[i], A[random_int(i,n=1)]) Une k-permutation de A est une séquence qui contient k éléments de A. Si la taille de A est n alors une n-permutation est une permutation. Démontrer l’invariant suivant de la boucle pour : après l’itération i, les i premiers éléments de A contiennent chaque i-permutation de A avec probabilité (n−i)!n!\\frac {(n-i)!}{n!}n!(n−i)!​ 归纳法归纳法归纳法！！！ soit p une k+1-permutation, p’ le préfixe de longueur k de p P(p′ et x)=P(x∣p′)P(p′)=1n−k∗(n−k)!n!=[n−(k+1)]!n!P(AB)=P(A∣B)∗P(B)P(p'\\ et\\ x)=P(x|p')P(p')=\\frac1{n-k}*\\frac{(n-k)!}{n!}=\\frac{[n-(k+1)]!}{n!}\\\\ P(AB)=P(A|B)*P(B) P(p′ et x)=P(x∣p′)P(p′)=n−k1​∗n!(n−k)!​=n![n−(k+1)]!​P(AB)=P(A∣B)∗P(B) Quel est le résultat de l’algorithme? 就是在做交换但是随机这样子？ Quelle est la complexité de l’algorithme ? Θ(n) Classes de complexité des algorithmes probabilistes 问题集 rapple: EiE_iEi​ 表示执行第i次迭代的概率,E(X)=∑P(Ei)E(X) = \\sum P(Ei)E(X)=∑P(Ei) 同一个式子是不是可以同时等于O，Ω，Θ 是的，但是一般写Θ，因为它表达的信息能更多 P40的插入排序翻转对的问题 移动的次数就是等于翻转对的个数，然后需要加上定位到所有位置的一个遍历的复杂度n，所以是n+l P43的斐波那契Ω((32)n)Ω((\\frac32)^n)Ω((23​)n) P47的ex2 P50的pi和随机八皇后","link":"/2022/09/16/ALGOA_CM3/"},{"title":"ALGPR-1","text":"序 第一周的算法课都讲了什么T.T CM1 TD1 从字符的匹配开始讲的，说了蛮多伪代码的东西，真难看(bushi 字符的匹配 貌似没啥，就是熟悉一下子法语书写的伪代码 L 123456789101112131415Variables://定义变量 Caractère:courant//串，定义为字符类型 Entier:nbL//拿来计数的int Début nbL &lt;- 0 courant &lt;- lire()//这里的读是一个个读 tantque(courant != '.') si(courant == 'L') nbL &lt;- nbL+1 finsi courant &lt;- lire() fintanque afficher(nbL)//输出Fin LE 1234567891011121314151617Variables: Caractère:courant,précédent Entier:nbLE Début nbLE &lt;- 0 précédent &lt;- '.' courant &lt;- lire() tantque(courant != '.') si(courant == 'L' ET courant = 'E') nbLE &lt;- nbLE+1 finsi précédent &lt;- courant courant &lt;- lire() fintanque afficher(nbLE)Fin ELLE 就是把子串固定，然后拿courant去做匹配 以ELELLELLLLEL找ELLE为例 1234567891011121314151617181920212223242526272829303132Variables: Chaine de caractère:courant,motif//motif是子串 Caractère: c Entier: nbMotif Début nbMotif &lt;- 0 afficher(&quot;quel est le motif cherché?&quot;) motif &lt;- lire() //初始化串为...courant[0] pour i de 0 à taille(motif)-2 courant[i] &lt;- '.' finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c //串变成了...E tantque(c != '.') si (courant = motif) nbMotif &lt;- nbMotif+1 finsi //从后往前移 pour i de 0 à taille(motif)-2 courant[i] &lt;- courant[i+1] finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c fintanque afficher(nbMotif)Fin 妙的！时间复杂度的话N*n，可能比用想的的find函数要好哎 实际写的好艰难,string里面真的好多东西哦:( 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main(){ int nbMotif=0; string courant,motif; cin&gt;&gt;courant; cin&gt;&gt;motif; size_t p=0;//注意返回类型 while((p = courant.find(motif,p)) != courant.npos) { nbMotif++; p += motif.size(); } cout&lt;&lt;nbMotif&lt;&lt;endl; return 0;} 老师的奇妙方法 用矩阵还是图的知识来实现匹配(example:LE 123456789101112131415161718192021Variables: Caractère:c Entier: s,ss,x,nbLE Tableau d'Entiers m &lt;- {{0,1,0,2},{0,1,0,2}} Début nbLE &lt;- 0 s &lt;- 0 tantque(s != 2) courant &lt;- lire() x &lt;- 0 si(c == 'L') alors x &lt;- 1 finsi si(c == 'E') alors x &lt;- 2 finsi si(c == '.') alors x &lt;- 3 finsi ss &lt;- m(s,x) si (s = 1 ET x = 2) alors nbLE &lt;- nbLE+1 finsi s&lt;- ss fintanque afficher(nbLE)Fin 时间复杂度的话应该有两部分，一是在写m矩阵那里，然后是主程序。主程序的时间复杂度的话，有个逐个读的n，然后剩下的话我感觉有m^2。—&gt; ? 矩阵长这样 好像是在用s和x来表示前后两次的匹配的结果 但感觉就是时间也多了，空间也给浪费了嘛(；′⌒`) TD题 题 1.1 Points et polygone (enregistrement) On souhaite calculer quelques propri´et´es d’un polygone quelconque (p´erim etre, longueur moyenne des arˆetes, boite englobante). La boite englobante est un rectangle englobant le polygone de cˆot´es paralleles aux axes. Les sommets du polygone sont donn´es (dans l’ordre de parcours du p´erimetre) par leurs coordonn´ees r´eelles dans un plan et le nom du point (caractere). La liste de coordonn´ees est suppos´ee correcte et n’est lue qu’une seule fois. Exemple de fichier a lire : — 1,5 3,7 A — 6,4 4,6 B — 5,8 8,3 C — … — 1,5 3,7 A (dernier sommet a ne pas ajouter dans la structure de donn´ees) Les coordonn´ees du dernier sommet sont ´egales a celles du premier. Ce sommet permet uniquement de d´etecter la fermeture du polygone. Il ne faut pas rentrer ce sommet dans la structure de donn´ees. — Proposez une structure de donn´ee pour stocker le polygone, — Ecrivez l’algorithme principal pour lire le fichier contenant les points du polygone, ´ appeler les fonctions permettant de calculer les propri´et´es demand´ees et afficher les r´esultats a l’´ecran, — Ecrivez les fonctions secondaires pour calculer la longueur du p´erim`etre, calculer la ´ longueur moyenne des arˆetes et d´elimiter la boite englobante. 解 1234567891011121314151617181920Types//应该是在定义结构体 point: enregistrement caratère: nom réel: x réel: y fin_enregistrement tabPoint: tableau de pointAlgorithme principal PolygoneVariables://定义变量 tabPoint polygone,boiteEnglobante réel périmètre, longMoy Début polygone &lt;- lirePolygone(&quot;data.txt&quot;)//读文件 périmètre &lt;- calcuPérimètre(polygone)//周长 longMoy &lt;- périmètre/taille(polygone)//棱边数 boiteEnglobante &lt;- calculBoite(polygone)Fin Algorithme 我想的C++ 不知道能不能成 1234567891011121314151617181920212223struct Point{ char Nom; float x; float y;};float distance(Point A, Point B){ return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}class Polygone{ vecter&lt;Point&gt; PonitsDePolygone; public: //构造函数 Polygone(Point A){PonitsDePolygone.push(A);} //拷贝构造 ou 析构？？？？ float périmètre(); int longMoy();} 结语 KMP,CM和未完成的C++就是明天一定","link":"/2022/02/08/ALGPR-1/"},{"title":"ALGOA_CM4&amp;5","text":"ALGOA_CM4&amp;5 Énumeration exhaustive et Backtracking et Diviser pour régner Énumeration exhaustive EXEMPLE Carré magique. Pour n ∈ N&gt;0, placer une fois et une seule chaque nombre de 1 à n^2 dans une grille carrée de taille de côté n de façon à ce que la somme de chaque ligne, chaque colonne, et chaque grande diagonale soit la même. 123456789def carre(C,T,k,n): if k == n^2 and test\\_carre(C, n):#递归终止条件 return C for i = 1 to n^2: if not T[i]: T[i] = true#标记有没有取过 C[(k / n),(k mod n)]=i#这里下标很有意思，这样i和j都能取[0..n-1] carre(C,T,k+1,n) T[i]=false#回退 EXERCICE Backtracking 解空间树，DFS+约束函数 Exemple 八皇后： 123456789101112131415def aligned(L,i,j):#约束函数 for (k,l) in L: if k==i or l == j or abs(k-i) == abs(l - j): return True return Falsedef queen(L,i,n): if i==n: return L else: for j = 1 to n-1: if not aligned(L,i,j): L2 = L L2 = L2 ++ [(i,j)] queen(L2,i+1,n) return [] EXERCICE: Trouver des valeurs de x, y, z et w pour satisfaire cette formule de 3-SAT par backtracking : (x∨z∨w)∧(x∨y∨¬w)∧(¬x∨¬y∨w)∧(¬x∨¬y∨z)∧(¬x∨¬w)∧¬z(x ∨ z ∨ w) ∧ (x ∨ y ∨ ¬w) ∧ (¬x ∨ ¬y ∨ w) ∧ (¬x ∨ ¬y ∨ z) ∧ (¬x ∨ ¬w) ∧ ¬z(x∨z∨w)∧(x∨y∨¬w)∧(¬x∨¬y∨w)∧(¬x∨¬y∨z)∧(¬x∨¬w)∧¬z X=0,Y=1,W=1,Z=0 OU X=1,Y=0,W=0,Z=0 Le voyage du cavalier. On considère un échiquier de taille n avec un cavalier sur la case en haut à gauche. On rappelle que le cavalier se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale. Écrire un algorithme pour trouver dans quel ordre le cavalier doit visiter les cases de l’échiquier pour les voir toutes exactement une fois. -se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale: ​ -老师写的算法 12345678910111213141516def moves(B,i,j): n = len(B) deps = [(2,1),(-2,1),(2,-1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)] L = [] for (x,y) in deps: if i+x &gt;= 0 and i+x &lt; n and j+y &gt;= 0 and j+y &lt; n and B[i+x][j+y] == 0: L.append((i+x,j+y)) return Ldef knight(B,i,j,k): if k == n*n+1: print_board(B)#注意终止条件！ else: for (x,y) in moves(B,i,j): B[x][y]=k knight(B,i,j,k+1) B[x][y]=0 Diviser pour régner (Divide &amp; Conquer ) Principe général: Diviser en sous-problèmes Résoudre les sous-problèmes Combiner les solutions. En général, on parle de diviser pour régner , quand on divise en (au moins deux) problèmes indépendants identiques au problème initial mais plus petits. Donne naturellement des algorithmes récursifs. EXEMPLE: merge sort 归并排序 1234567891011121314151617181920def merge_sort(A,d,f): if f - d &gt; 1 : //划分 m = int((f+d)/2) merge_sort(A,0,m) merge_sort(A,m,f) B = A //合并 i = 0 j = m k = 0 while i &lt; m or j &lt; n: if j == n or B[i]&lt;B[j]#左半区更小 A[k] = B[i] i = i+1 else: A[k] = B[j] j = j + 1 k = k + 1 时间复杂度分析 T(n) = 2T(n/2) + Θ(n) a=2,b=2,k=1–&gt;T(n)=Θ(nlogn) EXERCICE: Recherche dichotomique. Proposer un algorithme pour la recherche d’un élement dans un tableau trié et donner sa complexité au pire cas. 二分查找 12345678def dicho(A,x,d,f): if d &gt; f : return False else: m = (d+f)/2 if x == A[m]: return m else: if x &lt; A[m]: return dicho(A,x,d,m) else : return dicho(A,x,m+1,f) Occurrences. Écrire un algorithme pour compter le nombre d’occurrences d’un élément donné dans un tableau trié et donner sa complexité pire cas. 查找出现的次数 123456789101112131415161718192021def find_first(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m] or (m &gt; d and A[m-1] == x): --这里的m&gt;d等价于f&gt;d，看着没啥必要的样子哎 return find_first(A,x,d,m) elif x &gt; A[m]: return find_first(A,x,m+1,f) else: return mdef find_last(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m]: return find_last(A,x,d,m) elif x &gt; A[m] or (m &lt; f and A[m-1] == x): --这里的m&gt;f也等价于f&gt;d，看着也没啥必要的样子 return find_last(A,x,m+1,f) else: return m 多米诺棋盘覆盖问题 用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//tr,tc表示棋盘左上角//dr,dc表示表示特殊方格void ChessBoard(int tr , int tc , int dr , int dc , int size){ if(size == 1)return;//棋盘只有一个方格其是特殊方格 int number = ++t;//L型骨牌号 int s = size/2;//划分棋盘 //覆盖左上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s-1][tc+s-1]=number; ChessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)//特殊方格在右上角子棋盘中 ChessBoard(tr,tc+s,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖左下角，再递归处理子棋盘 board[tr+s-1][tc+s]=number; ChessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左下角子棋盘中 ChessBoard(tr+s,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右上角，再递归处理子棋盘 board[tr+s][tc+s-1]=number; ChessBoard(tr+s ,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr+s,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s][tc+s]=number; ChessBoard(tr+s,tc+s,tr+s,tc+s,s); }} a = 4 , b = 2 , k = 1 Pesées. On a n pièces de monnaies dont une exactement est fausse et plus légère que les autres. On dispose d’une balance de type Roberval ou à éau : en une pesée on peut déterminer si un ensemble de pièces est plus lourd qu’un autre. Écrire un algorithme pour trouver la pièce fausse à l’aide de la balance et donner sa complexité au pire cas. On représente les pièces par un tableau de poids et on veut l’indice de la pièce fausse. On dispose d’une fonction compare(A, d1, f1, d2, f2) qui renvoit −1, 0 ou 1 si la somme des poids des pièces aux indices d1 jusqu’à f1 est respectivement plus petite, égale, ou plus grande que celle des pièces de d2 à f2 12345678910def pesses(A,d,f): if d &gt; f : return False elif d == f : return d else: m = (d+f)//2 if compare(A,0,m,m+1,f) == -1 : return pesses(A,0,m) elif compare(A,0,m,m+1,f) == 1 : return pesses(A,m,f) else: return False Tri rapide (quick sort). Si on choisit un élément du tableau (le pivot), on peut partionner les autres éléments en ceux qui sont plus petits, et ceux qui sont plus grands que le pivot. En exploitant ce principe, proposer un algorithme de tri d’un tableau et donner sa complexité au pire cas 123456789101112131415def quicksort (A, d, f ): if d &lt; f : p = partition (A, d, f ) quick_sort(A, d, p-1) quick_sort(A, p+1, f)def partition (A, d, f ): p = random_int(d, f) swap(A, f , p) j = d for i = d to f - 1: if A[i] ≤ A[f]: swap(A, j , i ) j = j + 1 swap(A, j , f ) return j a = 2,b=,k=1","link":"/2022/09/16/ALGOA_CM4&5/"},{"title":"ALGORITHM-Prem","text":"Prem 问题描述：全排列问题的两种递归实现 1.DFS(来自啊哈算法一书) 123456789101112131415161718192021222324void dfs(int step , int n ,int book[] , int a[]){ if (step == n )//排到第n个数，排列完成 { print(a,n); return;//【返回之前一步，很重要】 }//每一步的操作for (int i = 0; i &lt; n; i++){ if (!book[i])//还没有排 { a[step] = i+1; book[i] = 1; //开始排下一个了 dfs(step+1,n,book,a); book[i] = 0;//排序完成，回收本次数【！！！】 }} return;} DFS：深度优先搜索，这里的DFS不单指图论，理解为一种递归的思想。下一步操作与当下操作是一样的,一直执行，直到符合条件。基本模型为： void dfs(int step) { 判断边界(递归结束条件)return; 尝试每一种可能 for(int i = 0 ; i &lt; n ; i++) { 继续下一步 dfs(step + 1); } return ; }","link":"/2021/12/06/ALGORITHM-Prem/"},{"title":"ALGORITHM-算法效率","text":"算法_第二章__算法效率分析 1.算法分析概述 对算法所需要的两种计算机资源：时间资源和空间资源进行估算。 目的是为了设计和选择更好的算法 （1）时间效率 **时间效率：**设输入的元素个数为n,执行该算法的第i步操作记为op（i）,该步骤执行的次数为Cop(i)，则该算法的总执行时间为： T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) （2）时间复杂性 时间复杂性：指执行算法所消耗或占用时间资源的量【程序步数】 ​ 在最坏、最好、平均三种情况下的时间复杂度 （3）例题 1.非递归程序顺序检索：在具有n个元素的数组a[1……n]中找出值等于x的元素的位置 1234567template&lt;class Type&gt;int seqSearch(Type *a, int n, Type x){ for(int i=0;i&lt;n;i++) if (a[i]==x) return i; return -1;} 最坏：T(n) = n 最好：T(n) = 1 平均：Tavg（n）=sum[p(I)T(I)] 变式：设计一个尽可能高效的算法，在长度为n的一维数组a[n]中查找值最大的元素max和最小的元素min，并分析算法的最好、最坏和平均时间复杂度。 123456789void MaxMin(int a[],int n,int &amp;max,int &amp;min){ int I; max=min=a[0]; for(i=1;i&lt;n;i++) if(a[i]&gt;max) max=a[i]; else if(a[i]&lt;min) min=a[i];//【要特别注意这的else！！！】} 最好：是一个递增的，n-1 最坏：递减，2*（n-1） 平均：假设a中有一半元素比max大，a[i]&gt;max执行n-1次，else语句执行（n-1）/2次------&gt;平均3*（n-1）/2次 2.递归程序的时间复杂性分析 123456789float RSum(float list[],const int n){ if (n) //1 { return RSum(list,n-1)+list[n-1]; //? } return 0; //1} T(n) = T(n-1)+2[T(0)=2] 程序步骤不能确切反映程序运行的实际时间 2.渐进 定义：只关心f(n)的阶 **大O表示法：**若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≤c×f(n)，则称f(n)是T(n)的上界，记为：T(n)=O(f(n)) **大Ω表示法：**若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≥c×g(n)，则称g(n)是T(n)的下界，记为：T(n)= Ω(g(n) **Θ表示法：**若存在三个正的常数c1、c2和n0，对于任意n≥n0都有c1×f(n)≥T(n)≥c2×f(n)，则称f(n)与T(n)同阶，记为：T(n)=Θ(f(n)) 求解方法： \\lim_n {t(n)\\over g(n)}=0\\mbox{\\quad \\quad t(n)的增长次数比g(n)小}\\\\ \\lim_n {t(n)\\over g(n)}=c&gt;0\\mbox{\\quad \\quad t(n)的增长次数和g(n)相同}\\\\ \\lim_n {t(n)\\over g(n)}=\\infty\\mbox{\\quad \\quad t(n)的增长次数比g(n)大} 为0时，大O；为无穷时，大Ω；c为Θ 3.时间复杂度 定义：针对指定基本运算，计数算法所做运算次数 例： 123456x=1; for(i=1; i&lt;=n; i++) for(j=1 ; j&lt;=i; j++) for(k=1; k&lt;=j; k++) x++; 执行次数为： ∑i=1n∑j=1i∑k=1j1=∑i=1n∑j=1ij=∑i=1ni(i+1)2=[n(n+1)(2n+1)/6+n(n+1)/2]/2=n3+3n2+2n6\\sum^n_{i=1}\\sum^i_{j=1}\\sum^j_{k=1}1=\\sum^n_{i=1}\\sum^i_{j=1}j=\\sum^n_{i=1}{i(i+1)\\over2}=[n(n+1)(2n+1)/6+n(n+1)/2]/2 \\\\ ={n^3+3n^2+2n\\over6} i=1∑n​j=1∑i​k=1∑j​1=i=1∑n​j=1∑i​j=i=1∑n​2i(i+1)​=[n(n+1)(2n+1)/6+n(n+1)/2]/2=6n3+3n2+2n​ 时间复杂度T(n) = O(n^3) 4.递归的高阶方程的数学分析 先化简再计算 例： 1.汉诺塔问题的递归算法的复杂度分析 代码： 12345678910void Hanoi(int n , A ,B,C){ if(n == 1)MoveOne(n,A,B); else { Hanoi(n-1 , A ,C , B); MoveOne(n,A,C); Hanoi(n-1 , B , A , C); }} M(n) = 2M(n-1)+1 M(n) = Θ(2^n) 2.斐波那契 代码： 1.递归实现 123456int Fibonacci1(int n){ if(n &lt; 0) return -1; if(n &lt;= 0) return (n); else return Fibonacci1(n-1)+Fibonacci1(n-2);} A(n) = A(n-1)+A(n-2)+1 2.迭代法 123456789int Fibonacci2(int n){ int F[n+1]; F[0] = 0; F[1] = 1; for(int i = 2 ; i &lt;= n ; i++) F[i] = F[i-1] + F[i - 2]; return F[n];} 时间复杂度低但空间资源浪费高 A(n) = n - 1 = Θ(n) 3.最优解法 123456789101112int Fibonacci3(int n){ int F , Fa , Fb; Fa = 0 ; Fb = 1 ; for(int i = 2 ; i &lt;= n ; i++) { F = Fa + Fb; Fb = Fa; Fa = F; } return F;}","link":"/2021/12/06/ALGORITHM02/"},{"title":"ALGOA_CM8","text":"Structures de données Représenter et organiser des collections d’objets ; Choisir la bonne structure de données Spécialisation sur certaines opérations : types de de données abstraits Comprendre leurs implémentations[实施方案] possibles : maîtriser[控制] leur complexité pouvoir les étendre[扩大] avec de nouvelles opérations. 1. Tableaux et listes 都是线性的 一些区别 • Tableaux : accès direct, taille fixe • Listes : structure récursive : tête et queue, accès séquentiel[顺序访问] (en particulier accès direct à la tête) , taille variable Tableaux Implémentation des tableaux : adresses et pointeurs x est une variable. Elle a un nom (x), un type (entier sur 8 bits), un contenu (2), et une adresse (132)，p est une variable qui contient une adresse，pointeur sur un entier sur 8 bits 取值*和引用[取地址]&amp; Opération spécifique sur les types pointeurs : le déréférencement，⇒ *p est la variable dont l’adresse est dans p On a aussi une opération pour obtenir l’adresse d’une variable , ⇒ &amp;x donne l’adresse (de début) de x 这里说p是32bits的pointeur，所以*p是一个贼大的数，2+3x256的3次方=16777218 q是8bits的pointeur，所以*q是3 Implémentation des tableaux A[i] = *(A+n x i)[n是每个元素的taille吗] 关于数组增删查改的复杂度：accès: O(1), insertion: O(n), supression: O(n),insertion/suppression: à la fin O(1) Tableaux dynamiques Comment ajouter un élément dans un tableau A quand il est plein[满]? Allouer un nouveau tableau plus grand en mémoire ; Copier l’ancien tableau dans le (début du) nouveau ; Faire pointer A sur le nouveau tableau ; Ajouter l’élément. 复杂度是O(n) complexité amortie: si on fait beaucoup d’accès[访问] et peu de redimensionnements[调整], ils sont négligeables[忽略]. coût amorti[平摊分析] : 1n∑k=1nck\\frac 1 n \\sum_{k=1}^nc_kn1​∑k=1n​ck​, ckc_kck​ 表示le coût de l’instruction Coût amorti : méthode du potentiel – 平摊分析的势能方法 一些源于wiki上的解释 平摊分析常用于分析资料结构（动态的资料结构），在使用平摊分析前须知道资料结构各种操作所可能发生的时间，并计算出最坏情况下的操作情况并加以平均，得到操作的平均耗费时间。平摊分析只能确保最坏情况性能的每次操作耗费的平均时间，并不能确认平均情况性能。一个简单的例子，一个长度为n的liste，在liste的最后要加入一笔新的资料此时要花费的操作时间为O(n)，此时也是加入新的资料的最糟糕的情况。但是，一个 n 个插入的操作序列仍然可以在 O(n) 的时间内完成，因为剩下的插入可以在常数时间内完成，因此n 个插入可以在 O(n) 的时间内完成。因此每操作的平摊耗费为O(n) / n = O(1)。 ex： On considère une chaîne de caractères (un tableau) contenant initialement des espaces et suffisamment grande. On dispose de trois opérations : Ajouter un caractère à la fin de la chaîne, remplaçant le premier espace (‘a’, …, ‘z’) : O(1) Effacer le dernier caractère (del) O(1) Effacer tous les caractères (clear) : 1 + nb de caractères à effacer = O(n). 这些个指令数怎么长这样子哦 Plus généralement, le coût d’une séquence de n instructions est O(n). Le coût amorti de clear est donc O(n)/n = O(1), 然后把它记作O˜(1) 用势能方法来做clear的平摊分析 soit s le nombre de caractères différents d’espace dans la chaine; on choisit la fonction φ(s)=s+1 Initialement, la chaine est vide donc φ(V0) = 1 Comme il y a toujours au moins 0 caractères dans la chaine on a toujours φ(Vn) ≥ 1 = φ(V0) Le coût potentiel de la séquence est donc ≥ au coût total de la séquence On calcule le coût potentiel de chaque opération : si ik=′c′,pk=1+φ(Vs)−φ(Vs−1)=1+(s+1)−s=2i_k = 'c', p_k = 1+φ(V_s)-φ(V_{s-1})=1+(s+1)-s=2ik​=′c′,pk​=1+φ(Vs​)−φ(Vs−1​)=1+(s+1)−s=2 si ik=del,pk=1+s−(s+1)=0i_k=del,p_k=1+s-(s+1)=0ik​=del,pk​=1+s−(s+1)=0 si ik=clear,pk=(1+s)+0−s=1i_k=clear,p_k=(1+s)+0-s=1ik​=clear,pk​=(1+s)+0−s=1 Chaque opération a bien un coût potentiel O(1) donc le coût potentiel total est 0(n), donc le coit aussi O(n) et le coût amorti de clear est Ö(1). On considère l’incrémentation n fois d’un compteur binaire à k chiffres. Exemple pour k = 3, n = 7 : Déterminer le coût pire cas et, par la méthode du potentiel, le coût amorti de chaque incrémentation. φ(0) = 0 ; φ(n) = nombre de 1 dans n si n = 0…0 , 1+(x+1)-x = 2 sinon n = 1…1, p+1+(x-p+1)-x=2 Complexité amortie du redimensionnement de tableau. On suppose une séquence d’insertions en n de tableau plus grande que le tableau, on augmente la taille du tableau de k cases quand il est plein, Soit AiA_iAi​ le tableau après l’instruction i et sis_isi​ sa taille On définit la fonction de potentiel φ(i) = 2i − sis_isi​ Coût potentiel des insertions: • Si $i &lt; s_i : 1 + 2 ∗ (i + 1) − s_{i+1} − (2 ∗ i − s_i ) = 3 \\ car\\ s_{i+1} = s_i $ • Si $i = s_i : (1 + s_i ) + (2 ∗ (i + 1) − s_{i+1} − (2 ∗ i − s_i ) = 3 + s_i − k \\ car\\ s_{i+1} = s_i + k $ Avec k = sis_isi​, on a donc une complexité amortie O˜(1) Liste Liste chaînées 定义 Chaque cellule C contient la donnée C.d et un pointeur vers la cellule suivante C.n Chaque peut se trouver n’importe où en mémoire Chaque peut se trouver n’importe où en mémoire 增删改查的时间复杂度：accès O(n)，insertion/suppression O(n)，insertion/suppression avec pointeur O(1) insertion/suppression 12345678910111213141516171819202122232425262728# insertion de l'élément x après la cellule pointée par Ldef insert (L, x ): #On suppose le type enregistrement cell bien défini #L'est un pointeur vers la nouvelle cellule L' = memory_alloc(cell) (*L').n = (*L).n (*L').d = x (*L).n = L'# insertion de l'élément x en tête de la liste pointée par Ldef insert_front (L, x ): #On suppose le type enregistrement cell bien défini #L' est un pointeur vers la nouvelle cellule L' = memory_alloc(cell) (*L '). n = L (*L '). d = x return L'def supp(L): L.n = (L.n).n return Ldef supp1(L,x): if L.d == x: L = L.n return L else: L.n = supp(L.n,x) return L Listes doublement chaînées insertion/suppression 1234567891011121314151617181920212223242526272829303132333435def insert2_after (L,x ): #On suppose le type enregistrement cell bien défini #L' est un pointeur vers la nouvelle cellule L' = memory_alloc(cell) (*L').n = (*L).n (*L').p = L # new ! (*L').d = x if (*L).n != ⊥ : # new ! (*((*L).n )). p = L' # new ! (*L).n = L' # si L était la fin de la liste, il faudra mettre à jour #le pointeur end return L'# insertion de l'élément x avant la cellule pointée par Ldef insert2_before (L,x ): #On suppose le type enregistrement cell bien défini #L' est un pointeur vers la nouvelle cellule L' = memory_alloc(cell) (*L').n = L (*L').p = (*L).p # new ! (*L').d = x if (*L).n != ⊥ : # new ! (*((*L).n )).p = L' # new ! (*L).P = L' # si L était la fin de la liste, il faudra mettre à jour #le pointeur end return L' def supp2(L): (L.d).n = L.n (L.n).d = L.d return L.d 2. Files et piles 定义：File : First In First Out (FIFO) 队列，Pile : Last In First Out (LIFO)堆栈，基本操作：insérer / empiler (enqueue / push)，supprimer / dépiler (dequeue / pop), prochain élément / dessus de pile (next / top), vide ex La Bataille. Dans ce jeu de cartes, les 52 cartes sont distribuées entre les deux joueurs et gardées faces cachées. À chaque tour, les deux joueurs retournent la première carte de leur paquet. Le joueur avec la carte la plus forte (on considère uniquement la valeur, pas la couleur) remporte les deux cartes qu’il met au dessous de son paquet (d’abord la sienne puis l’autre). En cas d’égalité, il y a Bataille !. Chaque joueur ajoute la prochaine carte de son paquet face cachée sur sa carte, puis retourne à nouveau la carte du dessus de son paquet. Le joueur avec la carte la plus forte, remporte toutes les cartes qu’il met en dessous de son paquet dans l’ordre (du dessus vers le dessous et comme précédemment). S’il y a encore égalité on répète l’opération autant de fois que nécessaire. À tout moment, un joueur qui ne peut pas jouer perd et son adversaire gagne 1234567891011121314151617181920212223242526272829303132333435363738394041424344from file_pile import File, Piledef bataille(L1, L2): # Q1, Q2 sont des files[队] et P1, P2 sont des piles[堆] Q1 = File() Q2 = File() P1 = Pile() P2 = Pile() # 把牌压入队列 for c in L1: Q1.enqueue(c) for c in L2: Q2.enqueue(c) #牌打完退出循环 while not Q1.empty() and not Q2.empty(): done = False while not done and not Q1.empty() and not Q2.empty(): done = True #翻开自己的底牌 P1.push(Q1.dequeue()) P2.push(Q2.dequeue()) #赢两张牌 if P1.top() &gt; P2.top(): while not P1.empty(): Q1.enqueue(P1.pop()) Q1.enqueue(P2.pop()) elif P1.top() &lt; P2.top(): while not P1.empty(): Q2.enqueue(P2.pop()) Q2.enqueue(P1.pop()) else: #平局的话翻开自己的牌顶 if not Q1.empty() and not Q2.empty(): P1.push(Q1.dequeue()) P2.push(Q2.dequeue()) done = False if Q1.empty(): return 2 else: return 1 Notation polonaise inversée. 用pile，一旦是符号就弹出2个出来算然后压进去 12345678910def fun(L): P = Pile() for item in L: if not is_digit(item): P.push(item) else: num1 = P.pop() num2 = P.pop() P.push(c2i(num1,num2,item)) return P.top() Simuler une file le avec deux piles 123456789101112131415class File: def __init__(self): self.contents = [] def enqueue(self, x): self.contents.append(x) def dequeue(self): x = self.contents[0] self.contents.pop(0) return x def empty(self): return not self.contents Simuler une pile avec deux les files 12345678910111213141516171819class Pile: def __init__(self): self.contents = [] def push(self, x): self.contents.append(x) def pop(self): e = len(self.contents) - 1 x = self.contents[e] self.contents.pop(e) return x def top(self): return self.contents[len(self.contents) - 1] def empty(self): return not self.contents Établir, dans les deux cas, la complexité (amortie) des opérations simulées Derécursification[去递归] 例子：阶乘 1234567891011121314151617181920def fact(n): if n == 0: r = 1 else r = n * fact(n-1) return rdef fact2(n): r = 0 W.push(frame(n, 0, &amp;r, 1, True))#W是堆,frame是构造的一个结构体 while not W.empty(): f = W.top() if f.grow:#把所有数压进去 if f.n == 0: *f.p = 1 W.pop()#跳到外面的else去做乘法 else: W.top().grow = False W.push(frame(f.n-1, 0, &amp;f.r , f.n, True)) else:#这里做乘法 *f.p = f.r * f.a#f.r不都是0了？？？？？，为啥是f.a不直接写f.n W.pop() return r 3. Files de priorité 定义 Files de priorité：优先队列，Toujours sortir le plus petit élément de la le，On peut trier la le (typiquement) O(n log2 n)) mais il faut recommencer à chaque insertion (O(n)) **平衡树：**Un arbre est équilibré en hauteur si la hauteur de ses sous-arbre diffère d’au plus 1[任意节点的子树的高度差都小于等于1], un arbre n-aire équilibré avec m noeuds a une hauteur d’au plus lognmlog_nmlogn​m, on construit une structure avec des opérations en O(hauteur). Tas binaire (binary heap)： un arbre binaire tel que seul le dernier niveau n’est pas rempli[只有最后一层没满], dans chaque sous-arbre la racine est plus petite que les racines de ses sous-arbres[根节点永远小于子节点] Tas implicites[隐式]：堆的数据结构是用数组来实现的，Pour un indice i donné–&gt; indice du noeud parent : i-1//2, indice du noeud successeur (fils) gauche : 2i + 1 et droit : 2i + 2 基本操作 关于堆的基本操作：test du vide, insertion d’un élément，extraction du minimum Insertion On ajoute l’élément à la fin, on le fait remonter à sa place le cas échéant[维护堆的性质]. 时间复杂度是O(logn) 1234567891011121314def heap_insert(A, x , n): if n == len(A) - 1: error (&quot;heap is full &quot;) #堆满抛异常 else : A[n] = x n = n + 1#这里+1干嘛--&gt;说明taille+1吗 heap_fix_up(A, n - 1)def heap_fix_up(A, i):#从下往上维护堆的性质 p = (i-1)//2 while p ≥ 0 and A[i] &lt; A[p]: swap(A, i , p) i = p p = (i-1)//2 Extraction Le minimum est la racine, on le remplace par le dernier élément de l’arbre, on fait descendre cet élément à sa place le cas échéant. 时间复杂度是O(logn) 12345678910111213141516171819202122232425def heap_extract_min(A, n): if n == 0: error (&quot;heap is empty&quot;) else : r = A[0] A[0] = A[n-1] n = n - 1 heap_fix_down(A, 0, n) return rdef heap_fix_down(A, i, n)#从上往下维护堆的性质 done = false while not done: done = true k = i #找左右节点更小的 if 2i + 1 &lt; n and A[2i + 1] &lt; A[k]: k = 2i + 1 if 2i + 2 &lt; n and A[2i + 2] &lt; A[k]: k = 2i + 2 #根节点大就换，然后再往下换 if i != k: swap(A, i , k) i = k done = false Tri par tas 时间复杂度，插入加摘2logn，取渐进就是O(logn) 1234567def heapsort(A, n): #把这里看作建堆的过程 for i = n//2-1 downto 0:# 从最后那个元素的父节点开始维护 heap_fix_down_max(A, i, n) for i = n - 1 to 1: swap(A, 0, i )#不停的把最值放到后面 heap_fix_down_max(A, 0, i+1)#这里咋+1？不应该就是i吗 4. Ensembles et tableaux associatifs ABR 定义：Dans tout sous-arbre : la racine du ls gauche (si elle existe) est plus petite que la racine， la racine du ls doit (si elle existe) est plus grande que la racine[左结点小，右节点大] 操作：查找，插入和删除 查找：复杂度是O(hauteur) 123456789def abr_search(A, x): if A == ⊥: return false else if x == (*A).r: return true else if x &lt; (*A).r: return abr_search((*A).g, x) else : return abr_search((*A).d, x) 插入： 12345678910111213def abr_insert(A, x ): if A == ⊥:# on suppose le type node bien défini B = memory_alloc(node) (*B).r = x (*B).g = ⊥ (*B).d = ⊥ return B else : if x &lt; (*A).r: (*A).g = abr_insert((*A).g, x) else : (*A).d = abr_insert((*A).d, x) return A 删除[未解决]： 两种主要思想： remplacer (* N).r par la valeur (* Y).r et supprimer cette valeur dans le sous-arbre correspondant：用值(*Y).r替换(*N).r，并从相应的子树中删除这个值 remplacer N par Y et recoller les morceaux soigneusement：把N换成Y，然后小心翼翼地把碎片粘在一起 12345678910111213141516171819202122232425262728293031323334def abr_min_parent(A, p): if A.g == None: return p else: return abr_min_parent(A.g, A)def abr_delete(A, x): if A != None : if x == A.r: if A.g == None:#如果左子树为空，包含了叶子结点的情况 return A.d elif A.d == None:#如果右子树为空 return A.g else:'''最复杂的左右子树都不空的情况--&gt;1.找到该节点的右子树中的最左孩子（也就是右子树中序遍历的第一个节点） 2、把它的值和要删除的节点的值进行交换 3、然后删除这个节点即相当于把我们想删除的节点删除了，返回true；''' P = abr_min_parent(A.d, A) if P == A: Y = A.d # c'est directement A.d qui est le min else: Y = P.g # Y est le min，Y左子树为空，只有右子树 Y.d = A.d #这样不是就包含自己了嘛？？？？？？--&gt;换A和Y和值， #然后del(Y):P.g=Y.d Y.g = A.g return Y else: if x &lt; A.r: A.g = abr_delete(A.g, x) else: A.d = abr_delete(A.d, x) return A Arbres auto-équilibrant/AVL rapple：任意节点的子树的高度差都小于等于1,常见的平衡树有：AVL,2-3树，红黑树，这里就只讨论AVL[二叉平衡搜索树] 定义: Pour tout noeud x, le sous-arbre enraciné en x est équilibré (en hauteur). --&gt; AVL就是平衡的ABR，平衡因子A.b = hauteur(A.d) - hauteur(A.g)在-1到1之间 Un arbre équilibré en hauteur avec n noeuds a une hauteur O(log2 n) 基本操作: rotation, insertion et suppression,他们3的复杂度都是O(logn) rotations 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def avl_rotate_left(A): R = A.d A.d = R.g R.g = A A.b = A.b - 1 #更新平衡因子 if R.b &gt; 0: A.b = A.b - R.b R.b = R.b - 1 if A.b &lt; 0: R.b = R.b + A.b return Rdef avl_rotate_right(A): R = A.g A.g = R.d R.d = A A.b = A.b + 1 if R.b &lt; 0: A.b = A.b - R.b R.b = R.b + 1 if A.b &gt; 0: R.b = R.b + A.b return Rdef avl_balance(A): R = A if A != None: if A.b == 2: if A.d.b &lt; 0: A.d = avl_rotate_right(A.d) R = avl_rotate_left(A) elif A.b == -2: if A.g.b &gt; 0: A.g = avl_rotate_left(A.g) R = avl_rotate_right(A) return R insertion 12345678910111213141516171819def avl_insert(A, x, p, bfu): retrace = (p != None) if A == None: B = node(x, p) else: if x &lt; A.r: A.g = avl_insert(A.g, x, A, -1) else: A.d = avl_insert(A.d, x, A, +1) B = avl_balance(A) if B.b == 0: retrace = False if retrace: p.b = p.b + bfu return B suppression Tables de hachage 定义：根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。他的增删改查的复杂度都是O(1) EX: Chemins. Soit M une matrice de taille m × n contenant des 0 et des 1. On s’intéresse aux chemins qui vont de la case (0, 0) à la case (m − 1, n − 1) en ne passant que par des 1 et en ne se déplaçant que sur une case immédiatement à droite ou en bas. En s’inspirant de la programmation dynamique, donner un algorithme non-récursif qui calcule le nombre de tels chemins Tables de hachage : chaînage 123456def ht_search(T, x): return list_search(T[h(x)], x)def ht_insert(T, x): T[h(x)] = list_insert_front(T[h(x)])def ht_delete(T, x): list_delete (T[h(x )], x) complexité: Quelle est la complexité pire cas de ces opérations ? La complexité de l’utilisation de la table dépend de celle de la recherche. [操作的复杂度源于查找的复杂度]Pour la suppression : Recherche d’un pointeur sur la cellule contenant x (ou son parent si la liste est simplement chaînée) ; Suppression en O(1) de la cellule en utilisant ce pointeur La complexité pire cas ne dépend pas de la taille m de la table La complexité moyenne dépend de m et de la qualité de la fonction de hachage : indépendance : ∀x, y, P(h(x)|h(y)) = P(h(x)) ;uniformité : ∀x, P(h(x)) = 1/m Une fonction de hachage valeurs dans [0…m − 1] est universelle si P(h(x) = h(y)) = 1/m. Montrer que si h est indépendante et uniforme alors elle est universelle. P(h(x)=h(y))=∑nP(h(x)=a et h(y)=a) =∑nP(h(x)=a)∗P(h(y)=a)=n∗1n2=1nP(h(x)=h(y))=\\sum_nP(h(x)=a\\ et\\ h(y)=a)\\ =\\sum_n P(h(x)=a)*P(h(y)=a)\\\\=n*\\frac 1 {n^2} = \\frac 1 n P(h(x)=h(y))=n∑​P(h(x)=a et h(y)=a) =n∑​P(h(x)=a)∗P(h(y)=a)=n∗n21​=n1​ En supposant h universelle et qu’on a n éléments dans notre ensemble, quelle est l’espérance du nombre de collisions? Xxy=1 si h(x)=h(y) sinon 0E(X)=∑x&lt;yE(Xxy)=∑x&lt;y1n=n2−n2n=n−12X_{xy} = 1 \\ si\\ h(x)=h(y)\\ sinon\\ 0\\\\ E(X)=\\sum_{x&lt;y}E(X_{xy})=\\sum_{x&lt;y}\\frac1n=\\frac{n^2-n}{2n}=\\frac {n-1}2 Xxy​=1 si h(x)=h(y) sinon 0E(X)=x&lt;y∑​E(Xxy​)=x&lt;y∑​n1​=2nn2−n​=2n−1​ 啥哦== Combien de personnes ont leur anniversaire le même jour dans la classe ? EX 好难哦，不想看了","link":"/2022/11/12/ALGOA_CM8/"},{"title":"ALGPR-2","text":"序 第二周的算法课都讲了什么T.T TD2 尝试在课上直接记blog的第一天 Récursivité calcule la puissance d’un nombre principe_1: calcul récursif pour n != 0,et puissance(x,0)=1 123456entier puissance(entier x,entier n):Début si (n = 0) alors retourner 1//结束递归的跳出条件 sinon retourner x * pusissance(x,n-1)//递归 finsiFin principe_2: par la méthod “diviser pour régner”,et puissance(x,0)=1,et puissance(x,1)=x div étant la division entiere 1234567891011121314151617Début //结束递归的跳出条件 si (n = 0) alors retourner 1 finsi si (n = 1) alors retourner x finsi //本质还是在所递归，有减少一些递归的次数 entier y = puiss2(x, (n div 2)) si (n mod 2 = 0 ) alors retourner y*y sinon alors retourner x*y*y finsiFin ----&gt;堆栈！ L’ordre inversé 12345678910111213141516171819202122232425262728293031323334affiche_1(vecteur&lt;entier&gt; w)Début pour i de 0 à taille(w) -1 faire écrire(w[i]+'') fin_pourFin affiche_2(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors écrire(w[debut]+'') affiche_2(w,debut+1) fin_siFinentier debut = taille(w) -1affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut = -1) exit(0) fin_si écrire(w[debut]+'') affiche_inv(w,debut-1)Fin//可以初始化为0，先递归再输出[妙！]affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors affiche_inv(w,debut-1) écrire(w[debut]+'') fin_siFin String的palidrome 123456789101112Algorithm palindrome booléen &lt;- palindrome(string s,int decal) Début si(decal &lt; (taille(s)-1)/2) si(s[decal] != s[taille(s)-1-decal]) retourner FAUX sinon palindrome(s,decal+1) sinon retourner VRAIFin –&gt;用stack来实现 Reine et pions(八皇后！) 题有点怪 先写题 On considère un échiquier de huit cases sur huit comportant huit pions et une reine. Les positions des pions et de la reine sont données dans un fichier sous un format que vous devez définir(selon la structure de données que vous choisissez). La reine peut se déplacer sur les lignes(diagonales; verticale et horizontale) sur lesquelles elle se trouve. On souhaite savoir combien de pions sont en prise(i.e. pouvant êrte pris par la reine). Si deux pions ou plus sont sur la même ligne(diagonale, verticale , horizontale), seul le premier est en prise. 123456789101112131415161718192021DFSint res[9]void dfs(int step){ int i,j; if(step &gt; 8) { for(i=0;i&lt;8;i++) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0; } //尝试每一种可能 for(int i = 0 ; i &lt; 8; i++) { 继续下一步 dfs(step + 1); } return ; } CM2 Gestion de la mémoire//内存管理 Possible de stocker un lien vers une case mémoire Utile pour : ​ Structures de données (listes chainées, arbres) ​ Passage de paramètres：传递参数 ​ Allocation de mémoire：配置、地址分配 像是在讲指针的样子 1234567891011utilisation 'lien' :ExempleLienEntiervariables lien entier lienEnt//声明一个lien entier entDébut lienEnt ← lien(ent) contenu(lienEnt) ← 5 reçoit la valeur 5//接受 afficher(ent)Fin 关于lien和contenu lien:创造或声明链接 contenu：访问链接的内容 Structures de données composées Stockage de plusieurs données dans une seule structure pour：Structurer les données，Faciliter les traitements Données de même type : listes et arbres//树和表 Données de type quelconque : enregistrements(记录登记) Enregistrements 应该是结构体 123456789101112131415161718types article : Enregistrement entier : référence réel : prix chaine de caractère : libellé entier : quantité Fin enregistrementvectArticles : tableau d’articlevariablesarticle artCour // article courantentier valeurStockartCour.prix &lt;-- lire ()artCour.libellé &lt;-- lire ()artCour.quantité &lt;-- lire ()valeurStock &lt;-- artCour.prix * artCour.quantitéécrire (&quot;La valeur du stock de &quot;, artCour.libellé, &quot; est de : &quot;,valeurStock, &quot; euros&quot;) Structures linéaires Listes Définition Ensemble d’éléments de même type liés par une relation de séquentialité 注意一下名字： prédécesseur， successeur 一些关于表的基本操作:插入、删除、测试表是否为空、测表长 Tableaux表 Accès direct à un élément à l’aide de son indice(下标) 目标算法: Somme(求和), Tris(排序), Présence d’élément(?) Exemple de définition de types composés tabEnt : Tableau d’entiers matReels : Tableau de dimension 2 de réels tab4DEnt : tableau d’entiers de dimension 4 123456789101112131415161718192021222324252627282930//检查是否正序variables tabEnt tab entier n booléen trie{n, tab} &lt;- lire ()trie &lt;- VRAIpour i &lt;- 0 à n-2 faire si ( tab[i] &gt; tab[i+1] ) alors trie FAUX fin sifin poursi ( non trie ) alors écrire (&quot;le tableau n’est pas trié&quot;)fin si//一般函数variables vectArticles tabArt//?结构体的vector？ réel valStock entier nDébut{n, tabArt} &lt;-- lire (&quot;data.txt&quot;)valStock &lt;-- 0pour i 0 à n-1 faire valStock valStock + tabArt[i].prix * tabArt[i].quantitéfin pourécrire (&quot;La valeur du stock des &quot;, n, &quot; articles est de : &quot;,valStock, &quot; euros&quot;)Fin 所以说就是表的元素可以是结构体的意思？ Liste chainée链表 单向 successeur 链表的定义(值与指向下一元素的指针)： 1234567891011121314151617type elementEntier : Enregistrement entier valeur, lien elementEntier suivant, // lien vers l’élément suivant Fin enregistrementvariables elementEntier elementUn, elementDeux, ..., elementSix... elementUn.valeur 12 elementUn.suivant lien(elementDeux) elementDeux.valeur 99 elementDeux.suivant lien(elementTrois) ... elementCinq.suivant lien(elementSix) elementSix.valeur 16 elementSix.suivant VIDE 双向 要同时定义前置和后置指针 Calcul de la longueur d’une liste（递归） 1234567891011fonction : longueur calculLongueur(lienDébutListe)paramètres : lien elementEntier lienDébutListerésultats : entier longueurDébut si ( lienDébutListe est VIDE ) alors longueur 0 sinon longueur 1 + calculLongueur(lienD´ebutListe-&gt;suivant) fin si retourner longueurFin Recherche d’un élément dans une liste（递归） 12345678910111213141516fonction : présence chercherElement(lienDébutListe, val) paramètres : lien élémentEntier lienDébutListe, entier val résultats : booléen présenceDébut si ( lienDébutListe est VIDE ) alors//链表为空退出 présence FAUX sinon si ( lienDébutListe-&gt;valeur = val ) alors présence VRAI sinon présence chercherElement(lienDébutListe-&gt;suivant, val) fin_si fin_si retourner présenceFin 就是链表本质就是结构体+数组吗？ Liste chainée和tableau时间复杂度的比较 查找，添加/删除头(位) Piles 存储结构讲表与链表，然后栈、队列是特殊的线性表（？） LIFO:栈，先入后出 基本操作： ajoute(push),delete(pop),Test de pile vide File d’attente FIFO：队列，先入先出 Structures arborescentes ​ Extension du concept de liste avec plusieurs successeurs pour un élément(一个节点后面可以接多个节点) 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/09/ALGPR-2/"},{"title":"ALGPR-3","text":"序 ALGPR的第三周 TD TD2_Division euclidienne 1234567891011121314151617181920212223242526272829303132couplEntier qr &lt;- divEuclid(entier n, entier d)Types couplEntiers: enregistrement entier: quotient entier: reste fin_enregistrement Variables couplEntiers qr,inter Début Si(n &lt; d) alors qr.reste &lt;- n; Sinon qr.quotient++; divEuclid(n - d , d); fin_Si retourner qrFinDébut Si(n &lt; d) alors qr.quotient &lt;- 0; qr.reste &lt;- n; Sinon inter &lt;- divEuclid(n - d , d); qr.quotient &lt;- inter.quotient + 1; qr.reste = inter.reste ; fin_Si retourner qrFin TD3_Définition Notion de lien vers une structure de données: ce lien est un type de données à part entière défini par le mot-clé lien, suivi du type lié. Cette notion de lien sera traduite(翻译) en C++ par la notion de pointeur（指针） Lien Type_x 1: pour créer ou déclarer un lien sur une variable contenu(1): pour accéder au contenu du lien 1 指针和引用 指针本质也是变量，存储地址。引用本质是取地址。 注： 引用必须初始化，引用不能为空，引用只是别名不是实体 就是说不能这样子 int &amp;n 要这样 int &amp;n = m(m之前定义) 然后in &amp;n = 3这样子也会报错（？） 引用没有const 引用的自增和指针的自增问题 123456789101112131415int *p,entier;int &amp;q = entier;entier=5;p = &amp;q;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;*p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;q++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; 指针自增就是还挺多，*运算符的优先级低于右++，然后还有什么移位不安全啥的，看到再说 Exemple 1234567891011121314Variables Lien Entier lienEnt Entier nDébut lienEnt &lt;- lien(n) conteun(lienEnt) &lt;- 5 afficher(n)Finint *lienEnt,nlienEnt = &amp;n;*lienEnt = 5;cout&lt;&lt;n; [?] ne transmettre que la valeur de la variable: utiliser le passage par valeur modifier la valeur originale de la variable: utiliser le passage en partage TD3_Swap 1234567Variables Entier cDébut c &lt;- a a &lt;- b b &lt;- cFin TD3_Swap+lien+struct 12345678910111213141516fonction creerArticleproblème : création d'un novel articleapecification: fonction: Lien Article &lt;- creerArticle(r,n,p) paramètres: Entier r, VectCar n , Réel p résultats: Lien Article 1A Variables Lien Article 1ADébut 1A &lt;- nouveau() contenu(1A).reference &lt;- r contenu(1A).nom &lt;- n contenu(1A).prix &lt;- p renvoyer 1AFin 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/21/ALGPR-3/"},{"title":"CCUBE_Chapitre1","text":"序 CCUBE: C3{C^3}C3 est capteurs, contrôle, commande Chapitre_0:Préface et Objectifs Préface Objectifs et moyens 教学目标： — échantillonner un signal 信号采样; — en faire une analyse de Fourier 傅里叶分析; — modéliser un système physique continu par le langage des fonctions de transfert 用transfert函数给系统建模; — modéliser un système physique continu par le langage de l’espace d’état 用l’’espace d’état给系统建模; — lier les phénomènes physiques aux paramètres de ces représentations (temps de réponse, stabilité) ; — interfacer le temps continu et le temps discret(离散) ; — simuler(模拟) ces représentations à l’aide de logiciels adaptés. TP 使用Matlab的Simulink完成： 1.la reconstruction d’une partition à partir de l’enregistrement audio-phonique ; 2.le pilotage en simulation d’une navette spatiale, version très simplifiée d’un contrat avec l’agence spatiale 前置数学知识 — les nombres complexes 复数; — la dérivation et l’intégration d’une fonction d’une variable réelle（？） à valeur réelle（？） 积分求导; — les suites de nombres réels ou complexes ; on n’a pas à craindre les quelques calculs élémentaires de séries ; — le calcul matriciel 矩阵 ; — les valeurs et vecteurs propres, la diagonalisation d’une matrice carrée特征值； —LTI linéaire temporellement invariant线性时间不变 Chapitre1:Concepts et outils fondamentaux 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/04/CCUBE-01/"},{"title":"ALGPR-4","text":"序 关于算法的第四周 TD Listes chainées En utilisant une structure de liste chainée dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: afficher les éléments de liste(打印) ajouter un éléments à la fin de la liste(增) rechercher une valeur avec renvoi du nombre de valeurs présentes dans la liste(查) 1234567891011types elementSimplementChiane: Enregistrement type valeur, lien elementSimplementChiane suivant Fin_Enregistrementtypes elementEntier: Enregistrement type valeur lien elementSimplementChiane suivant Fin_Enregistrement Afficher 12345678910111213141516Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementafficherElement(Lien ElementEntier début)paramètre: Lien sur ElementEntierresultat: videDébut si(début non vide) alors écrire(début -&gt; valeur)//也可以写成contenu(début).valeur afficherElement(début -&gt; suivant)//contenu(début).suivant finsiFin Ajouter 1234567891011121314151617Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementajoutFin(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors contenu(début).suivant &lt;- ajoutFin(contenu(début).suivant,val) sinon contenu(début).valeur &lt;- val; contenu(début).suivant &lt;- NULL; finsi renvoyer débutFin Rechercher 12345678910111213141516171819Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementrechercheNbVal(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors si(contenu(début).valeur = val) nb &lt;- nb+1 finsi nb &lt;- nb+rechercheNbVal(contenu(début).suivant,val) sinon nb&lt;-0 finsi renvoyer débutFin Liste doublement chainées En utilisant une structure de liste doublement chainées dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: ajouter un éléments à la bonne place dans une liste triée, supprimer un élément dont la valeur est donnée en paramètre. 123456Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement Ajouter 123456789101112131415161718192021222324252627282930Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement ajoutTrié(Lien ElementEntier début, Entier val)Variable: Lien ElementEntierDbl tmpDébut si(début n'est pas vide) alors si(val &lt; contenu(début).valeur) tmp &lt;- noveau() contenu(tmp).valeur &lt;- val //insère contenu(tmp).suivant &lt;- début contenu(tmp).précrédent &lt;- contenu(début).précrédent contenu(début).précrédent &lt;- tmp début &lt;- tmp sinon contenu(début).suivant &lt;- ajoutTrié(contenu(début).suivant,val) finsi sinon début &lt;- noveau() contenu(début).valeur &lt;- val finsi renvoyer débutFin Arbres binaires 12345Type NoeudArbreBinaire: Enregistrement type valeur, lien NoeudArbreBinaire fg, lien NoeudArbreBinaire fd,Fin_enregistrement Fonction parcoursPréfixe 123456789Début afficher(racine -&gt; valeur) si racine -&gt; fg non vide alors parcoursPréfixe(racine-&gt;fg) fin_si si racine -&gt; fd non vide alors parcoursPréfixe(racine-&gt;fd) fin_siFin Recherche 12345678910111213141516171819202122Booleen &lt;- existe(lien NoeudEntier noeud, Entier val)Début si(noeud n'est pas vide) alors renvoyer FAUX sinon si(noeud.valeur = val) alors renvoyer VRAI sinon renvoyer existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val)//注意这里一定是ou fin_si fin_siFin另一种写法Début si(noeud is not vide) alors renvoyer FAUX sinon renvoyer (noeud.valeur = val) OU existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val) fin_siFin Supprime[] 1234567891011121314lien NoeudEntier &lt;- supprimeFeuille(lien NoeudEntier, Entier val)efface()、nouveau()Début si(noeud is not vide) alors si(noeud.fg = vide ET noeud.fd = vide ET noeud.valeur = val) efface(noeud) sinon noeud.fg &lt;- supprimeFeuille(noeud.fg , val) noeud.fd &lt;- supprimeFeuille(noeud.fd , val) fin_si fin_si renvoyer noeudFin Ajouter Haute 123456789101112Entier &lt;- hauteur(lien NoeudEntier noeud)Début variable: entier g,d=0//放这里吗？？？？是的 si(noeud.fg is not vide) alors g &lt;- hauteur(noeud.fg) finsi si(noeud.fd is not vide) alors d &lt;- hauteur(noeud.fd) finsi h &lt;- 1+ max(g,d) renvoyer hFin ajouter dans la branche la plus courte d’un arbre une valeur passée en paramètre(在树的最短分支上添加一个参数中传递的值) 12345678910111213141516//[用树高来判断存在问题]---&gt;树的最小深度问题lien NoeudEntier &lt;- ajoutHtMin(lien NoeudEntier noeud, Entier val)Début si(noeud is not vide) alors si(hauteur(noeud-&gt;fg) &lt; hauteur(noeud-&gt;fd)) noeud.fg &lt;- ajoutHtMin(noeud-&gt;fg, val) sinon noeud.fd &lt;- ajoutHtMin(noeud-&gt;fd, val) sinon nouveau.valeur &lt;- val nouveau.fg &lt;- NULL nouveau.fd &lt;- NULL noeud &lt;- nouveau() finsi renvoyer noeudFin Arbres binaires de recherche(ABR): enracinement Définition : Un ABR est un arbre dont les valeurs des noeuds appartiennent à un ensemble totalement ordonné et les conditions équivalentes suivantes sont vérifiées: ​ La liste des valeurs en ordre infixe est croissante ​ Pour tout noeud x de valeur v, les valeurs des noeuds de la branche gauche de x sont inférieures ou égales à v et les valeurs des noeuds de la branche droite de x sont surpérieures ou égales à v (左节点要小于根节点，右节点要大于根结点) 二叉查找树的查找会更快 Verification constituer 用parcoursInfixe()创建//中序 inferieur, superieur(), abr()//都是布尔型函数 1234567891011121314151617181920specification: fonction: super &lt;- superieur(racine , x) parametres: lien NoeudArbreBinaire racine, Entier x resultat: booleenDebutvariables locales booleen b &lt;- (x &gt;= racine-&gt;valeur) choix selon (racine-&gt;fg != NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fg , x) et superieur(racine-&gt;fd , x) et b (racine-&gt;fg != NULL et racine-&gt;fd = NULL): renvoyer superieur(racine-&gt;fg , x) et b (racine-&gt;fg = NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fd , x) et b (racine-&gt;fg = NULL et racine-&gt;fd = NULL): renvoyer b fin_choix_selonFin CM 真后悔，没去 待补 看了一眼，大概c++的语法。好耶！","link":"/2022/02/28/ALGPR-4/"},{"title":"ALGORITHM-期末","text":"期末实验汇总 西南交通大学算法实验期末题型汇总 凸包问题 蛮力法 文字描述 找所有构成凸包的点 对由n个点构成的集合S中每两个点进行遍历，判断这两点是否能构成凸多边形的边。如果能，则将这两点的标志位flag置位1。具体判断方法为：集合S内的所有点都在这两个点构成边的同一侧。(一侧的判断由ax+by&gt;=c的点的个数为n-2或0完成) （以凸包内一点）用的斜率反推角度进行逆时针排序 说明：本算法中因输入设置为当x0&amp;&amp;y0时停止输入，因此在选择计算凸包边界各点的斜率的原点时选用(0,0)。 角度求解（由于atanx的范围为-π/2到π/2，但a的实际范围为-π到π，因此在求角度时要进行不同情况的判断计算）： ​ x = 0 ：y &gt; 0 时，a = π / 2；y &lt; 0 时，a = - π / 2 ; ​ a = atan(y / x) : 第一象限 x&gt;0,y&gt;0 :a = a;第二象限：x&lt;0,y&gt;0,a= a +π；第三象限：x&lt;0,y&lt;0,a= a +π；第四象限：x&gt;0,y&lt;0,a= a +2π 排序:用algorithm库封装的sort函数用每个点的角度信息对点进行快排，输出并压入数组Q。 计算凸包边长 依次计算数组Q中相邻点的距离，即distance(p[i],p[i+1])，注意加上首尾即distance(p[0],p[n-1])求得周长。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;#define M 10#define PI 3.1415926struct Point { int x; int y; int flag = 0; double a = 0;};Point Q[M];void print(Point P[], int n){ int k = 0; cout &lt;&lt; &quot;凸包的顺序输出为：&quot;; for (int i = 0; i &lt; n; i++ ) { if (P[i].flag) { Q[k] = P[i]; cout &lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt; &quot;(&quot; &lt;&lt; Q[k].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[k].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; k++; } } cout &lt;&lt; endl;}//自己定义的排序规则:按角度排int comp(const Point&amp; p_1, const Point&amp; p_2) { return p_1.a &lt; p_2.a;}//使其按逆时排列void sortP(Point P[], int n){ for (int i = 0; i &lt; n; i++) { if (!P[i].x) { if(P[i].y &lt; 0) P[i].a = 3.0*PI / 2.0; else P[i].a = PI / 2.0; } else { P[i].a = atan((double)P[i].y / P[i].x); //一象限不变 if (!P[i].y) if (P[i].x &lt; 0) P[i].a = PI;//0和PI的判断 else if (P[i].a * P[i].y &lt; 0) P[i].a += PI;//二、三象限加PI else {//四象限加2*PI if (P[i].y &lt; 0)P[i].a += 2 * PI; } } } sort(P , P+n , comp);//按序排 print(P, n);}//检查点在不在线一侧bool OneSide(Point P[], int n ,int a , int b ,int c){ int sign_1 = 0, sign_2 = 0; for (int k = 0; k &lt; n; k++) { if (a * P[k].x + b * P[k].y == c) { ++sign_1; ++sign_2; } if (a * P[k].x + b * P[k].y &gt; c) ++sign_1; if (a * P[k].x + b * P[k].y &lt; c) ++sign_2; } if (sign_1 == n || sign_2 == n) return 1; return 0;}void ConvexHull(Point P[] ,int n){ int k = 0; for (int i = 0; i &lt; n; ++i) { for (int j = i + 1; j &lt; n; ++j) { int a = P[j].y - P[i].y; int b = P[i].x - P[j].x; int c = P[i].x * P[j].y - P[i].y * P[j].x; if (OneSide(P, n, a, b, c)){ P[i].flag = 1; P[j].flag = 1; } } } sortP(P, n);//打印}double distance(const Point&amp; p_1 , const Point&amp; p_2){ return sqrt((p_1.x - p_2.x)* (p_1.x - p_2.x) + (p_1.y - p_2.y) * (p_1.y - p_2.y));}//计算凸包的边长double c_ConvexHull(int n){ double sum = 0; for (int i = 0 ; i &lt; n-1 ; i++) { // cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[i].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[i].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; sum += distance(Q[i], Q[i + 1]); } //首尾 sum += distance(Q[0], Q[n-1]); return sum;}int main(){ Point P[M]; int i=0; cout &lt;&lt; &quot;输入点集：&quot;; for (; i &lt; M; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (!x &amp;&amp; !y)break; P[i].x = x; P[i].y = y; } ConvexHull(P, i); cout &lt;&lt; &quot;凸包周长是：&quot; &lt;&lt; c_ConvexHull(i-1); return 0;} Gramph算法 文字描述 总体思路：先找到凸包上的一个点，然后从该点开始有方向的逐个寻找凸包上的点。 1.点集中纵坐标最小的点一定是凸包上的点，将其作为原点P0，重新求解点集S 2.计算点集中所有点相对于P0的幅角a，对其排序。a相同时，距离小的排在前面。P0、p1入栈。 3.连接P0和栈顶的点，得到直线L。看p1后面的点（即p2,计作当前点）是在直线L的右边还是左边。如果在直线的右边就执行步骤4；如果在直线的左边（上）就执行步骤5。 4.如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤3。 5.当前点是凸包上的点，把它压入栈，执行步骤6。 6.检查P2是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把P2后面那个点做当前点，返回步骤3。 最终栈中为凸包各点的按序存储 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define M 10struct Point{ double x, y;};Point P[M];//inoutPoint Q[M];//outputdouble distance(const Point&amp; p_1, const Point&amp; p_2)//距离{ return sqrt((p_2.x - p_1.x) * (p_2.x - p_1.x) + (p_2.y - p_1.y) * (p_2.y - p_1.y));}double x(const Point&amp; p_1, const Point&amp; p_2, const Point&amp; p_3)//叉积公式{ return (p_2.x - p_1.x) * (p_3.y - p_1.y) - (p_3.x - p_1.x) * (p_2.y - p_1.y);}bool cmp(const Point&amp; p_1, const Point&amp; p_2)//极角排序{ double pp = x(p_1, p_2, P[0]); if (pp &gt; 0) return true; if (pp &lt; 0) return false; return distance(P[0], p_1) &lt; distance(P[0], p_2);}int Graham(int n)//Graham算法{ int k = 0; for (int i = 1; i &lt; n; i++) { if (P[i].y &lt; P[k].y || (P[i].y == P[k].y &amp;&amp; P[i].x &lt; P[k].x)) k = i; } swap(P[0], P[k]); sort(P + 1, P + n, cmp); int top = 2; Q[0] = P[0], Q[1] = P[1]; for (int i = 2; i &lt; n; i++) { //去共线 while (top &gt; 1 &amp;&amp; x(Q[top - 2], Q[top - 1], P[i]) &lt;= 0) top--; Q[top++] = P[i]; } return top;}void show(int n){ for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[i].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[i].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; endl;}double sum(int n){ double sum = 0; for (int i = 0; i &lt; n - 1; i++) sum += distance(Q[i], Q[i + 1]); sum += distance(Q[0], Q[n - 1]);//首尾 return sum;}int main(){ int i = 0; cout &lt;&lt; &quot;输入点集：&quot;; for (; i &lt; M; i++){ int x, y; cin &gt;&gt; x&gt;&gt; y; if (!x &amp;&amp; !y)break; P[i].x = x; P[i].y = y; } int a = Graham(i); cout &lt;&lt; &quot;凸包是：&quot; ;show(a); cout &lt;&lt; &quot;凸包周长是：&quot;&lt;&lt; sum(a); return 1;} 动态规划 文字描述 无 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define PI 3.1415926#define M 10struct Point{ int x, y; double a = 0;};Point P[M];//inputPoint Q[M];//outputint book[M];//标记点// 计算三角形面积int area_t(Point p1, Point p2, Point pi){ return p1.x*p2.y + pi.x*p1.y + p2.x*pi.y - pi.x*p2.y - p2.x*p1.y - p1.x*pi.y;}//角度排int comp(const Point&amp; p_1, const Point&amp; p_2){ return p_1.a &lt; p_2.a;}//横坐标bool cmp(const Point&amp; p1, const Point&amp; p2){ if(p1.x==p2.x) return p1.y&lt;p2.y; return p1.x&lt;p2.x;}void print(Point P[], int n){ int k = 0; cout &lt;&lt;&quot;relusts:&quot;; for (int i = 0; i &lt; n; i++ ) { if (book[i]) { Q[k] = P[i]; cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[k].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[k].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; k++; } } cout &lt;&lt; endl;}//使其按逆时排列void mysort_P(Point *P, int n){ for (int i = 0; i &lt; n; i++) { if (!P[i].x) { if(P[i].y &lt; 0) P[i].a = 3.0*PI / 2.0; else P[i].a = PI / 2.0; } else { P[i].a = atan((double)P[i].y / P[i].x); //一象限不变 if (!P[i].y) if (P[i].x &lt; 0) P[i].a = PI;//0和PI的判断 else if (P[i].a * P[i].y &lt; 0) P[i].a += PI;//二、三象限加PI else {//四象限加2*PI if (P[i].y &lt; 0)P[i].a += 2 * PI; } } } sort(P , P+n , comp);//按序排 print(P, n);}// 递归求凸包// ps 是当前要求解的点的集合，ps保存这些点在points数组中的下标// mode 表示递归s1 s2，还是递归s3，s4，还是同时递归 s1，s2，s3，s4// mode = 3 递归 s1，s2，s3，s4，只有第一次调用会出现该情况// mode = 2 递归s3，s4// mode = 1 递归s1 s2void ConvexHull(vector&lt;int&gt; &amp;ps, int mode){ // 边界处理：少于两个点的集合一定是凸包上的点 if(ps.size()&lt;=2) { for(int i=0; i&lt;ps.size(); i++) book[ps[i]]=1; return; } // 最左右一定是凸包上的点， pa最左点，pb最右点 book[ps.front()]=1, book[ps.back()]=1; Point pa=P[ps.front()], pb=P[ps.back()]; // 找距离 pa，pb组成的直线最远的点，imax是上方最远，imin是下方最远 int maxs=INT_MIN, mins=INT_MAX, imax=-1, imin=-1; for(int i=1; i&lt;ps.size()-1; i++) { int s = area_t(pa, pb, P[ps[i]]); if(s&gt;maxs &amp;&amp; s&gt;=0) maxs=s, imax=ps[i]; if(s&lt;mins &amp;&amp; s&lt;=0) mins=s, imin=ps[i]; } // pa,pb与imax，imin的连线，分割出下一趟递归的点集合 s1 s2 s3 s4 vector&lt;int&gt; s1, s2, s3, s4; for(int i=0; i&lt;ps.size()-1; i++) { if(area_t(pa, P[imax], P[ps[i]]) &gt;= 0) s1.push_back(ps[i]); if(area_t(pa, P[imin], P[ps[i]]) &lt;= 0) s3.push_back(ps[i]); } for(int i=1; i&lt;ps.size(); i++) { if(area_t(P[imax], pb, P[ps[i]]) &gt;= 0) s2.push_back(ps[i]); if(area_t(P[imin], pb, P[ps[i]]) &lt;= 0) s4.push_back(ps[i]); } if(mode==3) ConvexHull(s1, 1), ConvexHull(s2, 1), ConvexHull(s3, 2), ConvexHull(s4, 2); else if(mode==1) ConvexHull(s1, 1), ConvexHull(s2, 1); else if(mode==2) ConvexHull(s3, 2), ConvexHull(s4, 2);}//计算凸包的面积double s_ConvexHull(int n){ double sum = 0; for (int i = 1 ; i &lt; n-2 ; i++) sum += fabs(area_t(Q[0],Q[i],Q[i+1]))/2; return sum;}int main(){ int n, x, y; cin&gt;&gt;n; vector&lt;int&gt; ps(n); for(int i=0; i&lt;n; i++) { cin &gt;&gt; P[i].x &gt;&gt; P[i].y; ps[i]=i; } sort(P, P + n, cmp); ConvexHull(ps, 3); mysort_P(P, n); cout&lt;&lt;&quot;ConvexHull's area is:&quot;&lt;&lt;s_ConvexHull(n); return 0;} 背包问题 蛮力法 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define M 20int max_value = 0;int max_weight = 0;int max_a[M];int k = 0;void print(int n){ sort(max_a , max_a + n); cout &lt;&lt; &quot;获胜者所选取的商品编号为：&quot;; for (int i = 0 ; i &lt; n ;i++) cout &lt;&lt; max_a[i]&lt;&lt;&quot;\\t&quot;; cout &lt;&lt; endl&lt;&lt;&quot;获胜者所能选取的商品的总重量和总的价格为：&quot; &lt;&lt; max_weight&lt;&lt;&quot;\\t&quot;&lt;&lt;max_value &lt;&lt; endl;}void sum(int a[] ,int n , int m , int object[M][2]){ int value = 0; int weight = 0; int i = 0; for (; i &lt; n+1; i++) { if (weight &gt; m)break; weight += object[a[i] - 1][0]; value += object[a[i] - 1][1]; } k = i; value = value - object[a[i - 1] - 1][1]; weight = weight - object[a[i - 1] - 1][0]; if (value &gt; max_value){ max_value = value; max_weight = weight; for (int j = 0; j &lt; i-1; j++) max_a[j] = a[j]; }}void Prem(int a[] , int start , int end , int m, int object[M][2]){ if (start == end)sum(a,end+1,m,object);//递归结束条件 else { for (int i = start; i &lt;= end; i++) { swap(a[start], a[i]);//全排列时start的后位依次做第一位 Prem(a, start + 1, end , m , object); swap(a[start], a[i]);//换回来才能保证下一次交换 } }}int main(){ int m, n; int a[M]; cout &lt;&lt; &quot;输入商场中商品的数量:&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;输入小车能装载的最大装载量:&quot;;cin &gt;&gt; m; for (int i = 0; i &lt; n; i++) a[i] = i + 1; int object[M][2]; cout &lt;&lt; &quot;输入每种商品的重量和价格:&quot;&lt;&lt;endl; for (int i = 0 ; i &lt; n ; i++) for (int j = 0; j &lt; 2; j++) cin&gt;&gt;object[i][j]; Prem(a,0, n-1 , m , object);//寻找各种可能结果 print(k);//打印 return 1;} TSP旅行商问题 蛮力法 文字描述 无 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;#define M 20int MIN = 1000;//用于计算最短路径int min_a[M];//用于保存最短路径编号void print(int n){ cout &lt;&lt; &quot;最短路径为：&quot;; for (int i = 0; i &lt; n; i++)cout &lt;&lt; min_a[i] &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;这条路长：&quot; &lt;&lt; MIN;}void sum(int a[] , int d[M][M] ,int n , int m){ int sum = d[m-1][a[0]-1]; for (int i = 0; i &lt; n; i++){ if (i == n - 1) sum += d[a[i]-1][m-1]; else sum += d[a[i]-1][a[i + 1]-1]; } if (sum &lt; MIN){ MIN = sum; for (int i = 1; i &lt; n+1; i++) min_a[i] = a[i-1]; }}//全排列void Prem(int a[] , int d[M][M] , int start , int end , int m){ if (start == end)sum(a,d,end+1,m);//递归结束条件 else { for (int i = start; i &lt;= end; i++) { swap(a[start], a[i]);//全排列时start的后位依次做第一位 Prem(a, d ,start + 1, end ,m); swap(a[start], a[i]);//换回来才能保证下一次交换 } }}int main(){ int n, m; int a[M],d[M][M]; cout &lt;&lt; &quot;输入待旅行的城市数量:&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;输入旅行者出发的城市编号:&quot;;cin &gt;&gt; m; for (int i = 0 ; i &lt; n-1 ;i++){ a[i] = i + 1; if (a[i] &gt; m-1)a[i] = i+2; } cout &lt;&lt; &quot;输入城市之间的距离：&quot;&lt;&lt;endl; for (int i = 0 ; i &lt; n ;i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; d[i][j]; min_a[0] = m;min_a[n] = m; Prem(a, d, 0 ,n-2 ,m); print(n+1); return 0;} 动态规划 文字 用邻接矩阵g来表示各城市间的距离，问题可抽象为:从结点s出发，令d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。 当V为空集，那么d(i,V)表示直接从i回到s，此时d(i,V) = g[i][s]。 如果V不为空，那么就是对子问题的最优求解，必须在V这个城市集合中，尝试每一个，并求出最优解。 在求解d(i, V)时，必须在V中找出这样一个结点k，它满足(从i到k的距离 + 从k出发经过 V-(k)这个集合回到s)是V的所有结点中最小的。 可得出状态转移方程：d(i,V) = min(g[i][k] + d(k,V–(k)))，其中k代表遍历当前V集合中所有的城市。 综上，可得出动态规划方程： ![img](file:///C:/Users/NILI99~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png) 其中s为起点。 用代码实现时，由于V的状态有很多种，因此考虑采用状态压缩的办法表示V，即用数的二进制状态来表示V，第i个二进制位为0就代表V中没有i，为1则代表有。例如(5)D = (101)B, 代表V中的城市有0和2，而没有1，(7)D = (111)B, 代表V中的城市有0、1、2。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define INF 10e7int n, m;//保存顶点i到状态s最后回到起始点的最小距离int dp[10001][10001];//核心函数，求出动态规划dp数组void TSP(int **a){ //初始化dp[i][0] for (int i = 0; i &lt; n; i++) { dp[i][0] = a[i][0]; } //求解dp[i][j],先跟新列在更新行 for (int j = 1; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { dp[i][j] = INF; //如果集和j(或状态j)中包含结点i,则不符合条件退出 if (((j &gt;&gt; (i - 1)) &amp; 1) == 1) { continue; } for (int k = 1; k &lt; n; k++) { if (((j &gt;&gt; (k - 1)) &amp; 1) == 0) { continue; } if (dp[i][j] &gt; a[i][k] + dp[k][j ^ (1 &lt;&lt; (k - 1))]) { dp[i][j] = a[i][k] + dp[k][j ^ (1 &lt;&lt; (k - 1))]; } } } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); int** a,bestc; cin &gt;&gt; n; a = new int* [n + 1]; for (int i = 0; i &lt;= n; i++) a[i] = new int[n + 1]; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) { cin &gt;&gt; a[i][j]; a[j][i] = a[i][j]; } for (int i = 0; i &lt; n; i++) a[i][i] = 0; m = 1 &lt;&lt; (n - 1); TSP(a); cout &lt;&lt; &quot;TSP: &quot; &lt;&lt; dp[0][m - 1] &lt;&lt; endl; fclose(stdin); return 0;} 因子分解 分治法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;math.h&gt;#define M 10using namespace std;int a[M];int i,m;void show(int n){ int i = 0; cout&lt;&lt;n&lt;&lt;&quot; = &quot;&lt;&lt;a[i++]; while(a[i]){ cout&lt;&lt;&quot; * &quot;&lt;&lt;a[i]; a[i++] = 0; } cout&lt;&lt;endl;}void fun(int x,int b){ if(x == 1 &amp;&amp; a[0])//递归退出 { show(m); return; } int y = 2; while(y &lt;= x) { if(!(x%y)){ a[b] = y; fun(x/y,b+1); } y++; }}int main(){ int n; cin&gt;&gt;n; m = n; fun(n,0); return 0;} 格雷码 分治法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;#define N 10int a[N][N];void show(int n){ for(int i = 0 ; i &lt; pow(2,n) ; i++) { for(int j = 0 ; j &lt; n ; j++) cout&lt;&lt;a[i][j]; cout&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}void Gray(int n){ if(n==1) //退出递归 { a[0][0] = 0;a[1][0] = 1; return; } int m = pow(2,n); for(int i=0; i&lt;m/2; i++) { a[i][n-1] = 0;//第一排为0 a[m-i-1][n-1] = 1; //第二排为1 } Gray(n-1); //格雷码拼接操作 for(int i=m/2; i&lt;m; i++) for(int j=0; j&lt;n-1; j++) a[i][j] = a[m-i-1][j];}int main(){ int n; cin&gt;&gt;n; Gray(n); show(n); return 0;} 最大子矩阵 动态规划 文字描述 采用自顶向下的思想进行递推。从初始的m x n矩阵开始，对矩阵进行求和，并与不同方向的m x (n-1)和(m-1) x n 矩阵进行递推和比较，在寻找过程中设置book数组保存访问状态和子矩阵的和，最终返回最大值。 阶段：当前子矩阵的左上角坐标为start_x, start_y 状态：当前子矩阵的size为m x n 阶段目标：book[a[start_x][ start_y],m,n]表示当前的值,为左上角坐标为start_x,start_y的m x n矩阵的最大的子矩阵和。 状态转移方程:book[a[start_x][ start_y],m,n] = max{ book[a[start_x][ start_y],m,n],book[a[start_x][ start_y],m-1,n],book[a[start_x+1][ start_y],m-1,n], book[a[start_x][ start_y],m,n-1],book[a[start_x][ start_y+1],m,n-1]} 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int row,col;int a[105][105];struct Books{ int sum; int flag=0;}book[105];int fun(int start_x,int start_y,int m , int n){ if(!m||!n||start_x+m&gt;row||start_y+n&gt;col) return 0; if(m==1 &amp;&amp; n == 1 ) return a[start_x][start_y]; if(book[a[start_x][start_y]+10*m+100*n].flag==1) return book[a[start_x][start_y]+10*m+100*n].sum; int temp_sum=0; for(int i = start_x ; i &lt; start_x+m ; i++) for(int j = start_y ; j &lt; start_y+n ; j++) temp_sum += a[i][j]; book[a[start_x][start_y]+10*m+100*n].sum = temp_sum; book[a[start_x][start_y]+10*m+100*n].flag=1; return max({temp_sum, fun(start_x+1,start_y,m-1,n), fun(start_x,start_y,m-1,n), fun(start_x,start_y,m,n-1), fun(start_x,start_y+1,m,n-1)});}int main() { cout&lt;&lt;&quot;input row,col: &quot;; cin &gt;&gt; row &gt;&gt; col; for(int i = 0; i &lt; row ; i++) for(int j = 0 ; j &lt; col ; j++) cin&gt;&gt;a[i][j]; cout &lt;&lt; &quot;max:&quot; &lt;&lt; fun(0, 0, row, col) &lt;&lt; endl; return 0;} 数字三角形 动态规划 文字描述 先根据元素个数填充三角形，行数为求解T=n*(n+1)/2的向上取整结果。若不能构成完整的数字三角形，空位补0。 行数为 n的三角形路径之和的最大值，可看做行数为n-1的三角形路径之和的最大值加上顶层。先求出第n-1阶段(第n-1行上各点)到第n行的最大和，再依次求出第n-2阶段、第n-3阶段……第1阶段(起始点)各决策点至第n行的最佳路径。按照自底向上的思想编写代码。 阶段：当前所在塔的层数i 状态：当前所在某层的位置j 阶段目标：f[i,j]表示当前的值,为从第i阶段中的点j至第n行的最大的数字和。 状态转移方程：f[i][j]=f[i][j]+max(f[i+1][j],f[i+1][j+1]) ​ 图示分析： n=5 9+max(50,49)=59 n=4 12+max(38,34)=50 15+max(34,29)=49 n=3 10+max(21,28)=38 6+max(28,19)=34 8+max(19,21)=29 n=2 2+max(19,7)=21 18+max(7,10)=28 9+max(10,4)=19 5+max(4,16)=21 n=1 19 7 10 4 16 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &quot;math.h&quot;using namespace std;int dp[105][105];//动规矩阵，存放每次结果int main() { int T;//T表示元素个数 cin&gt;&gt;T; int n;//n表示层数 n = ceil((sqrt(1+8*T)-1)/2.0); cout&lt;&lt;&quot;n: &quot;&lt;&lt;n&lt;&lt;endl; int k = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cin &gt;&gt; dp[i][j]; k++; if(k&gt;T) break; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } //自底向上动态规划 for (int i = n - 1; i &gt;= 1; i--) { for (int j = 1; j &lt;= i; j++) { dp[i][j] += max(dp[i + 1][j], dp[i + 1][j + 1]); } } cout&lt;&lt;&quot;dp is &quot;&lt;&lt;endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cout&lt;&lt;&quot;max : &quot;&lt;&lt;dp[1][1]&lt;&lt;endl; return 0;} 最长递增子序列 动态规划 文字描述 算法思想： 阶段：当前子序列长度为i 阶段目标：L[i]表示当前序列的最长递增子序列长少-1（L[i]初始值为0） 状态转移方程:if(a[i]&gt;a[j])then L[i]=max{L[j]}+1(j:1ài)，否则L[i]值不变。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int max_long=-9999;int dp_long[105];void find_long(int a[], int n){ for (int i = 0; i &lt; n; i++){ for (int j = 0; j &lt; i; j++) { if (a[i] &gt; a[j] &amp;&amp; dp_long[i] &lt; dp_long[j] + 1) dp_long[i] = dp_long[j] + 1; } } for (int i = 0; i &lt; n; i++) { if (dp_long[i] &gt; max_long) max_long = dp_long[i]; }}int main(){ int n; cin&gt;&gt;n; int a[105]; for(int i = 0 ; i &lt; n ;i++) cin&gt;&gt;a[i]; find_long(a,n); cout &lt;&lt; max_long+1 &lt;&lt; endl; return 0;} 图结点着色 回溯 文字描述 该题实质为图结点的着色问题。可以具体抽象为：输入无向连通图的各节点和其连接的点，找一种需要最少颜色的着色法使图中每条边的2个顶点着不同颜色。 输入设计：关键在于从字符串到邻接矩阵的转换。先使用s.erase(s.find('😂,1)去除字符串的”:”,然后使用if(s[j]&amp;&amp;(s[j]-s[0]))c[i][s[j]-s[0]+i]=1 的判断语句转换成邻接矩阵。 回溯设计：在图着色问题的解空间树中，如果从根结点到当前结点对应一个部分解，也就是所有的颜色指派都没有冲突，则在当前结点处选择第一棵子树继续搜索，也就是为下一个顶点着颜色1，否则，对当前子树的兄弟子树继续搜索，也就是为当前顶点着下一个颜色，如果所有m种颜色都已尝试过并且都发生冲突，则回溯到当前结点的父结点处，上一个顶点的颜色改变，以此类推。具体描述： 1.将数组color[n]初始化为0并令k=1; 2.while(k&gt;=1)：a)依次考察每一种颜色，若顶点k的着色与其他顶点的着色不发生冲突，则转步骤b；否则，搜索下一个颜色；b)若顶点已全部着色，则输出数组color[n]，返回。c)若顶点k是一个合法着色，则k=k+1,处理下一个顶点；否则，重置顶点k的着色情况，k=k-1，转步骤c）。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &quot;algorithm&quot;using namespace std;int n;//城市数int m;//当前着色数int c[10][10];int color[10];int ok(int k){ int i; for(i=0;i&lt;k;i++) if(c[k][i]==1&amp;&amp;color[i]==color[k]) return 0; return 1;}//法1void GraphColor(int n){ int i,k; for(i=0;i&lt;n;i++)color[i]=0; k=0; while(k&gt;=0) { color[k]=color[k]+1; while(color[k]&lt;=n) { if(ok(k)==1)break; else color[k]=color[k]+1; } //深度到n,着色完全 if(color[k]&lt;=n&amp;&amp;k==n) { sort(color,color+n); cout&lt;&lt;color[n-1]&lt;&lt;endl; return; } //深度不到n，节点下移 else if(color[k]&lt;=n&amp;&amp;k&lt;n)k=k+1; //回溯，着色未完全,返回父节点 else { color[k]=0; k=k-1; } }}//法2void dfs(int step){ if(step==n)//着色数=城市数 { sort(color,color+n); cout&lt;&lt;color[n-1]&lt;&lt;endl; exit(0); } else { for(int i=0;i&lt;n;i++) { color[step]=i+1; if(ok(step))dfs(step+1); color[step]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n; string s; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s; s.erase(s.find(':'),1); for(int j=0;j&lt;n;j++) { if(s[j]&amp;&amp;(s[j]-s[0]))c[i][s[j]-s[0]+i]=1; } }// for(int i=0;i&lt;n;i++)// {// for(int j=0;j&lt;n;j++)// cout&lt;&lt;c[i][j]&lt;&lt;&quot; &quot;;// cout&lt;&lt;endl;// } // GraphColor(n); dfs(0); fclose(stdin); return 0;} 集合找和为C 文字描述 回溯设计： 目标函数：sum+=out[k],sum=t&amp;k=n；约束条件：sum&lt;t，k&lt;n；限界函数：sum&lt;t,k&lt;n 具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件： sum&lt;t&amp;k&lt;n，继续dfs到下一层 sum=t&amp;k=n，输出 sum&gt;t||k&gt;n，进行剪枝并回溯到上一层。 去除重复输出设计:将每次回溯所得的结果存入二维数组out_comp中，其中i表示结果序号，即存回溯得到的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &quot;algorithm&quot;using namespace std;int c,n;vector&lt;int&gt; s;//inputint sum,k,out[10000],book[10000];int out_comp[10000][10000];//去重复int num;//记录解个数//去重复结果bool fun_row(int *a, int *b){ for(int i=0;i&lt;n;i++) if(a[i] != b[i]) return false; return true;}bool fun(){ for(int p=0;p&lt;10000;p++) if(fun_row(out, out_comp[p]))return true; return false;}void output(){ int n=0,m=0; if(!fun())//输出不重复的结果 { while (out[n]) { cout&lt;&lt;out[n]&lt;&lt;&quot; &quot;; out_comp[num][m] = out[n]; m++;n++; } num++; cout &lt;&lt; endl; } return;}void backtrack(int step){ if(sum == c &amp;&amp; k== n) { output(); return; } if(sum&gt;c || k&gt;n) return; for(int i=0;i&lt;s.size();i++) { if(!book[i] &amp;&amp; (s[i]&lt;=out[k-1]||k==0)) { //存入out out[k]=s[i]; sum+=out[k]; book[i]=1; k++; //向下dfs backtrack(step+1); //回退 k--; sum-=out[k]; book[i]=0; out[k]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;c&gt;&gt;n; if(n&lt;0||n&gt;10000) { cout&lt;&lt;&quot;worry input n!&quot;&lt;&lt;endl; return 0; } int temp; while(cin&gt;&gt;temp)s.push_back(temp); sort(s.begin(),s.end(),greater&lt;int&gt;()); backtrack(0); if(!num) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; fclose(stdin); return 0;} 构成最小倍数 分支界限 文字描述 本题主要采用了BFS(广度优先搜索)+剪枝回溯的思路编写程序。主要使用了数组来存m位不同的十进制数字，使用队列来进行BFS的搜索的数据结构类型。为找寻最小倍数，先将输入的数组x进行升序排序，因为x数组中的数据可以重复使用，所以每次拓展活结点时，其子节点为x[]中的所有元素。找到则退出，没有找到则继续在该层遍历，然后拓展下一层继续按层寻找。 具体算法设计为：1.先对输入的数据进行判断，若x[i]%n=0，即单位输入的数字即为自然数n的最小倍数，则直接输出，退出程序。2.若没有，则非零元素按大小依次进入队头。3.遍历组合队头元素的每个活结点，out=front*10+x[i]，若out[i]%n=0，代表找到，输出并退出程序，否则，队头元素出队并将out入队作为下一层拓展遍历的活结点。4.若out&gt; pow(2,32)-1,表示查找失败，输出0且退出程序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &quot;algorithm&quot;#include &quot;queue&quot;using namespace std;int n,m,*x;//input__int32 out;queue&lt;int&gt; q;int front;void backtrack()//bfs广度搜索{ for(int i=0;i&lt;m;i++) { if(x[i]) { if(!(x[i]%n)) { cout&lt;&lt;x[i]&lt;&lt;endl; exit(0); } q.push(x[i]); } } while(!q.empty()) { front=q.front(); q.pop(); for(int i=0;i&lt;m;i++) { out=front*10+x[i]; if(!(out%n)) { cout&lt;&lt;out&lt;&lt;endl; exit(0); } if(out&gt;pow(2,32)-1)return ; q.push(out); } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; int i; x=new int[m]; for(i=0;i&lt;m;i++)cin&gt;&gt;x[i]; sort(x,x+m); backtrack(); cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; fclose(stdin); return 0;} 贪心法求解最优服务次序 文字描述 算法思想：利用贪心的思想，优先服务需要时间少的顾客，直到最后。运用到了队列的数据结构。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &quot;vector&quot;#include &lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int wait_pos[101][101];int main(){ freopen(&quot;../input&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; int s; cin&gt;&gt;s; vector&lt;int&gt; t_temp; int temp; while(cin&gt;&gt;temp) t_temp.push_back(temp); sort(t_temp.begin(), t_temp.end(), greater&lt;int&gt;()); queue&lt;int&gt; t; while(!t_temp.empty()) { t.push(t_temp.back()); t_temp.pop_back(); } int j=0; //排位置 while(!t.empty()) { for(int i=0;i&lt;s;i++){ if(t.empty()) break; wait_pos[i][j] = t.front(); t.pop(); } j++; } //找时间并输出 int sum=0; for(int i=0;i&lt;s;i++) { int k=1; cout&lt;&lt;i+1&lt;&lt;&quot;:&quot;&lt;&lt;wait_pos[i][0]&lt;&lt;&quot; &quot;; while(k&lt;j &amp;&amp; wait_pos[i][k]) { cout&lt;&lt;wait_pos[i][k]&lt;&lt;&quot; &quot;; for(int z=0;z&lt;k;z++)sum+=wait_pos[i][z]; k++; } cout&lt;&lt;endl; } cout&lt;&lt;(double)sum/n&lt;&lt;endl; return 0;} 自然数分解积最大问题 文字描述 算法思想：贪心的想使每个分解出来的数尽可能的接近，因此得到的乘积最小。采取的策略：设n的加数为2+3+…+m+k;m为最大加数，k为剩余的数(k&lt;=m)；然后将k分到其他数中，策略就是从m-&gt;2的数值一次加一，直至把k消耗完。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;int a[1000];int main(){ freopen(&quot;../input&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; int sum = 0, m = 0, k; //找最大加数a[m-1] for (int i = 2; i &lt;= n; i++) { a[m++] = i; sum += i; if (sum &gt; n) { sum -= i; m--; k = n - sum;//余数k break; } } //cout&lt;&lt;&quot;a[m-1]:&quot;&lt;&lt;a[m-1]&lt;&lt;&quot;\\t&quot;&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;endl; //消耗余数 for (int i = m - 1; k; k--) { a[i]++; i--; if (i &lt; 0) i = m - 1; } //输出和累乘 int out=1; for (int i = 0; i &lt; m; i++) { cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;; out *= a[i]; } cout&lt;&lt;endl&lt;&lt;out; return 0;} 贪心法最大删除数字问题 文字描述 该算法同样涵盖了贪心算法的思想，根据分析，应当优先清除高位的小数，这样就可以带来局部最优解。所以从最高位开始寻找，从左到右依次遍历s[i]，若s[i]&lt;s[i+1]，则删除s[i]，并且缩短一位即可；若未找到，直接将len=len-1，即删除最后一位，输出即可。根据验证，此方法得到的解即为全局最优解。 最终，标记第一位非0的字符，从该位开始输出，得到的结果即为删除后的最大整数。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 10002int main(){ int k,len,flag,i,j; char s[MAX]={0}; gets(s); len=strlen(s); scanf(&quot;%d&quot;,&amp;k); while(k) { for(i=0;i&lt;len-1;i++) { if(s[i]&lt;s[i+1]) { for(j=i;j&lt;len-1;j++) { s[j]=s[j+1]; } len--; break; } } if(i==len-1) { len--; } k--; } for(i=0;i&lt;len;i++) { if(s[i]!='0') { flag=i; break; } } for(i=flag;i&lt;len;i++) { printf(&quot;%c&quot;,s[i]); } return 0;} 迷宫问题的分支界限 文字 约束条件：箱子没有撞墙、机器人没有撞墙、位置不重复（若重复则代表一定有更少的解决步骤）。程序中将可以走的位置全部用0来代表，不能走的位置用1来代表，因此撞墙的约束条件可用如下式子来判断： if (maze[next.bx][next.by] == 0 //箱子所在位置不是墙 ​ &amp;&amp; maze[next.px][next.py] == 0) //&amp;&amp;人所在位置不是墙 箱子和机器人的位置用一个四维数组来存储，四维分别是箱子和人的行、列下标，则位置不重复的约束条件： if (used[next.bx][next.by][next.px][next.py] == 0) //节点不重复 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAX = 20;char maze[MAX][MAX];struct node{ int px, py; //箱子位置 int bx, by; //人位置 bool useful; //本节点是否有效}; //无效条件：箱子越界、撞墙、节点重复int n, m; //n行m列node start;int tx, ty; //目标位置queue &lt;node&gt; q1;int used[MAX][MAX][MAX][MAX]; //判重数组int step[MAX][MAX][MAX][MAX]; //步数数组int walk[4][2] = //走一步后的新坐标变化{ 0, -1, //左 +1, 0, //下 0, +1, //右 -1, 0 //上};void input();int bfs();node moveto(node cur, int i); //返回人向i方向走一格的新节点int main(){ input(); cout &lt;&lt; bfs() &lt;&lt; endl; return 0;}void input(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin&gt;&gt;maze[i][j]; //将数字按字符读入，再转换成数字 switch (maze[i][j]) { case '#': maze[i][j] = 1; break; case '.': maze[i][j] = 0; break; case 'B': //箱子 { start.bx = i; start.by = j; maze[i][j] = 0; //将此处标记为0，意为“可以走” break; } case 'T': //目标位置 { tx = i; ty = j; maze[i][j] = 0; //同上 break; } case 'S': //人 { start.px = i; start.py = j; maze[i][j] = 0; //同上 break; } default:break; } } } //标记初始节点并入队 used[start.bx][start.by][start.px][start.py] = 1; step[start.bx][start.by][start.px][start.py] = 0; q1.push(start); fclose(stdin);}int bfs(){ node cur, next; while (!q1.empty()) { cur = q1.front(); q1.pop(); for (int i = 0; i &lt; 4; i++) //人向4个方向试探 { next = moveto(cur, i); //返回扩展所得的新节点 if (next.useful) //若该节点有效 { if (next.bx == tx &amp;&amp; next.by == ty) //判断箱子是否到达目标位置 { return step[next.bx][next.by][next.px][next.py]; } else //还未到达，新节点入队 { q1.push(next); } } } } return -1; //无法到达，返回-1}//节点无效条件：箱子或人越界、箱子或人撞墙、节点重复node moveto(node cur, int i){ node next; bool moved = false; //判断箱子是否移动 next.bx = cur.bx; //箱子位置暂时不动 next.by = cur.by; next.px = cur.px + walk[i][0]; //人向i方向移动一格 next.py = cur.py + walk[i][1]; if (next.px == next.bx &amp;&amp; next.py == next.by) //若此时人与箱子位置重叠 { next.bx += walk[i][0]; //那么箱子也要向i方向移动一格 next.by += walk[i][1]; moved = true; } //判断新节点next是否有效 next.useful = false; //初始为无效 if (maze[next.bx][next.by] == 0 //箱子所在位置不是墙 &amp;&amp; maze[next.px][next.py] == 0) //&amp;&amp;人所在位置不是墙 { if (used[next.bx][next.by][next.px][next.py] == 0) //节点不重复 { next.useful = true; //同时满足上述条件，该节点才有效 //标记“到达过” used[next.bx][next.by][next.px][next.py] = 1; //根据箱子是否移动来修改步数 if (moved) { step[next.bx][next.by][next.px][next.py] = 1 + step[cur.bx][cur.by][cur.px][cur.py]; } else { step[next.bx][next.by][next.px][next.py] = step[cur.bx][cur.by][cur.px][cur.py]; } } } return next; //返回新节点} 迷宫最长回路的分支界限 文字描述 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cerrno&gt;using namespace std;namespace LongestRoute{ struct block { int x; int y; int state; int visit[2]; block(int x = 0, int y = 0, int state = 0) { this-&gt;x = x; this-&gt;y = y; this-&gt;state = state; this-&gt;visit[0] = this-&gt;visit[1] = 0; }; }; int n = 0; int m = 0; vector&lt;vector&lt;block&gt;&gt; map; int direction[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1},};//上， 右， 下， 左 int longest_route = 0; int root_x; int root_y;};using namespace LongestRoute;void create_map(){ cin&gt;&gt;n&gt;&gt;m; string cur_str; for(int i = 0; i &lt; n; i++) { vector&lt;block&gt; cur_block_array; cin&gt;&gt;cur_str; for(int j = 0; j &lt; m; j++) { switch (cur_str[j]) { case '/': cur_block_array.emplace_back(block(i, j , 0)); break; case '\\\\': cur_block_array.emplace_back(block(i , j , 1)); break; default: fprintf(stderr, &quot;input error at (%d, %d), input is : %c \\n&quot;, i, j, cur_str[j]); exit(0); } } map.emplace_back(cur_block_array); }}void search_longest_route(int x, int y, int position, int cur_route_length){ //由于每个在分支限界中每个节点只有一次成为最优解的机会，故当一个节点被搜索过后，它不再有再次被置入搜索栈的资格 if(x == root_x &amp;&amp; y == root_y &amp;&amp; cur_route_length != 1) { if(cur_route_length - 1&gt; longest_route) { longest_route = cur_route_length - 1; cout&lt;&lt;&quot;update longest_route : &quot;&lt;&lt;longest_route&lt;&lt;endl; } return; } for(int i = 0; i &lt; 4; i++) { int cur_x = x + direction[i][0]; int cur_y = y + direction[i][1]; int cur_position = -1; if(cur_x &lt; 0 || cur_x &gt;= n || cur_y &lt; 0 || cur_y &gt;= m) { continue; } if(i == 0 || i == 2) { if(map[x][y].state != map[cur_x][cur_y].state) { if(i == 0 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 1; else if(i == 0 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 0; else if(i == 2 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 1; else if(i == 2 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 0; }else { if(i == 0 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 2 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 0 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 2 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; } } else { if(map[x][y].state^map[cur_x][cur_y].state) { if(i == 1 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 1 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 3 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 3 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; }else { if(i == 1 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 1 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 3 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 3 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; } } if(cur_position != -1 &amp;&amp; map[cur_x][cur_y].visit[cur_position] == 0) { cout&lt;&lt;&quot;(&quot;&lt;&lt;cur_x&lt;&lt;&quot;,&quot;&lt;&lt;cur_y&lt;&lt;&quot;,&quot;&lt;&lt;cur_position&lt;&lt;&quot;)&quot;&lt;&lt;endl; map[cur_x][cur_y].visit[cur_position] = 1; search_longest_route(cur_x, cur_y, cur_position, cur_route_length + 1); } }}int main(){ freopen(&quot;../input&quot;, &quot;r+&quot;, stdin); create_map(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { for(int k = 0; k &lt; 2; k++) { if(!map[i][j].visit[k]) { root_x = i;root_y = j; search_longest_route(i, j, k, 1); map[i][j].visit[k] = 1; } } } } cout&lt;&lt;&quot;Longest Route Length : &quot;&lt;&lt;longest_route&lt;&lt;endl; return 0;} 回溯法求和因子 文字 输入设计：while(cin&gt;&gt;t)直到n=0跳出输入，结束程序 回溯设计： 目标函数：sum+=out[k],sum=t; 约束条件：sum&lt;t,out[k]的k&lt;=n,即加数不超过n 限界函数：sum&lt;t 具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件： sum&gt;t，继续dfs到下一层 sum=t，输出 sum&gt;t，进行剪枝并回溯到上一层。 去除重复后输出结果:将每次回溯所得的结果存入二维数组out_comp[i][j]中，其中i表示结果序号，即存回溯的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include&quot;string.h&quot;#include &quot;algorithm&quot;using namespace std;int t,n,list[12];//inputint out[12],out_comp[100][12];//outputint sum=0;int book[12];int num=0;//保存结果数int k=0;//去重复结果bool fun_row(int *a, int *b){ for(int i=0;i&lt;12;i++) if(a[i] != b[i]) return false; return true;}bool fun(){ for(int p=0;p&lt;100;p++) if(fun_row(out, out_comp[p]))return true; return false;}void output(){ int n=1,m=1; if(!fun())//输出不重复的结果 { cout&lt;&lt;out[0]; out_comp[num][0] = out[0]; while (out[n]) { cout &lt;&lt; &quot;+&quot;&lt;&lt;out[n]; out_comp[num][m] = out[n]; m++;n++; } num++; cout &lt;&lt; endl; } return;}void backtrack(int step){ if(sum == t) output(); if(sum&gt;t)return; for(int i=0;i&lt;n;i++) { if(!book[i] &amp;&amp; (list[i]&lt;=out[k-1]||k==0))//没有访问过且要求降序 { //存入out out[k]=list[i]; sum+=out[k]; book[i]=1; k++; //dfs向下搜索 backtrack(step+1); //回退 k--; sum-=out[k]; book[i]=0; out[k]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;t) { //输入设置 if(t&gt;1000 || t &lt; 0) { cout&lt;&lt;&quot;worry input t&quot;&lt;&lt;endl; continue; } cin&gt;&gt;n; if(n == 0) { cout&lt;&lt;&quot;end&quot;&lt;&lt;endl; exit(0); } if(n&gt;12 || n&lt;1) { cout&lt;&lt;&quot;worry input n&quot;&lt;&lt;endl; continue; } int i,flag=1; for(i=0;i&lt;n;i++) { int j; cin&gt;&gt;j; list[i] = j; if(list[i]&gt;100 || list[i]&lt;0) { cout&lt;&lt;&quot;worry input list[i]&quot;&lt;&lt;endl; flag = 0; } } if(!flag)continue; //output cout&lt;&lt;&quot;result :&quot;&lt;&lt;endl; //初始化 sum=num=k=0; memset(book,0,12*sizeof(int)); memset(out,0,12*sizeof(int)); for(int i=0;i&lt;100;i++) memset(out_comp[i],0,12*sizeof(int)); //回溯 sort(list,list+n,greater&lt;int&gt;()); backtrack(0); if(num==0)cout&lt;&lt;&quot;NONE&quot;&lt;&lt;endl; } fclose(stdin); return 0;} 贪心算法解任务调度器 文字 任务调度分配的最短时间由任务数最多的任务所决定，设最多的任务数有max个，有max个任务数的任务共num个，任务总数为sum。则在任务之间的max-1个间隔贪心的插入n*( max-1)个任务(可能含待命)。最后计算最终调度时间：当需要插入的个数大于可插入利用的最大个数时，除任务A本身和间隔，需在末尾补上余下的num-1个任务，因此最短时间为max+ n*(max-1)+num-1。否则最短调度时间为任务总数sum。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &quot;string.h&quot;using namespace std;int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); string s; cin&gt;&gt;s; int n; cin&gt;&gt;n; int task[26]; //初始化 memset(task,0,26*sizeof(int)); //任务统计 for(int i = 0; i &lt; s.size(); i++) task[s[i]-'A']++; //统计max和max个数num int mymax = 0,num = 0; for(int i = 0; i &lt; 26; i++) { if(mymax &lt; task[i]) { mymax =task[i]; num=0; } if(mymax == task[i] )num++; } cout &lt;&lt; max((int)s.size(), (mymax + (mymax - 1) * n + num - 1)) &lt;&lt; endl; return 0;} 二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;#define M 10int m,n;bool binarySearch(int matrix[M][M], int i, int target){ int left = 0, right = n; while(left &lt; right) { int mid = left + (right - left)/2; if(target &gt; matrix[i][mid]) left = mid + 1; else if(target &lt; matrix[i][mid]) right = mid; else return true; } return false;}//不成熟的二分尝试1bool searchMatrix(int matrix[M][M], int target) { for(int i = 0; i &lt; m; ++i) if(binarySearch(matrix, i, target)) return true; return false;}//最后采用的二分法int searchMatrix_(int matrix[M][M], int target, int bottle_r , int bottle_c) { if(matrix[bottle_r][bottle_c] == target) return 1; if(bottle_r==m || bottle_c==n || bottle_c==-1|| bottle_r==-1)return 0; else if(matrix[bottle_r][bottle_c] &gt; target) searchMatrix_(matrix, target, bottle_r-1 , bottle_c); else searchMatrix_(matrix, target, bottle_r , bottle_c+1);}int main() { cout&lt;&lt;&quot;input m,n:&quot;; cin&gt;&gt;m&gt;&gt;n; int matrix[M][M]; cout&lt;&lt;&quot;input matrix&quot;&lt;&lt;endl; for(int i = 0 ; i &lt; m ; i++){ for(int j = 0 ; j &lt; n ; j++)cin&gt;&gt;matrix[i][j]; } int target; cout&lt;&lt;&quot;input target:&quot;; cin&gt;&gt;target; if(searchMatrix(matrix, target))cout&lt;&lt;&quot;ture&quot;; if(searchMatrix_(matrix, target,m-1,0))cout&lt;&lt;&quot;ture&quot;; return 0;} 时间+快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#define N 100000void quickSort(int *r, int begin, int end){ int i,j; if(begin &lt; end) { i=begin;j=end;r[0]=r[i]; while(i!=j) { while(r[j]&gt;r[0]&amp;&amp;i&lt;j) j--; if(i&lt;j) { r[i]=r[j]; i++; } while(r[i]&lt;r[0]&amp;&amp;i&lt;j) i++; if(i&lt;j) { r[j]=r[i]; j--; } } r[i]=r[0]; quickSort(r, begin, i - 1); quickSort(r, i + 1, end); } else return;}int main(){ clock_t t1,t2; double t; srand((unsigned)time(NULL)); int r[N],i,n; char ch[40]; FILE* fp; fp=fopen(&quot;D:/algorithm/test_2_1.csv&quot;,&quot;w&quot;); for(n=1000;n&lt;=100000;n+=1000)//建立横坐标n { itoa(n,ch,10); strcat(ch,&quot;,&quot;); fwrite(ch,sizeof(char),strlen(ch),fp); } fwrite(&quot;\\n&quot;,sizeof(char),1,fp); for(n=1000;n&lt;=100000;n+=1000)//输入纵坐标t { //生成随机数 for(i=0;i&lt;n;i++) r[i]=rand()%1001; t1=clock();//开始计时 quickSort(r, 1, n - 1); t2=clock();//结束计时 t = (double)(t2-t1)/CLOCKS_PER_SEC*1000; itoa(t,ch,10); strcat(ch,&quot;,&quot;); fwrite(ch,sizeof(char),strlen(ch),fp); } fwrite(&quot;\\n&quot;,sizeof(char),1,fp); fclose(fp); return 0;} 棋盘覆盖 分治 文字 分治法求解棋盘覆盖问题的技巧在于划分棋盘，使划分后的子棋盘的大小相同，并且每个子棋盘均包含一个特殊方格，从而将原问题分解为规模较小的棋盘覆盖问题。 k&gt;0时，可将2k×2k的棋盘划分为4个2k-1×2k-1的子棋盘，这样划分后，由于原棋盘只有一个特殊方格，所以，这4个子棋盘中只有一个子棋盘包含该特殊方格，其余3个子棋盘中没有特殊方格。为了将这3个没有特殊方格的子棋盘转化为特殊棋盘，以便采用递归方法求解，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。 ​ 每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量s来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。其次还要有一个变量nCount来记录L型骨牌的数量。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;#define M 10int t = 0;//全局变量，表示L型骨牌编号int board[M][M];//全局变量，表示棋盘//tr,tc表示棋盘左上角//dr,dc表示表示特殊方格void ChessBoard(int tr , int tc , int dr , int dc , int size){ if(size == 1)return;//棋盘只有一个方格其是特殊方格 int number = ++t;//L型骨牌号 int s = size/2;//划分棋盘 //覆盖左上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr,tc,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s-1][tc+s-1]=number; ChessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)//特殊方格在右上角子棋盘中 ChessBoard(tr,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖左下角，再递归处理子棋盘 board[tr+s-1][tc+s]=number; ChessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左下角子棋盘中 ChessBoard(tr+s,tc,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右上角，再递归处理子棋盘 board[tr+s][tc+s-1]=number; ChessBoard(tr+s ,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr+s,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s][tc+s]=number; ChessBoard(tr+s,tc+s,tr+s,tc+s,s); }}int main() { int size , x , y; cout&lt;&lt;&quot;input size and (x,y)&quot;; cin&gt;&gt;size&gt;&gt;x&gt;&gt;y; board[x][y] = 0; ChessBoard(0,0,x,y,size); //输出棋盘 for(int i = 0; i &lt; size; i++) { for(int j = 0; j &lt; size; j++) { cout &lt;&lt; board[i][j] &lt;&lt; &quot;\\t&quot;; } cout &lt;&lt; endl; } return 0;}","link":"/2021/12/06/ALGORITHM-%E6%9C%9F%E6%9C%AB/"},{"title":"ANG","text":"序 From BBC 6 Minute English.(https://www.bbc.co.uk/learningenglish/english/features/6-minute-english ) Welcome to the ‘metaverse’ Links：https://www.bbc.co.uk/learningenglish/english/features/6-minute-english_2022/ep-220106 1.5 minutes的introduction The topic I chose to talk about is &lt;&lt;Welcome to the ‘metaverse’&gt;&gt;. So to begin with, what is metavers? According to the video, metaverse means a virtual-reality space in which users can interact with a computer-generated environment and other users. Recently, Facebook announced that it was hiring ten thousand new workers to develop VR for the ‘metaverse’, according to Mark Zuckerberg, the Facebook boss,&quot; in the future we’ll all spend much of our time living and working in the ‘metaverse’ &quot;. But people hold different opinions about it. Some supporters think it can make a great difference to our living world. They believe that with the technology of metaverse, everything that we do on our phone today can be done in 3-D. But there are also some negative opinions. For example,some people called VR ‘ vomity reality ’,because wearing the headset of VR makes them feel sick, maybe because it’s so unwieldy . From my perspective, I hold a supportive attitude towards this new technology as it seems so cool which can make our world more convenient . 2 new keywords VR: virtual-reality,a hypothetical three-dimensional visual world created by a computer; user wears special goggles and fiber optic gloves etc., and can enter and move about in this world and interact with objects as if inside it unwieldy: difficult to move or carry because it’s so heavy, large or strangely shaped 结语 所以元宇宙就是VR? VR OU AR ? 看了一些科普，就是有比较像头号玩家那种世界（或许赛博朋克的那种？。感觉就是，元宇宙感觉是个画大饼的不太实的概念（ Body language online Links: https://www.bbc.co.uk/learningenglish/english/features/6-minute-english/ep-211209 Introduction The topic I chose to talk about is ‘Body language online’. As we know, body language is important when we communicate with others. By using some hand gestures and facial expressions, we can make the conversation more natural. But during the Covid pandemic, the communication tend to move online to be video meetings by using software like Zoom and Skype. So, in that case, how has body language changed in the world of online video meetings? Firstly, eye contact. In face-to-face meetings, we immediately see someone’s reaction to what we’ve said through eye contact, but using a web camera to make eye contact is almost impossible in online meetings and this often creates a kind of ‘distance’ effect.–&gt; ? Secondly, pause. It was completely normal to have a one-minute pause in a room with one another because we knew when we’re thinking but if we don’t hear someone speak on video, we may ask them if there are some Internet problems.–&gt; Slow down. Last but not the least, smile or laughing. Erica , a communications expert from the conversation, points out that laughing often happens in unison, so it is much less likely that we laugh and smile on camera. Laughing is often done in unison where we can quickly pick up the energy of someone smiling or laughing and feed off of that and laugh together. When it comes to screen delays, the fact that it’s not natural to see our own camera – being distracted by that – we are much less likely to laugh and smile. --&gt;Water cooler effect. That’s all. New words Water cooler effect: it’s an American expression to describe informal conversations between people at work.–&gt; Talk someting informal out of the topic. In Unison: it means happening together and at the same time Pandemic: 流行病 noun: a widespread outbreak of an infectious disease and many people are infected at the same time adjective: existing everywhere","link":"/2022/02/06/ANG-01/"},{"title":"Ekya","text":"序 戴老师给的第二篇论文 读论文 DNN 深度神经网络，隐含层大于两层的神经网络 跑项目 项目地址：https://github.com/edge-video-services/ekya 结语 武运昌隆！","link":"/2022/08/01/Ekya/"},{"title":"HASK_入门学习","text":"HASK_入门学习 B站：https://www.bilibili.com/video/BV16F411j7Zq?p=8&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 P1 简单算术运算 cmd+ghci进入环境，可以直接使用命令行进行简单的数学计算 Haskell的自定义函数 结构 函数名+输出参数+等号+表达式（可以调用函数/别的或者自己） 运行 文件以.hs结尾保存 cmd进入桌面：cd Desktop ghci :l + 文件名 输入函数名和参数，回车即可运行。 P2 列表 定义 用中括号定义，只能包含单一元素类型(但可以嵌套：列表元素是列表) 字符串，用双引号定义，其实是字符列表 常用操作 拼接 ++ [1,2,3]++[4,5] --&gt; [1,2,3,4,5] “hello”++“haskell”–&gt;“hellohaskell” 单个元素的拼接可以使用冒号 6：[3,4,5] --&gt; [6,3,4,5] 2:[] --&gt;[2] 2:3:4:[]–&gt;[2,3,4] 获取元素 !! “haskell world” !! 1 --&gt;‘a’ 比较 可以直接用 &gt;(如果相等则比较下一个位置),&lt;,== 列表乘 常用函数 let lst = [1,2,3,4] head,last,tail（第一个元素之后的元素）,init（最后一个函数之前的元素）,length,null,reverse take+n+列表：获取前n个元素//0返回空 drop+n+列表：删除前n个元素 4+‘elem’+列表：判断4是否在列表中 minimum,maximum,sum,product(累乘) Range 直接… cycle表示无限循环，take+cycle组合使用 take的是长度 take 5(repeat ‘a’) 等价于 replicate 5 ‘a’ 也可以用列表的形式实现 [2*x|x&lt;-[1…10]] [x|x&lt;[1…100], x mod13 == 0] 例题 注释：单行–，多行{-多行注释-} |表示对a进行说明，a&lt;-str表示a取自字符串str（想成在遍历） _&lt;-str表示取自字符串str,都把它搞成1 x &lt;- xs,odd x表示只获取xs中的奇数 元组 ()表示，可以包含多种元素，不同长度的元组是不同的数据类型 1[(1,2),(8,9,10),(4,5)]会报错 函数：fst返回第一个元素，snd返回第二个元素，但只用于长度为2的元组（？？？？？？） ZIP函数 接收两个列表进行元素配对压缩为新列表，新列表的元素为元组 [1..]['A',''B,'C']```-->[(1,'A'),(2,'B'),(3,'C')]12345678## 例题10以内可组成直角三角形的三条边的组合```haskellfun = [(a,b,c)|a&lt;-[1..10],b&lt;-[1..10],c&lt;-[1..10],a^2+b^2 == c^2]--&gt;fun = [(a,b,c)|a&lt;-[1..b],b&lt;-[1..c],c&lt;-[1..10],a^2+b^2 == c^2]--可以避免重复 P3：类型、类型变量、类型类 TYPE 使用:t查看 类型变量 比如说head啊fst啊这些函数返回值（的类型）是不一定的，所以head和fst函数就是类型变量 类型类 没懂啊啊啊啊啊啊啊啊啊啊 P4 模式匹配 输入5之外都是“holiday&quot; 阶乘 不写：：那排能运行吗？–&gt;不能 P5：|、where、let、case |：管道，单竖线，感觉有点像if where let 有点像where case switch吧 听不懂了不听了 P7: 递归、排序、高阶函数 递归 fibonacci 1234fibonacci :: Integer -&gt; Integerfibonacii 0 = 0fibonacii 1 = 1fibonacii n = fibonacii (n-1) + fibonacii (n-2) 重写replicate 123replicate :: i -&gt; a -&gt; [a]replicate n x if n &lt;=0 = [] else = x:replicate (n-1) x 重写take 123take :: i -&gt; [a] -&gt; atake n _ [] = []take n (x:xs) = x : take $ (n-1) xs 重写reverse 123reverse :: [a] -&gt; areverse [] = []reverse (x:xs) = reverse xs ++ [x] 重写zip 1234zip :: [a] -&gt; [b] -&gt; [(a,b)]zip _ [] = []zip [] _ = []zip (x:xs) (y:ys) = (x,y) : zip xs ys 重写elem 1234elem :: a -&gt; [a] -&gt; Boolelem a [] = Falseelem a (x:xs) = if a == x then True else = elem a xs 排序 快排 1234567qs :: [a] -&gt; [a]qs [] = []qs [x] = [x]qs (x:xs) = let smallS = qs [a| a&lt;-xs,a&lt;x] bigS = qs [a| a&lt;-xs,a&gt;x] in smallS ++ [x] ++ bigS 高阶函数 Haskell函数的参数可以是函数，返回值也可以是函数。 Haskell的每个参数都只接受一个参数。 空格类似一个操作符，具有最高优先级。 关于max的理解 a-&gt;(a-&gt;a): 接收一个参数，返回一个函数，返回的这个函数再接收一个参数，并返回一个参数 部分应用的函数，博主用了个很有意思的理解 12345678910111213141516171819202122compareWith3 x = compare 3 x --也可以简写成：compareWith3 = compare 3--因为compare本身返回值就是一个需要一个参数的函数divBy10 :: a -&gt; adivBy10 = (/10)isUpperCase :: Char -&gt; BoolisUpperCase = (`elem` ['A'..'Z'])apllyTwice :: (a-&gt;a)-&gt;a-&gt;aapllyTwice f x = f (f x)--重写zipWithzipWith :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt;[c]zipWith _ [] _ = []zipWith _ _ [] = []zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys--重写flip函数flip :: (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)flip g x y = g y x P8:λ\\lambdaλ,$,fold,map,filter $ 有最低的优先级，代替括号 12map ($ 9) [(1+),(2*),(2-),sqrt]sum.replicate 4.max 6 $ 7 λ\\lambdaλ lambda 匿名函数：(\\ 参数 -&gt; 函数体) 例 : map (\\a -&gt; a+1) [1…6] fold foldl + 函数 + 初始值 + 列表元素 –区别在于函数中的参数顺序foldl 是先初始值，再列表元素，foldr则相反 比如sum的改写，i是0，a是列表元素 123456789foldl (\\i a -&gt;i+a) 0 [1..3]--foldl (+) 0 [1..3]--foldl (+) [1..3]--列表的第一个元素当做初始值foldl (\\a i -&gt;i+a) 0 [1..3]--foldr (+) 0 [1..3]--foldr (+) [1..3]--列表的最后一个元素当做初始值--重写elemelem y= foldl (\\i x -&gt; (x == y) || i) False--没写参数(列表ys)是因为,返回值是个需要参数的函数 map 123map :: (a-&gt;b)-&gt;[a]-&gt;[b]map _ [] = []map f (x:xs) = f x : map f xs filter 1234filter:: (a-&gt;Bool)-&gt;[a]-&gt;[a]filter _ [] = []filter p (x:xs) = if p x then x : filter p xs else = filter p xs 用filter改写qs 1234567qs :: [a] -&gt; [a]qs [] = []qs [x] = [x]qs (x:xs) = let smallS = qs (filter (&lt;x) xs) bigS = qs (filter (&gt;x) xs) in smallS ++ [x] ++ bigS takeWhile 12345678--从给定列表的元素第一个开始，直到FlasetakeWhile :: (a-&gt;Bool) -&gt; [a] -&gt;[a]--考拉兹猜想：对于每个正整数，如果奇数*3+1，如果偶数除2，最终都能得到1collatz :: a -&gt; [a]collatz 1 = [1]collatz n = if odd n then n:collatz (n*3+1) else n:collatz (div n 2) P10&amp;11：类型类自定义 定义类型 data关键字 类型名(首字母大写) = 值构造器[可以与类型名相同或者不同，首字母大写] 值构造器：接收几个value作为参数，生成一个新的value 123456789data Point = Point Float Float deriving Showdata Shape = Circle Point Float| Rectangle Point Point deriving Showsurface :: Shape -&gt; Floatsurface (Circle _ r) = pi * r * 2surface (Rectangle Point(x1 y1) Point(x2 y2)) = abs (x2-x1) * abs (y2-y1)--用map构造一系列Circlemap (Circle 10 10) [4,5,6] 类型递归 123456789101112131415161718data Ls a = Empty | Cons a (Ls a) deriving Show--ABRdata Tree a = EmptyNode | Node a (Tree a) (Tree a) deriving ShowinsertNode :: a -&gt; Tree a -&gt; Tree ainsertNode x EmptyNode = singleton xinsertNode x (Node a left right) |x == a = Node x left right |x &lt; a = Node x (insertNode x left) right |x &gt; a = Node x left (insertNode x right) elemNode :: a -&gt; Tree a -&gt; BollelemNode x EmptyNode = FalseelemNode x (Node a left right) |x == a = True |x &lt; a = elemNode x left |x &gt; a = elemNode x right 也可以用大括号的形式 1data Person = Person {name::String,age::Int,height::Float} deriving Show 类型构造器：接收几个类型作为参数，生成一个新的类型，例： 12345Str::[Char]data Vector a = Vector a a a deriving ShowscalarM :: Vector t -&gt; Vector t -&gt; tscalarM (Vector i j k) (Vector l m n) = i*l + j * m + k * n deriving: 把构造的类搞成别的类型类的实例，就比如说上面的Person可以deriving(Eq) 然后去编它=的这样 类型同义词 type AssocListe k v = [(k,v)] 有点像说在自命名一个数据类型 Either a b class 类型类定义了函数或者类型声明，类型类的实例可以使用这些函数 比如说haskell自带的Eq类里面就有定义==和/=的说明，instance Eq Int就是Eq类的一个实例，表示两个int类型可以进行比较。也可以对自定义的类型进行说明，比如 1234567891011data Signal = R | Y | Ginstance Eq Signal where (==) R R = True (==) Y Y = True (==) G G = True (==) _ _ = Flase instance Show Signal where show R = &quot;Red&quot; show Y = &quot;Yellow&quot; show G = &quot;Green&quot; YesOrNo Functor 12345678class Functor f where fmap :: (a-&gt;b)-&gt; f a -&gt; f b--列表作为实例时，fmap与map相同fmap :: (a-&gt;b) -&gt; [a] -&gt;[b]--Maybe作为实例时fmap :: (a-&gt;b) -&gt; Maybe a -&gt; Maybe bfmap _ Nothing = Nothingfmap f (Just a) = Just (f a) P12：IO putStrLn, putChar, putLine(换行输出):: String -&gt; IO () print :接收任何一个实例的值，返回一个IO操作 = puStrLn.show getLine：获取用户在终端中输入的一行 getChar：获取用户在终端中输入的一个字符 多个IO操作可以用do绑定，用return不返回 sequence接收IO操作的列表 ls &lt;- sequence [getLine,getLine,getLine]","link":"/2022/09/01/HASK/"},{"title":"INDUR_CM1&amp;2","text":"INDUR - Informatique durable_CM1 &amp;2 CM1 一些问题和介绍 Quels mots/concepts vous évoque[唤起] l’idée d’une informatique durable(ou responsable)? ​ Energie: Conception logicielle–&gt;cycle de vie d’un logiciel analyse de complecité–&gt;metro compatilite utilisation a finalité de DD matériel–&gt;ordinateurs de []/centre de données Energie social ​ Ethique Quelques problèmes d’intérêt? design et informatique: le doomscrolling https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0257728在讲寻找与 COVID 相关的新闻可能会破坏积极情绪这些 informatique verte Une obligation sociétale https://www.legifrance.gouv.fr/codes/id/LEGIARTI000044330813/2022-09-01/ 讲说工程培训包括与数字服务的生态设计和数字清醒相关的模块。 Analyse d’impact relative a la protection des données(AIPD)? -obligatoire pour les traitements susceptibles[高风险] d’engendrer des risques élevés -Composé de 3 parties : Description détaillée du traitement mis en œuvre Évaluation juridique de la nécessité et de la proportionnalité concernant les principes et droits fondamentaux Étude technique des risques sur la sécurité des données (confidentialité[保密性], intégrité[完整性] et disponibilité[可用性]) et leurs impacts potentiels sur la vie privée -英语的：DPIA/PIA Plan du cours Plan du cours informatique verte(9月) Identifier les principes de l’informatique verte et les leviers[杠杆?] associés Enjeux[问题] et impacts directs et indirects Consommation énergétique matérielle et logicielle Sobriété[清醒] numérique -MOOC: impacts environnementaux du numérique Règlementation et éthique(10月) Cadre juridique en matière[材料，物质] de traitement automatique de données Ethique et responsabilité 11月7号早上考试!!! Objectifs du cours -Savoir construire une analyse éthique et responsable des traitements automatiques de l’information (identification de l’impact de ces traitements, des biais[偏差] possibles, etc.) -Savoir mettre en oeuvre un diagnostic de la consommation énergétique des applications informatiques Développer une pensée rationnelle[理性], basée sur la littérature scientifique 小组讨论 课后作业/之后的安排 MOOC(https://lms.fun-mooc.fr/courses/course-v1:inria+41025+session01/info)看完然后选主题写报告 就是说是让咋搁教室去上MOOC的意思？ CM2: Impact environnemental et éco-conception 是两个centrale paris的创业的厉害的年轻人来讲的 Présentation des enjeux Impact environnemental du numérique: beaucoup matériaux La fabrication: Matériaux rares, manufacture, transport 90% 的 émissions vient de la fabrication usages: les vidéos, divertissement l’effet rebond: augmenter la capacité du réseau, diminuer la consommation d’électricité Mesure d’une application pourquoi change-t-on de téléphone: mémoire saturée, batterie morte, incompatibilité de matériel, tout qui lague, marketing agressif(iPhone 14) L’outil de mesure de BAM(7 axes): compatibilité, utilisation de la batterie, performance de l’app, taille de l’app","link":"/2022/11/12/INDUR_CM1%20&%202/"},{"title":"IAM11","text":"IAM 11 IAM课上的一些随手记 CMs 1.Les différents types d’entretien L’entretien téléphonique Vous n’aurez jamais une seconde chance de faire une bonne première impression. La prise de rende-vous. L’entretien de pré-sélection L’entretien de suivi Les appels moins sympas L’entretien individuel Les entretiens successif L’entretien face à plusieurs interlocuteurs: 联系人员 L’entretien de groupe 2.L’entretien chez les anglo-saxons La plupart des pays fonctionnent comme la France Les questions sont sensiblement les mêmes sur le fond Les américains sont très sensibles a l’enthousiasme, l’énergie, l’engagement, la motivation improve your English 3.Les différents phases de l’entretien 20 minutes 1.Prise de contact 3’ 2.introduction recruteur 15’ 3.votre présentation 2’ 4.Questions/Réponses 35’ 5.Conclusion 5’ 4.Checklist entretien e-mail, téléphone, lieu, LinkedIn 5.Les comportements qui dérangent[不安] Mme en retard M. grognon: 暴躁 M. mal élevé：粗鲁 MME terreur M. tatillon：挑剔 M. formidable c’est moins/pas grave： MME. timide: 羞涩 MME. bavarde M. silence MME tête-en-l’air Rapple sur les modes de communication Visuel(0.55), mots(0.7), ton de la voix(0.38) 6.Questions entretien de recrutement plusieurs types de questions: sur votre personnalité par rapport à votre candidature par rapport à votre projet – 20 questions fréquemment posées pour un stage En quelques mots, qui êtes-vous? ECN, Double Diploma, C++, Python Pourquoi notre entreprise plutôt qu’une autre ? Qu’avez-vous compris des missions du stage ? SATR原则: Situation, task, action[comment, connaissance, compétences], result[chiffres] Que nous dirait votre entourage de vous? Où vous voyez-vous dans 5 ans ? Parlez-moi d’une expérience dont vous êtes fier[自豪]. Quel a été votre plus grand obstacle[障碍] et comment l’avez-vous surmonté[克服] ? Qu’est ce qui a motivé le choix de votre formation? Préférez-vous travailler seul ou en équipe? Qu’avez-vous fait dans cette période de creux[低谷期] sur votre CV? Que savez-vous de nous? Et de nos concurrents[竞争对手]? Pourquoi vous et pas un autre candidat? Quel serait votre stage idéal? Que pensez-vous pouvoir apporter à notre société ? Ce stage est gratifié de X €, cela vous convient ? Citez-moi 3 qualités et 3 défauts So, let’s switch in English ? Quand serez-vous disponible pour ce stage? Avez-vous d’autres pistes? Avez-vous des questions à nous poser? – 其他的一些经典问题 Quel est votre projet de carrière ? Parlez-moi d’une ou deux réalisations probantes[两个令人信服的成就] Quelles sont vos prétentions salariales? Quels sont vos points faibles par rapport au poste ? Parlez-moi de vos centres d’intérêt Si vous étiez un animal ? Un pays ? Comment gérez-vous le stress? Qu’attendez-vous de votre supérieur hiérarchique[部门经理]? Quels résultats avez-vous obtenus dans vos précédentes expériences? Pourquoi souhaitez-vous quitter votre poste actuel? Qu’est-ce qui vous plait dans notre offre ? Comment pensez-vous prendre votre poste? Quels sont vos moteurs professionnels? 7. Structure en 4 étapes Etat civil: votre prénom suivi de votre nom de famille énoncés clairement Dans certaines situations il pourra être pertinent d’annoncer votre âge, votre région d’origine et/ou votre situation familiale, dans l’objectif de créer du lien avec votre interlocuteur Formation votre interlocuteur peut situer ainsi immédiatement votre profil et votre niveau d’études Parcours 2,5 ou 10 lignes pour un pitch de 30’, 1 mn ou 2 mn Project vous concluez en annonçant votre projet professionnel 8. Méthode en 7 étapes Construisez votre pitch par écrit Vérifier que vous abordez bien le PASSE, PRESENT et FUTUR Soyez CONCRETS et PRECIS Souriez … un minimum, et articlez Lisez à haute voix votre pitch en vous enregistrant Apprenez votre pitch par cœur Répétez plusieurs fois 9. Exemples de pitch 9.1 axes 9.2 Si vous retenez ma candidature pour ce poste je serai en mesure de vous apporter :… --&gt;如果你接受我的申请该职位的申请我将能够为您带来 感觉适合实习经验丰富的? 9.3 学术背景+相关经验+aspirations和招聘广告一致+能给公司带来的收益 10. Comment être sûr de rater[搞砸] son pitch Réciter par cœur et sans saveur Jouer un rôle Raisonner sans résonner：没有共鸣的推理 être abstrait ou trop général Regarder par terre ou ailleurs Faire comme si S‘auto TDS 1.Une offre de stage qui vous intéresse vraiment INDEED: https://careers.microsoft.com/us/en/job/1464936/Software-Engineering-Internship-Opportunities-France-Start-date-Feb-March-2023?jobsource=indeed&amp;utm_source=indeed&amp;utm_medium=indeed&amp;utm_campaign=indeed-feed 2.analyser une offre L’annonce Secteur-Produits/Services: Software engineers Missions du Poste: design, development and testing of next-generation software Profil recherché: Pursuing a bachelor’s or master’s degree in software engineering, computer science or related field. One year of programming experience in an object-oriented language. Ability to demonstrate an understanding of computer science fundamentals, including data structures and algorithms. Moi+ Qu’est-ce que je connais du secteur de l’entreprise? data structures, algorithms, programming experience in an object-oriented, quickly learns new engineering methods Moi- Ce que je ne connais pas, ce qui peut freniner ma candidature I don’t have any related experience in software development. 3.CV et LM 4.面试中可能的问题 4.1 Generale 先自我介绍一下； 对未来有什么规划； 说说你的优缺点； 认为自己是一个怎样性格的人； 平时的爱好； 你能给公司带来什么； 你的期望薪资是多少； 为什么选择我们公司； to introduce themselves first. what plans you have for the future. tell us about your strengths and weaknesses. what kind of personality you consider yourself to be. hobbies in your spare time. what you can bring to the company. what your salary expectations are. why you chose our company. de se présenter d’abord. les projets que vous avez pour l’avenir. parlez-nous de vos forces et de vos faiblesses. quel type de personnalité vous considérez être. des passe-temps pendant votre temps libre. ce que vous pouvez apporter à l’entreprise. quelles sont vos attentes salariales. pourquoi vous avez choisi notre entreprise. 4.2 技术上 什么是软件工程?它目标和内容是什么? 软件开发中有哪几种过程模型?哪些适用于面向对象的软件开发? 列出复杂度为O(nlognnlognnlogn)的排序算法 列出常见的数据结构以及其用法 5. 基于面试问题的准备 5.1 一般的 to introduce yourself first. --&gt; 自我介绍； Good afternoon, sir. It’s my great honor to take this opportunity to give a brief personal introduction here. I’m Li NI, an engineering student studying Artificial Intelligence in École Centrale de Nantes. I come from China, and to gain more engineering knowledge and broaden international view, I’m here now for the double diploma. After 4 years of mutual training between France and China, I have extensive knowledge of artificial intelligence. During my school life, I studied hard and I got some achievements, just as shown in my CV, I used to rank NO.2 in my major and I got third prize in the China Robotics Competition. But to be honest, I haven’t much experiences of internships, which is not only important for my personal development, but it is also a requirement for my double degree program. That’s why I’m here now. If I am lucky enough to join your company, I’ll apply all I have learned in my work. OK, I think that’all. Thanks! what plans you have for the future–&gt;对未来有什么规划； For my future plans, firstly I have to find an internship to complete my double degree exchange program now of course. Then I’ll return to China to get my master’s degree in 3 years. Then, after graduation, I would like to join a famous internet company, where I can fully use my knowledge to make a difference to our world. tell us about your strengths and weaknesses --&gt; 说说你的优缺点； 优点： 适应力强。在法语不好的情况下，面对纯法语授课也全部通过考试。 Highly adaptable. My frech is poor, but I passed all the exams in the first year of Ecole Centrale de Nantes. 合理地安排时间。我会每周列出的任务清单，并根据每天的具体作业和完成情况进行更新，根据他完成任务。 Schedule reasonably well. I will make a list of tasks each week and update it according to the specific assignments and completion of each day and complete the tasks according to it. 逻辑性强。喜欢把一个问题拆分成不同的子问题，然后一一解决 Logical. Likes to break down a problem into different sub-problems and solve them one by one 缺点： ​ 1. My public speaking skills are poor and I usually feel nervous when speaking in public. what kind of personality you consider yourself to be --&gt; 认为自己是一个怎样性格的人； 同上 hobbies in your spare time --&gt; 平时的爱好； In my free time, I love travelling and recording my life. For these, I have created my personnel website “nililili7876.cn”, where I put my diary, class notes and travelogue. what you can bring to the company–&gt;你能给公司带来什么//为什么我们应该雇用你？ 首先，我有丰富的专业知识和快速学习的能力，能完成公司给我的任务 Firstly, I have a wide range of professional knowledge and the ability to learn quickly, so I can complete the tasks given to me by the company 其次，我为人热情且适应能力强，可以快速融入团队，提高公司效率 Secondly, I am enthusiastic and I can quickly adapt to a new team, which can improve the efficiency of our company 最后我注意到招聘信息对于团队多元文化的需求，我来自中国，可以增加团队的多元文化 Lastly, I noticed the need for multicultural teams in the job advertisement, as I am from China, it matters. what your salary expectations are --&gt; 你的期望薪资是多少； €1000 a month why you chose our company --&gt; 为什么选择我们公司； I am very optimistic about the industry you are in, I think your company values its people and this job is a good fit for me and I am sure I can do well. What’s more, I spent a lot of time considering various internship jobs offered by information fields, but finally, I decided the job of software engineer is the best fit for me, because it required many skills that I was skilled . For example, the knowlege of algorithmic analysis and data structures. 你为什么想要这份工作？ The internship experience is important for my personal development, as on the one hand it allows me to fully relate the theoretical knowledge I have acquired to its practical application, and on the other hand it better helps me to understand the direction of my future research. Internship experience is also required for my double degree program 你最大的专业优势是什么？ Received a joint training between China and France and I took many courses in artificial intelligence, such as: data structures, databases, algorithm analysis, operating systems 什么是你最大的专业成就？ NO2 RM Pass all first-year courses for engineers in ECN 你喜欢什么类型的工作环境？ the place where are lots of peers 你如何面对压力？ Find the source of stress and then solve it 你对我们有什么问题吗？ If I’m lucky enough to be hired by your company, is there anything I need to learn or prepare for before I start? 5.2 基于简历 关于RM: At the start of my 2nd year in university, I realised the importance of applying what I had learnt to the real problem, so I taught myself the opencv library in C++ that summer and successfully passed the test and joined the school robotics team, that representing the school in the National Robotics Competition. I was responsible for the computer vision, recognising armour plates and predicting trajectories of robots. We ended up winning our provincial championship, and the third national prize.","link":"/2022/11/12/IAM11_CM/"},{"title":"INDUR_Pres","text":"INDUR_Pres 关于indur的期末整理,以此纪念几乎每节课都有的pre== 1. Objets connectés 不是我说，真的完全找不到也完完全全记不得讲了啥了 2. Vers L’Eco-Conception 讨论Option SI与的环境关系，使用了analyse cycle de vie的方法探究SI如何向Eco-Conception发展。从avant，pendant和apres三个方面说的。 做了海报然后就说了个介绍，然后还是安然给我写的TAT 3. Nom de Domaine 3.1 课上讲的: Droit et propriété intellectuelle Droit d’autre Licences Open Source, Libre, Mesures de protection(DRM) Licences Creative Common musique libres, etc Droits des marques: R加圈，TM Droit des nom de domaine-Applc Instances de contrôle: HADOPI (ARCOM)[法国视听和数字通信监管局], CNIL Droits des marques: R加圈，TM-Droit des norme de domaine-Apple ®代表 “注册”，这意味着该商标已经注册, 它已达到相关商标局的要求。这时注册程序已经完成。 符号TM商标是指商标的名称。通常是在商标未经注册而使用，或已注册但未注册的情况下贴上。 使用&quot;©&quot;原则上意味着有关作品已在官方版权登记册上登记。然而，在法国，没有这样的登记。 Données personnelles - anonymisation[匿名] Loi Informatique et 1978 RGPD 2018 Neutralité du néseau (accessililité) privacy Droit vie privée en ligne Voitures autonomes: Quelle protection sur une oeuvre crée par une IA? Sur du code crée par une IA? Qui est propriétaire d’un modele étallisant du diag médieal 3.2 pre 查了超级多，但就讲了一点点的域名投资的东西。 L’investissement dans un nom de domaine consiste à enregistrer un nom de domaine en fonction de votre propre jugement du marché, à attendre qu’il prenne de la valeur, puis à le vendre pour la différence de prix, qui peut-etre ganer beaucoup.Par exemple, cars.com, qui a été enregistré gratuitement en 1994[mile neuf cent quatre-vignt-sixze] par Tim Lee, un étudiant de Washington, puis racheté par Gannett pour avrion 1,8 milliard de dollars en 2015[deux mile qunzi] 4.Transfert des données personnelles hors UE 讲的是欧洲数据传输上一些法律的保护。 欧盟-美国隐私盾的充分性决定于2016 年 7 月 12 日通过，允许将数据免费传输给在美国获得隐私盾认证的公司。在2020 年 7 月 16 日的判决 （C-311/18 案）中，欧盟法院宣布充分性决定无效。因此，欧盟-美国隐私护盾不再是将个人数据从欧盟传输到美国的有效机制。2022 年 3 月 25 日，欧盟委员会和美国宣布原则上就新的跨大西洋数据隐私框架达成一致。 GDPR European Commission and United States Joint Statement on Trans-Atlantic Data Privacy Framework 基于奥地利律师、隐私活动家Max Schrems诉Facebook系列案件，宣布被称为“隐私盾”（Privacy Shield）的欧盟-美国数据传输协议无效。这一裁决引发数据隐私保护领域和数据传输业务的巨大震荡，将导致包括亚马逊、花旗集团、Facebook、谷歌、微软、华为、汇丰、毕马威等在内的5300余家依赖于“隐私盾”协议的公司被迫停止将欧盟境内的个人数据传输至美国，或在美国的服务器上存贮欧盟个人数据。 数据经过外国公司提供的cookies处理即构成跨国数据传输。欧盟数据保护监管局和奥地利数据保护机构均认为，经过cookies处理后，数据就被传输到了美国。跨国数据传输必须采取额外措施以保证数据得到与欧盟同等水平保护，而仅仅是签订格式条款合同等,或存在美国当局基于美国法律访问这些个人数据的可能性，就不能认为数据得到了有效保护。基于此，未来的国际数据传输也会受到影响，即接收方不必对数据传输合法性承担责任。 再次，无论是欧盟数据保护局还是奥地利数据保护机构，二者均未对涉案主体处以罚款，而是采取措施禁止相关跨境数据传输行为。 只能说完全看不懂，然后我讲的部分就是上面说的那个厉害的奥地利的律师说隐私盾不安全，谷歌facebook这些仍然在侵犯欧洲公民的隐私，然后有个新的框架。 Je vais présenter le nouveau cadre sur Transfert des données personnelles hors UE, qui s’appelle Trans-Atlantic Data Privacy Framework.En juillet 2020, un avocat autrichien, M.Schrems a poursuivi des entreprises telles que Facebook Google Microsoft pour avoir violé la vie privée des données des citoyens européens,démontré les faiblesses du RGPD.Après deux ans d’efforts de la part de plusieurs gouvernements, le 25 mars de cette année, la présidente Von Der Leyen et le président Biden se sont mis d’accord sur un nouveau cadre de transmission, le Trans-Atlantic Data Privacy Framework. Alors, quelle est la différence avec le nouveau cadre ?Tout d’abord, Les citoyens européens pourront déposer une plainte auprès du Civil Liberties Protection Officer de la communauté du renseignement américaine. Ensuite, Les personnes auront la possibilité de faire appel de la décision du Civil Liberties Protection Officer devant la Data Protection Review Court nouvellement créée. Au total, dans le cadre du RGPD, auparavant, les questions relatives à la vie privée des données personnelles ne pouvaient être soumises qu’à l’Ombudsman, qui fait partie du gouvernement américain, dans le cadre des nouvelles règles, les décisions de l’Ombudsman et même l’Ombudsman peuvent faire l’objet d’un appel, ce qui peut garantir davantage la sécurité des transferts de données. 5. Reconnaissance faciale 将中国技术的未来和伦理上可能的问题，就很随意的说了很少很少的一点点 三个例子：面容解锁，可口可乐，麦当劳 人脸识别的未来：1.身份识别上，可以简化任何需要验证身份的场景，比如支付，考试；2.表情识别上，可以使我们的管理更高效，比如麦当劳分析顾客表情优化自身管理；也可能可以使我们的社会更安全，比如通过识别可以做疲劳驾驶的警报器，使运输更安全 Je vais vous présente l’avenir de la reconnaissance faciale : 1. en ce qui concerne la reconnaissance de l’identité, elle peut simplifier tout cas de figure nécessitant une vérification de l’identité, comme les paiements ou les contrôle des aéroports; 2. en ce qui concerne la reconnaissance de l’expression, elle peut rendre notre gestion plus efficace, comme McDonald’s qui analyse l’expression des clients pour optimiser sa propre gestion ; elle peut également rendre notre société plus sûre, comme la reconnaissance peut déclencher des alarmes de fatigue au volant pour rendre le transport plus sûr.","link":"/2022/11/12/INDUR_Pres/"},{"title":"INDUR_DS","text":"INDUR_DS introduction，mooc，dpi et éthique. 0. Introduction plan informatique verte(9月) Identifier les principes de l’informatique verte et les leviers[杠杆?] associés Enjeux[问题] et impacts directs et indirects Consommation énergétique matérielle et logicielle Sobriété[清醒] numérique -MOOC: impacts environnementaux du numérique Règlementation et éthique(10月) Cadre juridique en matière[材料，物质] de traitement automatique de données Ethique et responsabilité objectifs -Savoir construire une analyse éthique et responsable des traitements automatiques de l’information (identification de l’impact de ces traitements, des biais[偏差] possibles, etc.) -Savoir mettre en oeuvre un diagnostic de la consommation énergétique des applications informatiques -Développer une pensée rationnelle[理性], basée sur la littérature scientifique 1. Informatique verte 1.1 MOOC 数字技术与环境的关系 一些观点 数字不虚拟，有物理现实：光纤电缆，终端、云计算与数据中心[关于网络的另一端]–&gt;数据中心对环境的影响：2015 年，数字占全球温室气体排放量的 4%，而航空占 2.5%。在这 4% 中，有 25% 与数据中心相关联。数据中心的用电量约占全球用电量的 3%。 数字化没有成功转型，只是在叠加[使用电子设备的同时也没有减少对树木的砍伐，石油的使用]且数字化的那些设备不可再生 La sobriété numérique[数字清醒]：La sobriété consiste à faire décroître voire disparaître des usages, des valeurs ou des comportements. Elle ne nécessite pas le développement de nouvelles techniques ou technologies. Elle se rapporte au suffisant relativement aux besoins et aux enjeux d’équilibre écologique et d’équité. On pourrait parler de « faire moins avec moins ». 电子设备的ACV(analyse de cycle de vie)：分析ACV的4个步骤： Objectifs et champ de l’étude：研究的目标和研究结果的用途 Inventaire du cycle de vie：核心，分解特定功能单元生命周期中涉及的生产、转换或者消费阶段。 Évaluation des impacts environnementaux Interprétation et mise en forme des résultats 除了数字设备对环境的影响外，数字服务对环境也会造成影响。[数字服务：services numériques ，包括nos applications, logiciels de messagerie, interface de streaming。数字服务由一组软件、硬件、网络和基础设施以及由各种参与者（人力资源）（出版商、设计师、架构师、网络和服务运营商、互联网接入供应商、用户、 ETC）。这种通过数字服务进行的衔接使得满足一个或多个需求成为可能。数字服务不是软件，由一组人力、材料和软件资源组成]–&gt;比如说通信功能，这个功能背后需要很多基础建设和人力维护。 2. Droit et propriété intellectuelle[法律和知识产权] 网站：CNIL.fr Les données personnelles：个人数据 Règlement général sur la protection des données (RGPD) Augmentation des sanctions financières (jusqu’à 4% du chiffre d’affaire pour les entreprises) 增加经济处罚（对公司而言，最高为营业额的4%） Pour certains traitements (fonction publique + données sensibles), nécessité d’avoir un DPO (Data Protection Officer)对于某些处理业务（公共服务+敏感数据），需要有一个DPO（数据保护官） Introduit droit à l’effacement, droit à la portabilité des données personnelles, etc. 引入了删除权、个人数据的可移植性权利等。 RGPD 45: Transferts fondés sur une décision d’adéquation 基于充分性决定的转让 RGPD 46: Transferts moyennant des garanties appropriées 受适当保障的转让 RGPD 47: Règles d’entreprise contraignantes 具有约束力的公司规则 两条可能用到的法律 « L’informatique doit être au service de chaque citoyen. Son développement doit s’opérer dans le cadre de la coopération internationale. Elle ne doit porter atteinte ni à l’identité humaine, ni aux droits de l’homme, ni à la vie privée, ni aux libertés individuelles ou publiques. » Article 1er de la loi relative à l’informatique, aux fichiers et aux libertés du 6 janvier 1978, consolidée au 6 août 2004 &quot;信息技术必须为每个公民服务。其发展必须在国际合作的框架内进行。它不得侵犯人类身份、人权、隐私或个人或公共自由。1978年1月6日关于信息技术、文件和自由的法律第1条，于2004年8月6日合并 « La communication au public par voie électronique est libre. L’exercice de cette liberté ne peut être limité que dans la mesure requise, d’une part, par le respect de la dignité de la personne humaine, de la liberté et de la propriété d’autrui, du caractère pluraliste de l’expression des courants de pensée et d’opinion et, d’autre part, par la sauvegarde de l’ordre public, par les besoins de la défense nationale, par les exigences de service public, par les contraintes techniques inhérentes aux moyens de communication, ainsi que par la nécessité, pour les services audiovisuels, de développer la production audiovisuelle. » Article 1er de la loi pour la Confiance dans l’Economie Numérique du 21 juin 2004 “通过电子手段向公众传播是免费的。这种自由的行使只能受到限制，一方面要尊重人的尊严、他人的自由和财产，以及思想和意见表达的多元化，另一方面要维护公共秩序、国防的需要、公共服务的要求、通信手段固有的技术限制，以及视听服务发展视听制作的需要。” 2004年6月21日的《数字经济信心法》第1条 上课做pre的一些课题 Propriété intellectuelle: 知识产权 Droit d’auteur: 作者的权利 Droit des créations numériques - Licences: 数字创作法 - 许可证 Brevet (et brevet logiciel) : 许可证(和知识产权许可证) Droit des marques : 商标权 Droit du traitement de l’information: 信息处理法 Droit des données personnelles et sécurité : 个人数据和安全法 Droit du commerce électronique : 电子商业法 Questions diverses et actualités: 各类问题和实际情况 What is public domain? What differences between copyright, trademark, registered trademark? 版权、商标、注册商标之间有什么区别？ Do you know that the use of ® for an unregistered trademark is a criminal offense in some countries? 你知道在某些国家，将®用于未注册的商标是一种刑事犯罪吗？ How multimedia/numerical creations are protected against piracy? 如何保护多媒体/数字作品不被盗用？ What laws do you have to respect to process personal data? 在处理个人数据时，你必须遵守哪些法律？ How software licenses may restrict the end-user rights? 软件许可证如何限制终端用户的权利？ 最后面提到的一些法律 ▪Loi 78-17 du 6 janvier 1978 relative à l’informatique, aux fichiers et aux libertés : instauration de la CNIL 1978年1月6日关于信息技术、文件和自由的第78-17号法律：建立CNIL ▪Loi 88-19 du 5 janvier 1988, relative à la fraude informatique 1988年1月5日关于计算机欺诈的第88-19号法律 ▪Loi 98-536 du 1er juillet 1998, concernant la protection juridique des bases de données 1998年7月1日关于数据库法律保护的第98-536号法律 ▪Loi 2004-801 du 6 août 2004 relative à la protection des personnes physiques à l’égard des traitements de données à caractère personnel : remaniement de la loi « Informatique et Libertés » pour suivre la directive européenne de 1995 sur le sujet 2004年8月6日关于在处理个人数据方面保护个人的第2004-801号法律：重新修订 &quot;信息与自由 &quot;法，以遵循1995年关于该主题的欧洲指令。 ▪Loi 2004-575 du 21 juin 2004 pour la Confiance dans l’Economie Numérique 2004年6月21日关于数字经济信心的第2004-575号法律 ▪Loi 2006-961 du 1er août 2006 relative au Droit d’Auteur et aux Droits Voisins dans la Société de l’Information 2006年8月1日关于信息社会版权和邻接权的第2006-961号法律 ▪Loi 2009-669 du 12 juin 2009 favorisant la diffusion et la protection de la création sur internet 2009年6月12日第2009-669号法律，促进互联网上创作的传播和保护 Ou loi HADOPI Complétée par la loi 2009-1311 du 28 octobre 2009 relative à la protection pénale de la propriété littéraire et artistique sur internet 经2009年10月28日第2009-1311号法律补充，关于对互联网上文学和艺术财产的刑事保护 ▪Loi 2011-267 du 14 mars 2011 d’orientation et de programmation pour la performance de la sécurité intérieure 2011年3月14日第2011-267号法律，关于内部安全性能的定位和方案设计 Règlement (UE) 2016/679 du Parlement européen et du Conseil du 27 avril 2016 (RGPD) 2016年4月27日欧洲议会和理事会的（欧盟）2016/679号条例（RGPD） Adapté dans la loi française via la loi relative à la protection des données personnelles promulguée le 20 juin 2018 通过2018年6月20日颁布的个人数据保护法改编为法国法律 3. intelligence artificielle &amp; éthique 3.1 一些点 les émotions sur l’intelligence artificielle: peur, angoisse, espoir, 恐惧、焦虑、希望 为什么要讲牛顿那两个定律和拉格朗日的三个点 Peut-on faire confiance à l’IA ? (Ikigai) --&gt;用这个自我认知的方法来分析我们对IA信心 savoir l’IA élargit[扩大] les connaissances？ --&gt; oblitère[泯灭] vouloir I’IA peut orienter[引导] les désirs? --&gt; manipuler[操纵] devoir l’IA peut faire évoluer[发展，演化] les règles de vie --&gt; dé-socialiser pouvoir l’IA aide à la décision[帮助决策] --&gt; conditionne ? 3.2 一些与AI和l’éthique的具体例子 3.2.1 Le véhicule à conduite automatisée: 自动驾驶技术 Le bénéfice social attendu[预期的社会效益]: la sécurité routière[95% des accidents sont dus à une erreur humaine], une mobilité accessible[无障碍交通, à des personnes en incapacité de conduire], impact sur l’environnement[fluidité et contrôle du trafic] L’apport de l’IA: analyse des alentours du véhicule, détection obstacle et stratégie d’évitement[车辆周围环境分析: 、障碍物检测和避让策略] Les tensions: vide juridique &gt; responsabilité des véhicules autonomes[自动驾驶汽车的法律真空&gt;责任], comprendre l’intention des autres acteurs[了解其他参与者的意图], vu leur diversité comment seront traitées les situations non apprises[鉴于他们的多样性，如何处理未学到的情况:conditions météo, luminosité, réflexions] 3.2.2 La parole des agents conversationnels: 会话代理的声音 3.2.3 La reconnaissance comportementale: 行为识别 3.2.4 L’armée des engins soldats: 士兵的军队 3.3 démarche de réflexion[反思过程] rationalisme：理性主义，empirisme：经验主义 3.3.1 éthiques Principes éthiques occidentaux Aristote: 亚里士多德 384 &gt; 322 avant notre ère，penseur occidental le plus complet L’éthique est un champ de la science qui doit permettre à l’homme de vivre une vie meilleure 伦理学是一个科学领域，应该使人过上更好的生活 • La vertu éthique est toujours un équilibre entre deux excès: 伦理美德总是在两种过度之间取得平衡 • L’éthique doit toujours être en recherche du Bien (épanouissement)：向善的过程 • Le but d’Aristote n’est pas de savoir ce qu’est la vertu éthique, mais de montrer comment être vertueux: 亚里士多德的目的不是要知道什么是伦理美德，而是要说明如何成为示范如何做一个有道德的人 • Il distingue les vertus intellectuelles (produits de la formation reçue) et les vertus morales (produits de l’habitude): 他区分了智力上的美德（所受训练的产物)和德行(习惯的产物) Spinoza 1632 &gt; 1677, cartésianisme (Leibniz et Descartes)[笛卡尔主义(莱布尼茨和笛卡尔)?], L’Ethique selon l’ordre géométrique[按照几何学的顺序伦理学] • Quel type de connaissance humaine mérite notre confiance?: par opinion et ouï-dire (empirisme) 凭意见和道听途说（经验主义）, par raisonnement (rationalisme) 通过推理(理性主义), par science intuitive (essence des choses) 靠直觉科学（事物的本质） Schopenhauer[叔本华] 1788 &gt; 1860, un des plus grands “influenceurs”,Le fondement de la morale Notre époque a normalisé un “bonheur” qui se réduit à un plaisir illusoire. Comme la propagande mesure ce bonheur à l’aune du succès et de la compétition, l’être humain retombe encore et toujours dans la souffrance de l’insatisfaction, qui nous pousse à remettre en cause ce qui est pourtant suffisant et juste. La prétention du “savoir-être” affichée sur les réseaux sociaux a banni les sentiments négatifs, donc ceux qui rappellent la douleur, la nostalgie et l’absurdité de l’existence. Ce refus déstructure 我们的时代已经使一种 &quot;幸福 &quot;正常化，它被简化为一种虚幻的快乐。当宣传用成功和竞争的尺度来衡量这种幸福时，人类一次又一次地陷入不满意的痛苦之中，这促使我们质疑什么才是充分和正确的。在社交网络上展示的 &quot;知道如何做人 &quot;的伪装已经驱逐了负面情绪，即那些让我们想起痛苦、怀旧和生存的荒谬的情绪。这种拒绝破坏了 Principes éthiques d’ailleurs Confucius 551 &gt; 479 avant notre ère, concilie des principes moraux et les faiblesses des humains[调和了道德原则和人性的弱点], Les Entretiens [论语]constituent les enseignements de Confucius, ils ont été rassemblés pendant 2 générations de disciples 与社会相连的éthique： 敬重：避免侮辱 宽容：调和倾听 诚信：产生信任 勤奋：确保成功 慷慨：允许人们提出 Lao Tseu Livre de la voie et de la vertu[道德经] Une éthique individuelle en société[社会中的个人道德] L’homme d’une vertu supérieure : S’il fait des largesses, il excelle à montrer de l’humanité. 如果他给予，他擅长展示人性 S’il parle, il excelle à pratiquer la vérité. 如果他说话，他擅长于实践真理 S’il gouverne, il excelle à procurer la paix. 如果他执政，他擅长于带来和平 S’il agit, il excelle à montrer de la capacité. 如果他演戏，他擅长表现能力 S’il se meut, il excelle à se conformer aux temps. 如果他的动作，他擅长的是与时俱进。 L’éthique aujourd’hui • éthique &gt; principes universels: 普遍原则 • morale &gt; principes contextuels: 背景原则 • éthique &gt; rapports de soi à soi: 自身对自身 • morale &gt; rapports de soi aux autres: 自己对他人 Les deux se confondent souvent Ethique des anciens Ethique maximaliste rechercher une vie vertueuse[有德行的生活] • Aristote &gt; tout un art de vivre, y compris en société: 整个生活的艺术，包括在社会中的艺术 • Kant &gt; devoirs moraux envers autrui et soi-même: 对他人和自己的道德义务 Ethique minimaliste se réduit à “ne pas nuire à autrui” : 简化为 “不伤害他人” John Stuart Mill &gt; pas de crime sans victime : 没有无受害人的犯罪 Ethique moderne Si l’éthique des anciens est celle des vertus à avoir soi-même, l’éthique moderne la formule en devoirs (vis-à-vis des autres) … même si c’est au détriment de soi-même ?如果说古人的伦理学是拥有自己的美德，现代伦理学将其表述为（对他人的）义务 • la non-nuisance: 无害 • l’impartialité：诚实 • l’égale considération：平等 • la justice：公正，不是向善 3.3.2 science empirisme &amp; rationalisme L’empirisme se réfère à une démarche inductive qui dérive une loi générale à partir d’observations 经验主义指的是一种归纳法，从观察中得出一般规律 Le rationalisme s’appuie sur une doctrine : la vérité a un caractère manifeste (d’évidence) 理性主义建立在一个学说上：真理是显而易见的（不言而喻） Deux conclusions majeures: 1. Pour faire partie de la science tout énoncé doit être falsifiable[要成为科学的一部分，任何陈述都必须是可被证实的] 2. Ni observation, ni raison ne peut, à elle seule, être source de la connaissance[单纯的观察和理性都不能成为知识的来源, 但是L’IA bouscule[推翻] cette affirmation–&gt;咋推翻了的？] science naturelle &amp; science artificielle science naturelle: Une science naturelle est un corpus de connaissances sur une réalité naturelle constitutive de notre monde, objets ou phénomènes (physique, biologique, etc). Ces connaissances portent sur :[关于构成我们世界、物体或现象（物理、生物等）的自然现实的知识体系。这些知识涉及] • les caractéristiques de cette réalité 这个现实的特点 • son fonctionnement interne 他的内部运作 • son comportement externe, ses interactions 它的外部行为和相互作用 science artificielle：Une science artificielle est un corpus de connaissances sur une réalité qui a été synthétisée par des êtres humains. Ces connaissances sont : [人工科学是一个关于现实的知识体系，是由人类合成的] • ses caractéristiques résultent de sa conception, conditionnée par des critères et contraintes: 它的特点源于它的设计。以标准和约束为条件 • son fonctionnement interne résulte de sa conception:其内部功能源于其设计 • elle est forgée dans un but précis, donc pour un comportement souhaité, donc connu: 它是为某一特定目的而锻造的，因此是为所需的希望的，因此也是已知的行为 intelligence artificielle une intelligence artificielle construit une décision à partir d’un univers des relations entre toutes les données qui conditionnent cette décision. [人工智能从所有数据之间的关系宇宙中构建一个决策，这些数据是这个决策的条件] Cette démarche : • s’appuie sur l’identification des données qui peuvent affecter le comportement de la réalité étudiée [是基于对可能影响所研究的现实行为的数据的识别] • ne s’appuie pas sur une connaissance préalable du comportement de la réalité étudiée[并非基于对所研究的现实行为的事先了解] • construit, par affinages successifs un modèle de la réalité étudiée qui se comporte comme elle[通过连续的细化，构建了一个所研究的现实模型，该模型的行为方式是这样的] cerveau humain vs intelligence artificielle L‘IA se comporte comme moi &gt; consciente ?[人工智能有意识吗] Mais les théories neuro-scientifiques de « structure causale » concluent que la réplication n’est pas un fonctionnement suffisant pour générer une conscience 在神经科学领域， &quot;因果结构 &quot;理论得出结论，复制并不是产生意识的充分功能 Pour d’autres, la conscience étant une notion subjective (pas de théorie sousjacente), il n’est pas possible de conclure sur l’IA 对其他领域来说，由于意识是一个主观的概念（没有基础理论），所以不可能对人工智能下结论 L’efficacité du cerveau reste inégalée[无可比拟] • dans sa rapidité d’apprentissage: l’IA de l’entreprise DeeMind a dû accumuler 900h de jeu pour atteindre un niveau acquis en 2h par un humain • l’apprentissage humain est social: c’est-à-dire se transmet : nous sommes des « homo docens », la transmission est au fondement de la socialisation • l’apprentissage humain est long: la plasticité cérébrale dure 20 ans : le cerveau se modèle, cette plasticité est stimulée par l’éducation • le cerveau humain a la faculté d’abstraction[La modélisation建模,La conceptualisation概念化,L’innovation de rupture颠覆式创新] 3.3.3 éthique &amp; science Éthique scientifique Éthique scientifique … du « chercheur » probité, honnêteté, sincérité, transparence 感觉倾向于描述科学家的道德：正直、诚实、真诚、透明这些 Ethique de la science En science naturelle En science de l’artificiel Pionnière[护理学] bio-éthique ：la bienfaisance[恩惠], non-malfaisance[非盈利性], l’autonomie[自主性], la justice. Il s’agit nécessairement de faire le bien. 向善的 une éthique du numérique une éthique du numérique: le numérique n’est pas destiné à faire le bien, mais pour répondre à un besoin concret, le numérique traite de l’information 数字的目的不是为了做好事，而是为了满足具体的需要,数字技术处理的是信息 une éthique des données Différentes perceptions des données • aux USA, la donnée est un produit commercial • en Asie, la donnée est un élément de pouvoir[权力的一个要素] • en Europe, la donnée est sacralisée[神圣的] et protégée des convoitises–&gt;RGPD une éthique du traitement des données • contrôle humain (respect de l’autonomie humaine) 人的控制（尊重人的自主性） • la conformité (au CdC), la robustesse technique (qualité) et la sécurité (résistance aux intrusions) 遵守（对CoP）、技术稳健性（质量）和安全性（对入侵的抵抗） • protection de la vie privée dans l’exploitation des données (RGPD) 数据利用中的隐私保护 (RGPD) • la loyauté et transparence des algorithmes (traçabilité, explicabilité, communication) 算法的公平性和透明度（可追溯性、可解释性、沟通性） • justice, équité et non-discrimination des résultats 公正、公平和不歧视的结果 • bien-être sociétal utilisateur et environnemental 用户和环境的社会福利 • responsabilité et redevabilité 责任与问责 une éthique limitée du traitement des données Les 3 lois de la robotique[机器人的3大法则] • Loi 1 : Un robot ne peut pas porter atteinte à un être humain ni, en restant passif, permettre qu’un être humain soit exposé à un danger. 机器人不得伤害人类，或通过保持被动，使人类处于危险之中 • Loi 2 : Un robot doit obéir aux ordres donnés par un être humain, sauf si contradiction avec la Loi 1. 机器人必须服从人类发出的命令，除非这些命令与法则1相抵触 • Loi 3 : Un robot doit protéger son existence, sauf si contradiction avec la Loi 1 ou la Loi . 机器人必须保护其存在，除非它与法律1或法律2相冲突 P33不想看了 problèmes éthiques propres à l’intelligence artificielle adopter de nouvelles règles d’usage des données: qui sont en grand nombre, très diversifiées, qui, directement ou non, décrivent nos vies 为数据的使用制定新的规则：这些数据数量众多，高度多样化，直接或间接地描述了我们的生活 adapter la protection des droits et des libertés: aux groupes d’individus … et non plus aux individus seuls, identifier la responsabilité en cas de dérive ou biais 对权利和自由的保护进行调整：针对个人群体…而不再是针对个人，在出现偏移或偏见的情况下确定责任 lever l’opacité du fonctionnement de l’algorithme: souhaitée par le souci de la PI des entreprises financeurs 消除算法操作的不透明性：资助公司的知识产权问题所希望的 conséquences sociétales des champs d’application 适用领域的社会后果 une éthique générale du développement de l’IA ​ 10个原则 Principe de bien-être • améliorer les conditions de vie, santé et conditions de travail • permettre d’exercer ses capacités physiques et intellectuelles • ne doit pas augmenter le stress, l’anxiété, le harcèlement Principe du respect de l’autonomie • permettre à chacun de réaliser sa propre conception de la vie • éviter les dépendances par une confusion entre IA et humains • ne doit pas mettre en œuvre des mécanismes de surveillance, d’évaluation ou d’incitation contraignants Principe de protection de l’intimité et la vie privée • protéger des espaces d’intimité non surveillés • protéger l’intimité de la pensée et des émotions • pas de profil personnalisé pour influencer le comportement • avoir un contrôle étendu sur ses données personnelles Principe de solidarité • favoriser les relations humaines et réduire l’isolement • favoriser le travail collaboratif • ne pas simuler des comportements cruels par des robots Principe de participation démocratique • une IA qui peut affecter la qualité de vie des personnes doit être intelligible et justifiable • le code des algorithmes doit être accessible aux autorités • la découverte d’effets non prévus doit être signalée Principe d’équité • ne pas créer de discriminations sociales, religieuses, ethniques… • éliminer les relations de domination fondées sur la richesse, le pouvoir, la connaissance • bénéficier économiquement à tous Principe d’inclusion de la diversité • ne pas induire l’uniformisation ou la normalisation • respecter les multiples expressions de toutes les diversités • pour chaque catégorie de service, une offre d’IA diversifiée Principe de prudence • restreindre la diffusion d’IA pouvant présenter un danger • satisfaire des critères de fiabilité, sécurité intégrité… testés • prévenir des risques d’usage néfaste des données et de l’IA Principe de responsabilité • seuls des êtres humains peuvent être tenus pour responsables • une décision qui affecte la vie doit être prise par une personne Principe de développement soutenable • efficacité énergétique des infrastructures des IA • filière de maintenance, réparation et recyclage • lutter contre le gaspillage des ressources naturelles","link":"/2022/11/12/INDUR_DS/"},{"title":"LeetCode","text":"LeetCode 冲冲冲！ 13. Roman to Integer 8.31 罗马数字(str)转数字(int) 123456789101112131415161718192021222324class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; dit = {'I':1,'IV':4,'V':5,'IX':9,'X':10,'XL':40,'L':50,'XC':90,'C':100,'CD':400,'D':500,'CM':900,'M':1000,'&quot;':0} keys = dit.keys() a = list(s) sum = 0 i = 0 while i&lt;len(a)-1: if(''.join([a[i],a[i+1]]) in dit): sum += dit[''.join([a[i],a[i+1]])] i += 1 else: sum += dit[a[i]] i += 1 if i == len(a)-1: sum += dit[a[i]] return sum 输入输出搞半天，但python真的快乐！（已经不想去去想C++怎么写了 今日python小收获：获取字典所有的键值：dit.keys(),根据键值查字典的value:dit[key] 9. Palindrome Number 9.1 数字回文判断 123456789101112131415class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; x = list(str(x)) i = 0 while (2*i) &lt; (len(x)+1) : if x[i] != x[-(i+1)]: return 0 break else: i += 1 return 1 20.Valid Parentheses 9.2 符号判断 用stack思想实现的，左边入栈，遇到右边与栈顶匹配，匹配成功栈顶弹出，否则返回false 123456789101112131415161718192021class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; dict = {'(':')','[':']','{':'}'} res = [] for item in s: if item == '&quot;': pass elif item in dict: res.append(item) else: if(len(res) and dict[res[-1]] == item): del res[-1] else : return 0 break return res == [] 如果大概没有记错的话，这就是去年algo的期末考试题（靓女流泪） 补一个C++版！ 1234567891011121314151617181920212223242526272829bool pipei(char a, char b){ if(a == '(' &amp;&amp; b == ')') return 1; else if(a == '[' &amp;&amp; b == ']') return 1; else if(a == '{' &amp;&amp; b == '}') return 1; else return 0;}bool isValid(string s){ char c; int length = s.size(); stack&lt;char&gt; res; for(int i=0;i&lt;length;i++) { if(s[i] == '(' || s[i] == '[' || s[i] == '{') res.push(s[i]); else { if(res.empty()) return 0; else { if(pipei(res.top(),s[i])) res.pop(); else return 0; } } } return res.empty();} 1143. Longest Common Subsequence 9.6 两个字符串的最长公共子序列–&gt;经典动态规划问题 C++ 123456789101112131415int A[1001][1001] = {0};int longestCommonSubsequence(string s1, string s2) { int LenS1 = s1.size(),LenS2 = s2.size(); for(int i=0;i&lt;LenS1+1;i++) { for(int j=0;j&lt;LenS2+1;j++) { if(s1[i] == s2[j]) A[i+1][j+1] = A[i][j] +1; else A[i+1][j+1] = max(A[i][j+1],A[i+1][j]); } } return A[LenS1][LenS2]; } Python 评论区抄的 123456789def longestCommonSub(s1,s2): A = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)] for i,c in enumerate(s1): for j,d in enumerate(s2): if(c == d): A[i+1][j+1] = A[i][j] + 1 else: A[i+1][j+1] = max(A[i][j+1],A[i+1][j]) return A[-1][-1] 就是如果一旦引入numpy的zeros那个来定义A的话时间复杂度会蹭蹭蹭的上去很多 然后今日python小技巧： enumerate()函数 用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列 12345seasons = ['Spring', 'Summer', 'Fall', 'Winter']list(enumerate(seasons))输出：[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list(enumerate(seasons, start=1)) # 下标从 1 开始输出：[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 常用在这道题这种的循环里面 python中的二维数组 -引入numpy A = np.zeros((m, n), dtype=np.int) -列表 A = [[0 for i in range(m)] for j in range(n)] 14. Longest Common Prefix 9.7 最长公共前缀 就硬遍历 c++ 1234567891011121314151617181920string LCP(strs){ string res=strs[0]; for(int i=1;i&lt;strs.size();i++) { if(res.size() &gt; strs[i].size()) res = res.substr(0,strs[i].size());//注意这里考虑res比字符串长的情况 for(int j=0;j&lt;strs[i].size();j++) { if(res[j] != strs[i][j])//C++自动处理越界了？--&gt;当j大于res时，res[j]直接是空 { if(!j) return &quot;&quot;; res = res.substr(0,j); break; } } } return res;} python 123456789101112131415def LCP(strs): res = strs[0] strs = strs[1:] if not res: return &quot;&quot; for curr in strs: if len(res) &gt; len(curr) : res = res[:len(curr)] for i,ch in enumerate(curr): if i &gt;= len(res) : #考虑i大于res长度的情况 break if(res[i] != ch): if not i: return &quot;&quot; res = res[:i] break return res python小技巧：enumerate是先下标，再数字，start也不是说取后几个，而是下标从几开始排 突然觉得C++天下第一 21. Merge Two Sorted Lists 9.13 合并子串的问题 我写的辣鸡代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { if(!list1) return list2; ListNode *p2,*head,*p3,*p1,*p1_next; p2 = list2; head = list1; p1 = head; p1_next = p1-&gt;next; while(p2) { p3 = p2-&gt;next;//p3是为了保存L2下一节点继续进行遍历 if(p1-&gt;val &gt; p2-&gt;val) { p2-&gt;next = p1; head = p2; } else { while(p1_next &amp;&amp; p1_next-&gt;val &lt; p2-&gt;val) { p1 = p1-&gt;next; p1_next = p1-&gt;next; } if(!p1_next) { p1-&gt;next=p2; return head; } p2-&gt;next=p1_next; p1-&gt;next=p2; } p1 = p2;//开始遍历的位置应该从这个被插入的点开始 p1_next = p1-&gt;next; p2 = p3; } return head; } 一些正确的解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//leetcode评论区//递归ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { //递归终止条件 if(!l2 &amp;&amp; !l2) return nullptr; else if(l1 == NULL) return l2; else if(l2 == NULL) return l1; else { if(l1 -&gt; val &lt;= l2 -&gt; val) { l1 -&gt; next = mergeTwoLists(l1 -&gt; next, l2); return l1; } else { l2 -&gt; next = mergeTwoLists(l1, l2 -&gt; next); return l2; } } }};//非递归ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { if(list1 == NULL) return list2; if(list2 == NULL) return list1; ListNode * head = list1; if(list1 -&gt; val &gt; list2 -&gt; val) { head = list2; list2 = list2 -&gt; next; } else { list1 = list1 -&gt; next; } ListNode *curr = head; while(list1 &amp;&amp; list2) { if(list1 -&gt; val &lt; list2 -&gt; val) { curr-&gt;next = list1; list1 = list1 -&gt; next; } else { curr-&gt;next = list2; list2 = list2 -&gt; next; } curr = curr -&gt; next; }//确实确实，一个head不动，一个curr始终指向当前遍历的位置来回横跳就行了的呜呜呜 // 处理余下的部分 if(!list1) curr -&gt; next = list2; else curr -&gt; next = list1; return head; }}; python: 直接摆 12345678910111213141516171819202122232425262728293031323334353637383940def mergeTwoLists(list1, list2): if not list1: return list2 if not list2: return list1 head = list1 if(list1.val &gt; list2.val): head = list2 list2=list2.next else: list1=list1.next curr = head while list1 and list2: if list1.val &lt; list2.val: curr.next=list1 list1=list1.next else: curr.next=list2 list2=list2.next curr = curr.next if not list1: curr.next=list2 else : curr.next=list1 return head#评论区def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: #感觉思想差不多，但写法很python就是 cur = dummy = ListNode()#就，后续操作只改变cur不改变dummy while list1 and list2: if list1.val &lt; list2.val: cur.next = list1 list1, cur = list1.next, list1 #注意这里藏着cur的递归 else: cur.next = list2 list2, cur = list2.next, list2 if list1 or list2: cur.next = list1 if list1 else list2 return dummy.next 56.Merge Intervals 合并重叠部分的区间 思路： 将原序列按起始坐标排序，然后把第一个加入结果集，遍历后续区间，如果重叠就更新，不重叠便直接加 1234567891011121314def merge_(intervals): out = [] for i in sorted(intervals, key=lambda i: i[0]):#按起始坐标进行排序 if out and i[0] &lt;= out[-1][1]: print(i[0]) print(out[-1][1]) out[-1][1] = max(out[-1][1], i[1])#处理重叠 else: print(i[0]) if out: print(out[-1][1]) out.append(i)#不重叠添加进去 return outintervals = [[1,3],[5,7]]print(merge_(intervals)) 704. Binary Search 123456789101112131415161718192021222324252627#递归find = 1def search(nums,target): global find if not nums: find = 0 return -1 mid = len(nums)//2 if target &gt; nums[mid]: return mid+1+search(nums[mid+1:],target) elif target &lt; nums[mid]: return search(nums[:mid],target) else: return mid #非递归def search_(nums, target): d = 0 f = len(nums)-1 while(d&lt;=f): mid = (d+f)//2 if(target == nums[mid]): return mid elif target &gt; nums[mid]: d = mid+1 else: f = mid-1 return -1 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/08/31/LeetCode-Pyhton/"},{"title":"INDUR_MOOC","text":"MOOC 课上要求看的MOOC Partie1: Introduction: Les impacts environnementaux du numérique Partie2: Des équipements non renouvelables Des services numériques très matériels Partie1: Introduction: Les impacts environnementaux du numérique Introduction Le numérique et l’environnement: le numérique nous offre une formidable capacité de collecter, stocker et traiter ces données. Et cela nous aide à comprendre notre impact sur l’environnement. Alors, que sait-on de l’impact environnemental de l’homme sur le climat ? Et que nous disent ces indicateurs sur l’impact environnemental du numérique ? Ensuite, nous vous proposons de vous familiariser avec des outils mathématiques et informatiques essentiels pour comprendre et analyser les indicateurs. 数字技术与环境：数字技术帮助收集数据，有助于我们更好的了解环境。那么，我们对人类对气候的环境影响了解多少？这些指标告诉我们数字技术对环境的影响是什么？要学会使用计算机工具对这些指标进行分析。 Que pensez-vous du numérique ? 1.A l’heure où les problèmes environnementaux sont pointés du doigt, quel est l’impact du numérique sur l’environnement ? Là aussi, les avis divergent également : pour certains, le numérique est LA solution, pour d’autres, il ne ferait qu’aggraver le problème. Et vous qu’en pensez-vous ? -我觉得数字化对环境还是好的。数据的分析可以更直观发现问题并且提出有效的措施。 2.Indiquez quelques mots que vous associez spontanément[自发的] aux impacts environnementaux du numérique. Numérique et prise de conscience[意识] écologique[生态] : petite histoire 建模等计算方式更好的模拟和预测环境，并给出更好的解决方法 IPCC悖论：数字化越成功，发现的问题就越多？观察的越多， 环境足迹 数字化没有成功转型，只是在叠加[使用电子设备的同时也没有减少对树木的砍伐，石油的使用] Fiche concept: 概念表 数字不虚拟，有物理现实：光纤电缆 终端、云计算与数据中心[关于网络的另一端]–&gt;数据中心对环境的影响：2015 年，数字占全球温室气体排放量的 4%，而航空占 2.5%。在这 4% 中，有 25% 与数据中心相关联。数据中心的用电量约占全球用电量的 3%。 建模、数值模拟与环境 Quels indicateurs[指标] pour évaluer l’empreinte[足迹] numérique ? L’effet de serre[温室效应] provoque le réchauffement[变暖] de la plantet–&gt;OUI，没有的话地球在15°左右 Les activités humaines produisent-elles des gaz a effet de serre?–&gt;OUI Afin de comparer les effets sur le réchauffement global des différents gaz a effet de serre, les scientifiques ont choisi un gaz de référence. Lequel?–&gt;CO2 A ce jour, quel est approximativement le réchauffement global généré par les activités humaines depuis la révolution industrielle[1850-1900]?–&gt;+1°C，每10年+0.2°C Si ces émissions continuent a la vitesse actuelle, quand atteindrons-nous un réchauffement de +1.5°C depuis le début de la révolution industrielle?–&gt;2030到2052 Quelle est la consommation électrique mondiale liée aux usages numériques?–&gt;10%,每年增加6%，每12年翻一番 Fiche concept: Indicateur: est la traduction chiffrée d’un phénomène ou d’un concept. Indicateurs environnementaux: Les indicateurs peuvent être classés en fonction de l’enjeu écologique auquel ils correspondent. Par exemple le ministère de l’écologie a sélectionné 22 indicateurs essentiels pour suivre 4 enjeux écologiques majeurs : le changement climatique, la perte de biodiversité, la raréfaction des ressources et la multiplication des risques sanitaires environnementaux 生态部选择了 22 项基本指标来监测 4 大生态挑战：气候变化、生物多样性丧失、资源稀缺和环境健康风险倍增 Deux indicateurs environnementaux simples: Émissions de gaz à effet de serre et Empreinte en eau Un exemple d’indicateur environnemental synthétique : l’Empreinte Écologique (EE) 以国家为单位计算，生产+进口-出口 数字设备： L’empreinte environnementale du numérique mondial[数字环境足迹]：2019全球340亿台设备, 2.23亿吨。法国：6.31亿台设备，700万吨，数字消费占法国电力的8.3% Eco-avertis : Lire et questionner les indicateurs Êtes-vous victime du biais exponentiel[指数偏差]? Quel lien peut-on faire entre performance environnementale et usage d’Internet ? 横坐标：互联网使用人口，纵坐标：碳足迹 La sobriété numérique[数字清醒] La sobriété consiste à faire décroître voire disparaître des usages, des valeurs ou des comportements. Elle ne nécessite pas le développement de nouvelles techniques ou technologies. Elle se rapporte au suffisant relativement aux besoins et aux enjeux d’équilibre écologique et d’équité. On pourrait parler de « faire moins avec moins ». 减少甚至消除用途、价值观或行为。它不需要开发新技术或新技术。它涉及与生态平衡和公平的需求和问题有关的充分条件。我们可以谈论“事半功倍”。 Conclusion 全球变暖，环境衡量指标，数字行业的增长极其负面影响 Partie2: Des équipements non renouvelables 数字化的背后的设备是不可再生的 Pour démarrer : Combien possédez-vous d’équipements connectés ? L’empreinte environnementale des équipements numériques Vie et mort d’un smartphone：手机制造需要贵金属，开采和制造手机会污染水土流失污染环境，废弃手机不可回收再次造成污染 Cycle de vie d’un smartphone 对环境污染的排序：Production &gt; Usage[电力消耗] &gt; Transport &gt; Traitement de fin de vie Fiche concept ACV: analyse de cycle de vie, est une méthode d’évaluation quantifiée des impacts environnementaux d’un produit (qui peut être un bien ou un service). 具有多标准和多步骤的特点： Multicritère : différentes catégories d’impacts environnementaux sont étudiées (potentiel de réchauffement climatique, épuisement des ressources abiotiques, création d’ozone photochimique, pollution de l’eau, de l’air, des sols, toxicité humaine, perte de biodiversité…). Ces impacts relèvent de différentes échelles spatiales (du local au global) et temporelles (du court terme au long terme). Multi-étapes : les différentes phases du cycle de vie sont prises en compte (extraction des matières premières, fabrication, transport, usage, fin de vie). 分下面4个主要步骤进行： Objectifs et champ de l’étude：研究的目标和研究结果的用途 Inventaire du cycle de vie：核心，分解特定功能单元生命周期中涉及的生产、转换或者消费阶段。 Évaluation des impacts environnementaux Interprétation et mise en forme des résultats Pourrons-nous continuer longtemps à fabriquer des équipements informatiques ? Mais fabriquer toujours plus se heurte aux limites de notre planète：不可再生资源，无限可回收的不现实[热力学第二定律和技术限制] –&gt; si le numérique pèse sur l’épuisement des ressources ou si finalement 数字化会让资源枯竭吗 一些问题： -Combien de smartphones ont été vendus dans le monde en 2019?–&gt;1.4 milliard d’unités. -Combien y a-t-il d’éléments différents dans un smartphone?–&gt;plus de 50 -Ou t -Pour quelles raisons utilise-t-on l’or[黄金] dans un smartphone?–&gt;Conductibilité, Ne rouille[生锈] pas -Ou trouve-t-on du tantale dans un smartphone?–&gt;Dans les condensateurs[电容器]. -Pour quelles raisons utilise-t-on du tantale dans un smartphone?–&gt;Il est extrement résistant et il permet la miniaturisation -Ou trouve-t-on de l’indium dans un smartphone?–&gt;Dans le film transparent[透明膜] qui recouvre l’écran. Fiche concept：DEEE Quels métaux dans les smartphones ? 稀土金属，集成电路需要半导体[硅] DEEE：废物，废弃的电气和电子设备，它们包括来自使用电源插座、电池或蓄电池的设备的所有废物，以及它们的所有组件和与之相关的消耗品。 Depuis 2018 en France, les EEE sont classés en 7 catégories d’équipements (échanges thermiques, écrans, lampes, gros électroménager, petit électroménager, informatique) avec un objectif de traçage et de suivi. 法国将 EEE 分为 7 类设备（换热器、屏幕、灯具、大型家用电器、小型家用电器、IT）。 DEEE的处理：La prise en charge des équipements collectés mène à plusieurs voies possibles : la préparation à la réutilisation (environ 2% en France en 2019) ; le recyclage (environ 75%) ; la valorisation énergétique (environ 10%) ; l’élimination c’est-à-dire mise en décharge et enfouissement, ou incinération sans récupération d’énergie (environ 14%). 准备再利用（2019 年在法国约为 2%）；回收（约 75%）；能量回收（约 10%）；处置，即填埋和填埋，或没有能量回收的焚烧（约 14%）。 实际上，只有 75% 的收集到的 WEEE 被注入到真正的 WEEE 回收系统中（这个数字根据设备的类型而变化很大）。考虑到法国的回收率（50%），这最终仅代表 WEEE 产生量的 38%（充其量）。回收的6个阶段：拆解，碎成小块，磁铁对铁元素进行电磁分离，光学分选分离电子卡，涡流分离有色金属，浮选或光学分离塑料。 限制：回收率低，回收的过程耗费能量，危害环境 Éco-consommateur : Recycler n’est pas gagner ! [未完] Partie3: Des services numériques très matériels 除了数字设备对环境的影响外，数字服务对环境也会造成影响 数字服务：services numériques ，包括nos applications, logiciels de messagerie, interface de streaming Quelle est la part du numérique qui a le plus d’impact environnemental ? Communication numérique: Le déploiement d’internet et des réseaux télécoms est à l’origine de nouveaux modes de communication. La communication virtuelle est l’un des services les plus répandus. En quelques clics, nous pouvons faire passer des messages quasi instantanément à l’autre bout du monde. 数字通信：互联网和电信网络的部署导致了新的通信模式。虚拟通信是最广泛的服务之一。只需点击几下，我们就可以几乎立即向世界的另一端发送信息。 petite sondage： -Combien de mails recevez-vous en moyenne par jour?–&gt;Une personne reçoit en moyenne 39 mails par jour, avant d’arriver dans votre boîte mail, le mail parcourt en moyenne 1500km -Mais nous sommes loin d’être seuls sur la planète. Selon vous, combien de mails transitent par minute dans le monde?–&gt;190 millions Toujours plus d’outils de communication: Dans les années 90, le SMS était limité à 160 caractères et le mail était envoyé uniquement depuis un ordinateur. 30 ans après, nos modes de communication ont bien changé. Nous avons multiplié nos outils et nous sommes passés de quelques caractères écrits à des centaines de photos et de vidéos envoyées quasi instantanément depuis nos mobiles. Alors, tout cela est-il virtuel? Cela n’q t’il pas d’impacts? Pas si simple… 越来越多的通信工具：在20世纪90年代，短信被限制在160个字符以内，电子邮件只能从电脑上发送。30年后，我们的沟通方式已经改变。我们的工具成倍增加，从几个书面字符到几百张照片和视频，几乎瞬间从我们的手机上发送。那么，这一切都是虚拟的吗？它没有影响吗？没有那么简单… 看到这里也并没有对标题[对环境影响最大的数字化部分是什么]做出回答嘛 Les services numériques sont-ils virtuels ? 应用程序：在云服务器无法自己运行，背后一个完整的生态系统，包括一系列基础设施建设[电话，电缆，无线网络，手机信号塔，数据中心] 数字服务背后的一切：硬件；网络：海底电缆，光纤，路由器；数据中心：机器外处理，消耗电力，发热，发电机，备用电池； 数据越多，基础设施越多，基础设施越多，数据越多。 自动播放。占据。 Le voyage d’un mail Ce n’est pas magique, c’est technologique! L’envoi d’un mail nécessite une infrastructure[基础设施] complexe qui dépend des terminaux utilisés, des services de messagerie employés aussi bien par l’émetteur[发射器] que par le récepteur. Ici le schéma technologique est relativement simple. Mais si Bob avait mis en copie une dizaine d’amis, c’est comme si 10 messages étaient partis individuellement : chaque message va transiter par son propre serveur de réception, vers un récepteur différent. De quoi augmenter rapidement la complexité du schéma ! Idem pour les pièces jointes qui seront stockées autant de fois que nécessaire ! Bref, même si tout cela se produit en seulement quelques secondes ! Ce n’est pas magique ! Fiche concept: Qu’est-ce qu’un service numérique? Le service numérique désigne l’ensemble des ressources humaines, logicielles et matérielles nécessaire à la mise à disposition d’un service. 数字服务指定提供服务所需的所有人力、软件和物质资源。例如，提供电子邮件服务、在 Youtube 上观看视频、高性能计算的实现、加密货币金融交易的实现、网页的显示……行业标准ITU L. 1410将数字服务引入为使用数字设备和/或电信网络为一个或多个用户提供价值。 Ainsi, le service numérique est constitué d’un ensemble de logiciels, matériels, réseaux et infrastructures, et d’autres services numériques opérés par des acteurs. 因此，数字服务由一组软件、硬件、网络和基础设施以及由各种参与者（人力资源）（出版商、设计师、架构师、网络和服务运营商、互联网接入供应商、用户、 ETC）。这种通过数字服务进行的衔接使得满足一个或多个需求成为可能。 数字服务不是软件，由一组人力、材料和软件资源组成. **Le cycle de vie d’un service numérique: **设计–&gt;生产–&gt;部署–&gt;使用–&gt;维护–&gt;报废 **Les acteurs engagés dans le déploiement d’un service numérique: ** 用户，服务操作者，开发，架构，主机，网络运营商 Comment et pourquoi accumule-t-on autant de données ? 数据的堆积：人类产生的 90% 的数据将在过去 2 年中产生，90% 的存储数据将无用。例如，假设每辆自动驾驶汽车每天为大约 1 小时 30 天的流量收集 4TB 的数据（即使只有一部分通过网络）。世界上有数百亿个连接对象也在捕获和传输数据, 传输和存储所有这些信息对环境的影响并非微不足道。数据增长需要处理、格式化、集中和共享，这既耗时又耗资源。 以照片为例：分享照片被上传至云端，但云端处理需要存储成本。 Quelle est l’empreinte environnementale d’un service numérique ? Dans cette activité, nous vous proposons d’analyser l’empreinte environnementale d’une navigation web et de matérialiser l’impact des différentes fonctionnalités proposées : lecture d’article, de vidéo, de présentation interactive. Pour effectuer cette activité, nous avons choisi l’outil Carbonalyser qui permet de visualiser la consommation électrique et les émissions de gaz à effet de serre associées à votre navigation internet. Il en existe d’autres. Attention les hypothèses et données de base ne permettent pas de se baser sur cet outil pour mesurer finement les émissions deg eq C02 liées à votre navigation. Le résultat n’est donc pas à prendre comme une mesure. Par contre, cet outil vous permettra d’évaluer la différence relative d’impacts de sites web différents. Vous allez pour cela installer une extension sur votre navigateur, puis nous vous guiderons pour naviguer dans le web avant d’analyser les résultats de Carbonalyser. Cette application ne fonctionne que sur Firefox. 用火狐浏览器的拓展工具Carbonalyser分析浏览网页不同功能(文章，视频，交互)时的电力消耗和温室气体排放的比较。 问的一些问题： -Dans l’article Comment marche internet à quoi est comparé le navigateur[浏览器]？–&gt;voiture **Comment marche internet: **Internet 和 Web是不一样的。Internet相当于公路网，Web相当于商店。 -Dans la [vidéo][https://www.youtube.com/watch?v=GqD6AiaRo3U&amp;list=PLWvGMqXvyJAPvxp2IPUAbKmr_ULtR8Nbh&amp;index=4] comment accède-t-on au site www.ilovepigeon.com ?–&gt;un moteur de recherche. 网站的知识: web: 信息的集合，由数10亿个衔接文件组成。Le web c’est un réseau d’informations Internet: C’est le réseau informatique qui permet de les transporter. Site: C’est un ensemble de pages contenant de l’information. 也叫site web. 文档储存在Web服务器上，客户端和服务器通过 Web 进行通信，根据 HTTP 协议","link":"/2022/09/16/INDUR_MOOC/"},{"title":"MATHS-TP1","text":"序 MATHS_TP1: Initiation Matlab – Equation de la chaleur 1D Initiation 注释：% 显示：disp、fprintf vecteur: x = [x1,x2……,xn] %空格或者逗号都可以；vecteur colonne 冒号：5：-1：1 %表示5到1以-1为间隔的vecteur linspace：是Matlab中的均分计算指令，用于产生x1,x2之间的N点行线性的矢量。其中x1、x2、N分别为起始值、终止值、元素个数。若默认N，默认点数为100","link":"/2022/02/22/MATH-TP1/"},{"title":"MVDNet","text":"序 记录第一次看论文与第一次独立运行深度学习代码~ 读论文 脉络梳理于XMind中 CNN概述 对图像进行识别 鲁棒性和抗干扰性都很强 卷积 卷积核/特征提取器：将图像拆分成对应的特点，查看被识别图像有无对应的卷积核来确认是否为目标物体。 卷积运算：用卷积核对原图像素（矩阵）进行扫描（点乘和），形成的新矩阵就叫特征图。特诊图的一些值(如行列式的值这种)能够反映与卷积核的相似度。比如： 池化 池化/下采样：多个卷积核(特征)会导致计算量增大，为解决这个问题提出的概念，本质是缩小特征图。池化方式有：最大池化（选择被扫描区域内的最大值）和平均池化（取被扫描区域内的平均值） 比如刚刚那个： 跑项目 不太顺利 项目地址：https://github.com/qiank10/MVDNet 环境配置 anaconda+linux+python3.7+cuda11.0+pytorch1.7 Pytorch 创建环境：conda create -n MVDNet python=3.7 激活/进入：conda activate MVDNet pytorch下载 1.查看cuda版本信息：nvcc --version或者nvidia-smi； 2.注意这里不能根据官网https://pytorch.org/get-started/locally/ 入口直接选择下载（如果正好是cuda10.2这种应该是ok的），不然后续不能配合cuda使用。 正确操作应该是到这里https://download.pytorch.org/whl/torch_stable.html 去找对应的下载进行安装(pip install就可以) 参数理解：cu110–&gt;cuda 11.0，torch版本自选，cp37–&gt;python3.7，后面就是win/linux了 检查 python–&gt;import torch–&gt;torch.cuda.is_available() Detectron2 Pycocotools 挺好装的而且没啥幺蛾子 数据准备 下载数据集：https://oxford-robotics-institute.github.io/radar-robotcar-dataset/， 用学校邮箱注册 可恨！等了一个月才回复，然后还在垃圾邮箱里面找不到了=_= 最后下载免费的数据集来后续操作的 在这里疯狂报错，主要是缺包和语法更新两个问题 报错no module named scipy或者cv，装scipy和opencv库 12pip install scipypip install opencv-python 报错 AttributeError: ‘scipy.spatial.transform.rotation.Rotation’ object has no attribute ‘as_dcm’：要把所有的as_dcm改成as_matrix 训练 报错import，需要到detectron2执行 1python setup.py build develop 报错“No such file or directory: ‘data/RobotCar/object/radar/1547122770869274.jpg’”：没解决 结语 武运昌隆","link":"/2022/05/20/MVDNet/"},{"title":"PAPY_CM1","text":"PAPY_CMS 期末复习做的xmind CHAP 2 CHAP 3 CHAP 4 突然感慨 2个月的python有种的会了很多有啥的不会的感觉 祈祷不挂！","link":"/2022/10/29/PAPY_CMS/"},{"title":"PAPY_CM1","text":"PAPY_CM1 Lucas Lestandi Introdution -mutiplateforme, langage interprété（解释） et interractif -python robuste,la lisibilité et la maintenance, paquet pour la distribution sur d’autres machines y compris des dépendances Plan 1.python:安装环境啥的–&gt;2hCM+4hTP 2.数据结构：OPP,code robuste(architecture,introspection,exceptions)–&gt;2hCM+6hTP 3.avec modules:os,sys,subprocess,numpy,scipy,matplotlib,扩展包（conda或者pip） 4.看到个C++ CM1 conda: python环境，anaconda划分python环境，miniconda IDE：vscode jupyter：mixe code, markdown et cellules “raw” 数据类型：complex表示复数 1234567891011121314import sysall_paths = sys.pathfor path in all_paths: print(path)def a(string): longueur=() try: assert(type(string) is str) longueur=len(string) except Exception as err: print(f&quot;Unexpected {err=},{type(err)=}&quot;) return longueurprint(a(all_paths[0]) assert: 断言, 用于判断一个表达式，在表达式条件为false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在Linux 系统下运行，可以先判断当前系统是否符合条件。 try…except结构：捕捉异常，更一般加else 函数 12def 函数名(参数):#这里的参数*arg就是表示随意取几个 函数体#不写的话加上pass占位","link":"/2022/09/06/PAPY_CM1/"},{"title":"PFONC_CM1","text":"PFONC_CM1 Introduction 基于函数的编程，接近数学声明式编程（programmation déclarative） 属性:transparence référentielle：参考透明,immutabilité：不变性 ​ transparence référentielle:并行，没有指针，全局变量或者输入输出 ​ immutabilité：被操纵对象的值永远不能改变 Constructions de base 复合函数 12345square x = x*xinc x = x+1f x = inc(square x)f x = (inc.square) x 条件式 if-then-else 123f n = if n == 0 then 1 else if n == -1 then 2 else 3 然后不等于是 /= gardée(|+ otherwise) 123456caculate' a b c | b == '+' = Just (a + c)--不太知道这里的just是啥 | b == '-' = Just (a - c) | b == '*' = Just (a * c) | b == '/' &amp;&amp; c == 0 = Nothing | b == '/' = Just (a / c) | otherwise = Nothing case-of 123f n = case n of 0 -&gt; 1 _ -&gt; n * f (n-1)--下划线_表示任意 递归: récursivité Une fonction récursive possède（有） : • un (ou plusieurs) cas général récursif • un (ou plusieurs) cas de base non récursif L’évaluation d’une fonction récursive se fait sur le modèle d’une pile[堆栈] Fonction récursive terminale 定义：Pour une fonction f définie en utilisant une fonction g, l’évaluation de g est dite terminale (tail évaluation/call) si elle fournit directement la valeur de f sans opération supplémentaire. 对于一个用函数g定义的函数f，如果g直接提供了f的值而没有任何额外的操作，那么g的évaluation被称为terminale 如果一个递归函数的所有递归的évaluation都是terminale的，那么他就是Fonction récursive terminale 例 123456f' 0 r = rf' n r = f' (n-1) (r*n)f n = f' n 1main = print(f 3) Exercices EX1: PUISSANCE 1.Écrire une fonction récursive qui calcule la puissance nen^ene d’un nombre 12puissance x 0 = 1puissance x n = x * puissance x (n-1) Utiliser le fait que x2n=(x2)nx^{2n}=(x^2)^nx2n=(x2)n pour améliorer la fonction. 12puissance' x 0 = 1puissance' x n = if even n then puissance' (x*x) (div n 2) else x * puissance' (x*x) (div n 2)--even应该是在说n是偶数，odd奇数 3.Quelles sont les complexités temporelles des deux versions ? 方法1是关于n的线性，方法2是关于log2nlog_2nlog2​n 的。 EX2: Fibonacci Écrire une fonction récursive terminale qui calcule le terme d’indice n de la suite de Fibonacci 12345678fibonacci 1 = 1fibonacci 2 = 1fibonacci n = fibonacci(n-1) + fibonacci(n-2)--terminalefibonacci' 0 _ n2 = n2--不是很懂这里fibonacci' n n1 n2 = fibonacci'(n-1) (n1+n2) n1fib n = fibonacci' n 1 0 EX3:La hauteur palindromique 1234567r' 0 m = mr' x m = r' (div x 10) (10*m + mod x 10)r x = r' x 0--判断回文数字:n == r(n)hpal n = if n == r n then 0 else 1 + hpal (n + r n)--太妙了太妙了太妙了","link":"/2022/09/06/PFONC_CM1/"},{"title":"PAPY_CM1","text":"PAPY_TPS PAPY的实验不完全汇总 TP1 1. 文件处理：统计说的话，删掉所有的e并将其写入新的文件 1234567891011121314f = open(&quot;fable.txt&quot;,'r')fable = f.read()print(type(fable))#print(fable)nombre = fable.count(&quot;- &quot;)/2print(nombre)fabl = fable.replace('e','',fable.count(&quot;e&quot;))f1 = open(&quot;fabl.txt&quot;,'w')f1.write(fabl)f1.close()f.close() 2. 爬虫[parseur] 1234567import urllib.request as equrl='https://fr.wikipedia.org/wiki/Python_(langage)'#抓取的网址file=eq.urlopen(url).read()#读取信息path=open('site.html','wb')#已写入二进制的方式创建文件path.write(file)#写入爬下的信息print(file)path.close()#关闭文件 3. Bonus 反向猜数 123456789101112131415161718import randomdef fun(): goal = int(input(&quot;please input num:&quot;)) num = random.randint(0,100) bmin = 0 bmax = 100 while goal != num : print(num) if bmin&gt;bmax: break sym = input(&quot;please input sym:&quot;) if sym == '-' : bmax = num-1 elif sym == '+': bmin = num+1 else: pass num = random.randint(bmin,bmax) print(num) if goal == num : print(&quot;won&quot;) else : print(&quot;non&quot;) TP2 1. Listes et dictionnaires Exercice1 : Ecrire un script qui transforme une liste de dictionnaires en dictionnaire de liste. Propser 2 méthodes a) bloucle for et b) compréhension. 1234567res = {}for item in data: keys = item.keys() for name in keys: if name not in res : res[name]=[]#初始化字典 res[name].append(item[name])#往字典添加元素print(res) 但这个只能处理data[0]里面有所有key的情况 1print({key: [i[key] for i in data] for key in data[0]}) Exercice2 : Ecrire un script qui renvoie les 10 mots les plus fréquents dans un texte avec la fréquence associée. L’appliquer à Zen of python (et en profiter pour lire le texte). 12345678910111213f = open('zen.txt',r)text = f.read()mots = text.split()res = {}sums = len(mots)for mot in mots: if mot not in res.keys(): res[mot] = mots.count(mot)/sumstrie = sorted(res.items(), key=lambda item: item[1],reverse=True)print(&quot;Percentage share of each word : &quot; )for item in trie[:10]: print(f&quot;{item[0]:20s}: {100*item[1]:.2f}%&quot;)f.close() Exercice 3: Ecrire une fonction qui calcule la moyenne d’un nombre inconnu d’arguments. 1234567891011121314151617def avgfun(*n:float)-&gt;float: &quot;&quot;&quot;Fonction qui calcule la moyenne d'un nombre inconnu d'arguments&quot;&quot;&quot; sums = 0 for t in n: sums = sums + t avg = sums / len(n) return avg # Driver Coderesult1 = avgfun(1, 2, 3)result2 = avgfun(2, 6, 4, 8) # Printing average of the listprint(round(result1, 2))print(round(result2, 2)) Exercice 4: Ecrire une fonction crier qui transforme un str en majuscules, une seconde chuchoter qui transforme le str en minuscules et enfin une troisième salutations (d’ordre supérieur) qui prend en argument une fonction et l’applique à un texte pré-défini. 1234567891011121314def crier(text): return text.upper() def chuchoter(text): return text.lower() def salutations(func): # storing the function in a variable greeting = func(&quot;Bonjour, je suis créé par une fonction passé en argument.&quot;) print(greeting) returnsalutations(crier) salutations(chuchoter) Exercice 5 : Ecrire une fonction décorateur log qui prend en argument une fonction et en extrait le nom, les arguments (positionnels et par mot-clé) ainsi que le résultat pour les afficher. 12345678def log(original_function,): def new_function(*args, **kwargs): result = original_function(*args, **kwargs) print(f&quot;&quot;&quot;Fonction {original_function.__name__} appelée avec les arguments positionnels \\{args} et les arguments par mot clé {kwargs}. Résultat:{result}\\n&quot;&quot;&quot;) return result return new_function 2. Programmation orientée objet 2.1 vector 类装饰@property+@varname.setter 12345678910111213141516171819@property#把类方法当成属性调用,get方法 def x(self): return self._x @x.setter#set方法 def x(self,num): if isinstance(num,numbers.Real): self._x = num else: print(f&quot;val={num} must be a real&quot;) @property#把类方法当成属性调用,get方法 def y(self): return self._y @y.setter#set方法 def y(self,num): if isinstance(num,numbers.Real): self._y = num else: print(f&quot;val={num} must be a real&quot;) 迭代器: __iter__ 和 from_iterable 在python3中，如果定义了一个类，类中有 iter(self)，next(self)两个函数，则该类具有了迭代器的属性，具体性质体现在：如果该类的对象出现在一个for循环中，那么for循环会自动通过__iter__标志识别这是一个可迭代的类，继而自动调用__next__()函数 123456def __iter__(self): &quot;&quot;&quot;Iterateur sur les élements du vecteur, utilise yield&quot;&quot;&quot; #向量元素的迭代器 #return iter(array('d',[self.x,self.y])) yield self.x yield self.y 迭代器的作用在这里体现在： v1 = Vecteur(3, 4) x, y = v1这行 print(x,y) 如果用的是直接return self.x, self.y，它报错：iter() returned non-iterator of type ‘tuple’, 所以这里用yield 1234567@classmethod#类方法 def from_iterable(cls, it): x = it[0] y = it[1] return Vecteur(x,y)#可以实现v2=Vecteur.from_iterable([1,5]) 打印__repr__ 和 __str__ repr: 定义解释器返回的对象表示形式 str: 对象的字符串表现形式, 如果未定义，则返回__repr__ 123456def __repr__(self): &quot;&quot;&quot;Représentation textuelle de l'objet&quot;&quot;&quot; return 'Vecteur('+str(self.x)+','+str(self.y)+')'def __str__(self): return '('+str(self.x)+','+str(self.y)+')' v1_clone = eval(repr(v1))#eval:python内置函数，可以接受一个字符串str作为参数，并把这个参数作为脚本代码来运行 操作符重载： 123456789101112def __eq__(self, other): &quot;&quot;&quot;Surcharge de l'opérateur ==&quot;&quot;&quot; #运算 return type(self)==type(other) and (self.x==other.x) and (self.y==other.y)#右加法，处理vector+其他 --&gt;左加法：__radd__：处理其他加vecter def __add__ (self,other): if isinstance(other,Vecteur): return Vecteur(self._x+other._x,self._y+other._y) if isinstance(other,list) : return (self._x+other[0],self._y+other[1]) raise TypeError(f&quot;unsupported operand type(s) for +: {type(self)} and {type(other)}&quot;) 12345678910111213141516171819#取反def __neg__(self): return Vecteur(-self._x,-self._y) #左乘法，处理vector* def __mul__(self,other): if isinstance(other,numbers.Real): return Vecteur(self._x*other,self._y*other) if isinstance(other,Vecteur): return self._x*other._x+self._y*other._y raise TypeError(f&quot;unsupported operand type(s) for *: {type(self)} and {type(other)}&quot;) #右乘法，处理*vector def __rmul__(self,other): return self*other #减法 def __sub__(self,other): if isinstance(other,Vecteur): return Vecteur(self._x-other._x,self._y-other._y) raise TypeError(f&quot;unsupported operand type(s) for +: {type(self)} and {type(other)}&quot;) 2.2 printer 继承后的方法重写 super().函数名 1234567class ColorPrinter(Printer): def __init__(self, devices=&quot;Printer 0&quot;,avail_paper=Printer.formats_dict.keys(),color=&quot;Black&quot;): super().__init__(avail_paper) self.color = color self.devices = devices def send(cls,strs,tallie=&quot;A4&quot;,color = &quot;Black&quot;): super().send(strs,color = cls.color) 2.3 afficher l’arborescence 普通函数方法 123456789101112131415161718192021222324252627282930import osfrom pathlib import Pathspace = ' 'branch = '│ 'tee = '├── 'last = '└── 'res = &quot;&quot;length_limit = 1000level = 0def print_dirtree(pathname,step=0,flag=0): global res,level if level &gt; length_limit: return p = Path(pathname) is_last = last if flag else tee#判断是否是last res += branch*int(bool(step)) + space * (step-1)+ is_last + p.name+'\\n' level += 1 if not p.is_file(): for item in os.listdir(pathname):#返回一个列表，包含p下所有文件夹和文件 noveau_pathname = pathname+&quot;/&quot;+item print_dirtree(noveau_pathname,step+1,item == os.listdir(pathname)[-1])path = &quot;TP2&quot;print_dirtree(path)print(res) 封装成类 123456789101112131415161718192021222324252627282930313233import osfrom pathlib import Pathclass generate: space = ' ' branch = '│ ' tee = '├── ' last = '└── ' res = '' level = 0 length_limit = 1000 def __init__(self,pathname): self.pathname = pathname def print_dirtree(self,pathname,step=0,flag=0): if self.level &gt; self.length_limit: return p = Path(pathname) is_last = self.last if flag else self.tee#判断是否是last self.res += self.branch*int(bool(step)) + self.space * (step-1)+ is_last + p.name+'\\n' self.level += 1 if not p.is_file(): for item in os.listdir(pathname):#返回一个列表，包含p下所有文件夹和文件 noveau_pathname = pathname+&quot;/&quot;+item self.print_dirtree(noveau_pathname,step+1,item == os.listdir(pathname)[-1])test = generate(&quot;TP2&quot;)test.print_dirtree(&quot;TP2&quot;)print(test.res) TP3.1 1.np库处理矩阵 linalg.det(A)：模,在有小数时有很多问题 linalg.inv(A):逆 2.模拟计算PI 12345678910111213141516import mathdef monteCarlo(NumTest,N): my_pis = 0 for i in range(NumTest): ptsinterieur = 0 for i in range(N): #随机生成在正方形里面的点 x = np.random.random() y = np.random.random() #在半圆里面的 if (x*x + y*y) &lt;= 1: ptsinterieur += 1 my_pis += ptsinterieur/N * 4 my_pi = my_pis/NumTest return my_pi,abs(math.pi-my_pi)/math.pimonteCarlo(50,int(1e6)) 3.scipy库 获取大小和通道 123456789101112131415#大小print(f.shape)#显示通道R = f[:,:,0]plt.imshow(R)plt.show()G = f[:,:,1]plt.imshow(G)plt.show()B = f[:,:,2]plt.imshow(B)plt.show() 获取灰度图[l’image en noir et blanc] 123gray = R * 0.299 + G * 0.587 + B * 0.114plt.imshow(gray, cmap=&quot;gray&quot;)plt.show() 镜像图[l’image en miroire] 1img_lr = np.fliplr(img) masque 12345678910111213141516x,y = gray.shapec_x = 300c_y = 600r = 100def inCircle(i,j): if (c_x-i)*(c_x-i) + (c_y-j)*(c_y-j) &gt; r * r: return True else: return Falsegray_circle = gray.copy() for i in range(x): for j in range(y): if inCircle(i,j): gray_circle[i][j] = 0plt.imshow(gray_circle,cmap='gray')plt.show() 二值化[binaire] 12345678910x,y = gray.shapegray_binaire = gray.copy()for i in range(x): for j in range(y): if gray_binaire[i][j] &gt; 100: gray_binaire[i][j] = 0 else: gray_binaire[i][j] = 255plt.imshow(gray_binaire,cmap='gray')plt.show() gradient 1234567def norm(x, axis=0): return np.sqrt(np.sum(np.square(x), axis=axis))gray = R *0.299 + G * 0.587 + B * 0.114gary_g = np.gradient(gray)gary_g = norm(gary_g)plt.imshow(gary_g,'gray') TP3.2 用OPENSKY + pandas画飞机轨迹 1. pandas 2.opensky 画飞机 画单个的飞机轨迹 123456789101112131415161718192021222324def drawJour(but): #先把这个avoin摘出来 tableau = df[df['icao24'] == but] liste_lat = tableau['lat'].tolist() liste_lon = tableau['lon'].tolist() print(&quot;liste ok&quot;) #画图 #地图 fig = plt.figure(figsize=(15,15)) # Create a GeoAxes in the tile's projection. stamen_terrain = cimgt.Stamen('terrain-background') ax = fig.add_subplot(1, 1, 1, projection=stamen_terrain.crs) #ax.set_extent([df['lon'].min()-6, df['lon'].max()+6, df['lat'].min()-6, df['lat'].max()+6], crs=ccrs.Geodetic()) # Add the Stamen data at zoom level 8. ax.add_image(cimgt.GoogleTiles(&quot;RGB&quot;), 8) #轨迹 ax.plot(liste_lon,liste_lat,color='red',transform=ccrs.Geodetic()) fig.savefig(&quot;1.jpg&quot;) plt.show() print(&quot;ok&quot;)drawJour('a7e152') 画所有飞机的 12345678910111213141516171819202122232425262728293031323334353637def drawAlltrace(dataset): #画图 #地图 fig2 = plt.figure(figsize=(15,15)) # Create a GeoAxes in the tile's projection. stamen_terrain = cimgt.Stamen('terrain-background') ax2 = fig2.add_subplot(1, 1, 1, projection=stamen_terrain.crs) #ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.Geodetic()) #Add the Stamen data at zoom level 8. ax2.add_image(cimgt.GoogleTiles(&quot;RGB&quot;), 8) print(&quot;map ok&quot;) #轨迹 #groupBy dataset_light = dataset[['icao24','lat','lon']] group = list(dataset_light.groupby(&quot;icao24&quot;)) print(len(group)) i = 0 for key, item in group: liste_lat = [] liste_lon = [] item = item.dropna(axis=0,how='any') liste_lat = list(item['lat']) liste_lon = list(item['lon']) if liste_lat and liste_lon: ax2.plot(liste_lon,liste_lat,color='red',transform=ccrs.Geodetic()) i+=1 print(liste_lat) print(liste_lon) fig2.savefig(&quot;Pic/&quot;+str(i)+&quot;.jpg&quot;) print(&quot;ax fini&quot;) plt.show() print(&quot;ok&quot;) #drawAlltrace(df) TP4 1.COO 2.Mandelbrot 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import numpy as npimport matplotlib.pyplot as pltnp.warnings.filterwarnings(&quot;ignore&quot;)def is_in_Mandelbrot(c, max_iter=50)-&gt;bool: &quot;&quot;&quot;Verifier un point apres max_iter fois iteration est dans la suite Mandelbrot Args: c (complex,optional complex_array): le candidat max_iter (int): nombre d'iteration. Returns: bool: si dans la suite-&gt;True; sinon False &quot;&quot;&quot; z = 0 for _ in range(max_iter): z = z**2 + c return abs(z) &lt;= 2def is_in_Julia(z,c, max_iter=50)-&gt;bool: &quot;&quot;&quot;Verifier un point apres max_iter fois iteration est dans la suite Mandelbrot Args: c (complex,optional complex_array): le candidat max_iter (int): nombre d'iteration. Returns: bool: si dans la suite-&gt;True; sinon False &quot;&quot;&quot; for _ in range(max_iter): z = z**2 + c return abs(z) &lt;= 2def plot_mandelbrot(zmin=-2 - 2j, zmax=2 + 2j, pixel_size=0.001, max_iter=50, figname=&quot;Mandelbrot.png&quot;): &quot;&quot;&quot;afficher et save la figure de suite Mandelbrot Args: zmin (_type_, optional): _description_. Defaults to -2-2j. zmax (_type_, optional): _description_. Defaults to 2+2j. pixel_size (float, optional): _description_. Defaults to 0.001. max_iter (int, optional): _description_. Defaults to 50. figname (str, optional): _description_. Defaults to &quot;Mandelbrot.png&quot;. &quot;&quot;&quot; reals = np.arange(zmin.real, zmax.real, pixel_size) imags = np.arange(zmin.imag, zmax.imag, pixel_size) x, y = np.meshgrid(reals, imags) c = np.array(x + y * 1j, dtype=complex) plt.figure(figsize=(15, 15)) plt.imshow(is_in_Mandelbrot(c, max_iter), cmap=&quot;binary&quot;) plt.gca().set_aspect(&quot;equal&quot;) plt.axis(&quot;off&quot;) plt.tight_layout() plt.show() plt.savefig(figname)def plot_julia(c=-0.8 + 0.156j, zmin=-2-1j, zmax=2+1j, pixel_size=5e-4, max_iter=100, figname=&quot;Julia.png&quot;): &quot;&quot;&quot;afficher et save la figure de suite Mandelbrot Args: c (_type_, optional): _description_. Defaults to -0.8 + 0.156j. zmin (_type_, optional): _description_. Defaults to -2-1j. zmax (_type_, optional): _description_. Defaults to 2+1j. pixel_size (float, optional): _description_. Defaults to 0.0005. max_iter (int, optional): _description_. Defaults to 100. figname (str, optional): _description_. Defaults to &quot;Julia.png&quot;. &quot;&quot;&quot; reals = np.arange(zmin.real, zmax.real, pixel_size) imags = np.arange(zmin.imag, zmax.imag, pixel_size) x, y = np.meshgrid(reals, imags) z = np.array(x + y * 1j, dtype=complex) plt.figure(figsize=(15, 15)) plt.imshow(is_in_Julia(z,c, max_iter), cmap=&quot;binary&quot;,alpha=0.5) plt.gca().set_aspect(&quot;equal&quot;) plt.axis(&quot;off&quot;) plt.tight_layout() plt.show() plt.savefig(figname) __main__.py 12345678910111213141516171819202122232425262728293031323334353637383940414243&quot;&quot;&quot;Main call to mandelbrot. Mostly a parser.&quot;&quot;&quot;import argparsefrom .affichage import plot_mandelbrot,plot_juliadef MandelbrotPlot(): &quot;&quot;&quot;Draw la suite Mandelbrot with des arguments suivants&quot;&quot;&quot; parser = argparse.ArgumentParser(description='Draw mandelbrot') parser.add_argument('--zmin',metavar='zmin', type=complex,default=-2-2j, help='input zmin,default:-2-2j') parser.add_argument('--zmax',metavar='zmax', type=complex,default=2+2j, help='input zmax,default=2+2j') parser.add_argument('--pixel_size',metavar='pixel_size', type=float,default=0.001, help='input pixel_size,default:0.01') parser.add_argument('--max_iter',metavar='max-iter', type=int,default=50, help='input max_iter,default:50') parser.add_argument('-o',metavar='pathname', type=str,default='mandelbrot.png', help='input pathname') args = parser.parse_args() plot_mandelbrot(zmin=args.zmin,zmax = args.zmax, pixel_size = args.pixel_size,max_iter=args.max_iter, figname=args.o)def JuliaPlot(): &quot;&quot;&quot;Draw la suite Mandelbrot with des arguments suivants&quot;&quot;&quot; parser = argparse.ArgumentParser(description='Draw Julia') parser.add_argument('-c',metavar='c de Julia', type=complex,default=-0.8+0.156j, help='input c de Julia,default:-0.8+0.156j') parser.add_argument('--zmin',metavar='zmin', type=complex,default=-2-1j, help='input zmin,default:-2-1j') parser.add_argument('--zmax',metavar='zmax', type=complex,default=2+1j, help='input zmax,default=2+1j') parser.add_argument('--pixel_size',metavar='pixel_size', type=float,default=5e-4, help='input pixel_size,default:5e-4') parser.add_argument('--max_iter',metavar='max-iter', type=int,default=100, help='input max_iter,default:100') parser.add_argument('-o',metavar='pathname', type=str,default='julia.png', help='input pathname') args = parser.parse_args() plot_julia(c=args.c,zmin=args.zmin,zmax = args.zmax, pixel_size = args.pixel_size,max_iter=args.max_iter, figname=args.o)","link":"/2022/10/29/PAPY_TPS/"},{"title":"PFONC_CM2&amp;3","text":"PFONC_CM2&amp;3 CHAP2:Types, 介绍haskell中的类型变量. Types de base entiers: Integer/Int Réels virgule flottante: Double ou Float Booléens: Bool (valeurs True et False) Caractères Char Chaîne de caractères: String (alias[别名] pour [Char]–Char类型的列表) Types algébriques[代数] 由基本类型构建 Types sommes : énumerations[枚举] 12data Bool = True | Falsedata Animal = Canard | Vache | Chat Types produits : tuples 12data AnimalMesure = Paire Animal Integer--Paire:值构造子(Value Constructor)和类型名(AnimalMesure)不同data Entiers3 = Entiers3 Integer Integer Integer Paire, True, False, Canard, etc. sont des constructeurs de données 都是值构造子，值构造可以与类型名同名，后面可以跟几个类型表示它包含值的类型 Ils peuvent avoir n’importe quel nom, y compris le même que le nom du type défini.Comme pour Entiers3 ; [可以同名] Les noms de types et de constructeurs commencent par une majuscule[大写字母] en Haskell.然后普通函数必须小写字母开头 Types algébriques: sommes de produits 12345678data PossibleReel = Rien | Valeur Doubleinversion :: Double -&gt;PossibleReelinversion 0 = Rieninversion x = Valeur (1/x)--Rien et Valeur sont implicitement[隐式地] définies avec ce type:--Rien:: PossibleReel--Valeur::Double -&gt;PossibleReel 这里注意一个问题，inversion的调用实现这里，直接调用 inversion n 报错 No instance for (Show PossibleReel) arising from a use of ‘print’，然后得在声明数据类型时加上deriving Show，具体原因不是很清楚哈哈哈哈 Plus de pattern-matching On peut utiliser les constructeurs pour faire du pattern-matching : 1234567opposePR :: PossibleReel -&gt;PossibleReelopposePR Rien = RienopposePR (Valeur x) = Valeur (-x)-- ou bien avec let ... inopposePR z = if z == Rien then Rien else let (Valeur x)=z in Valeur (-x) EXERCICE 1.Écrire une fonction et qui réalise le et logique entre deux Bool 12et True True = Trueet _ _ = False 2.Proposer la définition d’un type Point représentant un point du plan 1data Point = Point Double Double deriving Show 3.Écrire une fonction distance qui donne la distance entre deux Point 1234findDistance :: Point,Point -&gt; DoublefindDistance (Point x1 y1) (Point x2 y2)= sqrt ((x1-x2)^2+(x1-x2)^2)--调用：findDistance (Point 2 3) (Point 4 5) 4.Proposer la définition d’un type Figure qui est： ​ • soit un unique Point ; ​ • soit un cercle défini par son rayon &gt; 0 et son centre ; ​ • soit un carré défini par deux sommets opposés. 12data Vecteur = Vecteur Double Doubledata Figure = FigP Point |Cercle Point Double |Carre Point Vecteur 5.Écrire une fonction perimetre qui donne le périmètre[周长] d’une Figure. 1234perimetre (FigP _) = 0perimetre (Cercle _ r) = 2 * pi * rnorme (Vecteur x y)= findDistance (Point 0 0) (Point x y)perimetre (Carre _ (Vecteur x y)) = 4 * norme v --咋能这么算呢 Types paramétrés:参数化类型 Le type PossibleReel existe, sous la forme d’un type paramétré, en Haskell : 123--对于所有的类型来说都有：data Maybe a = Nothing | Just a--Maybe est un constructeur de type 一些(仍然不太懂的)理解： 类型构造子可以取类型作参数，产生新的类型 所以给 Car 类型加类型参数貌似并没有什么必要。通常我们都是 都是在一个类型中包含的类型并不影响它的行为时才引入类型参数 12345data Either a b = Left a | Right bsafeTwice ::Int-&gt;Either Int IntsafeTwice n = if n &gt; (maxBound::Int) `div` 2 then Left n else Right (2*n)--报错了QAQ,加deriving Show也不行 Types en Haskell type et newtype -type définit un type synonyme[同义] d’un autre：type String = [Char] -newtype est similaire à data mais ne fonctionne que pour un seul constructeur de données avec au plus une variable et fournit dans ce cas une petite optimisation (Synonymes mais crée un type distinct). 但只适用于最多只有一个变量的单一数据构造函数 Tuples Un tuple est un type produit, Haskell propose une syntaxe[语法] spécifique (et classique) pour les tuples: 12345678910-- fst et snd pour les couplesmaxi ::(Integer,Integer)-&gt;Integermaxi x = let a = fst x, b = snd x in if a &gt; b then a else b-- pattern matchingmaxi '::(Integer,Integer)-&gt;Integermaxi ' (a,b) = if a &gt; b then a else b-- pas que pour les couplesror::(Char,Char,Char)-&gt;(Char,Char,Char)ror (a,b,c) = (c,a,b) Enregistrements Un enregistrement est un type produit avec accesseurs intégrés [内置的访问器？] (en lecture bien sûr) 构造方法 123456789data Canard = Coin { nom::String , enverg::Double }info::Canard -&gt;Stringinfo c = &quot;Oh le beau canard &quot; ++ (nom c) ++&quot; d'envergure &quot; ++ show (enverg c) ++ &quot;m &quot;main = let c1 = Coin &quot;Coincoin&quot; 0.8 c2 = Coin { nom=&quot;Grocoin&quot;, enverg =0.8 } c3 = c2 { enverg = 1 } in print (info c1 ++ info c3) Listes -Le type liste est natif à Haskell, la liste vide est [] -Le constructeur « élément plus liste donne liste » est noté : --追加的冒号 -Pour tout type a le type « liste de a » est noté [a] ; -Accès à l’élément i (commençant à 0) : xs!!i.–获取索引 Listes en compréhension Les listes en compréhension (list comprehension) sont une facilité syntaxique pour créer des listes EXEMPLE 12345-- les nombres pairs inférieurs à n (on peut faire mieux...)evens n = [x+1 | x&lt; -[1..(n-2)], odd x]-- les produits de nombres impairs à trois chiffresproducts3 = [m*n | m &lt;- [101 ,103..999] ,n &lt;- [101 ,103..999]] EXERCICE Construire la liste des triplets pythagoriciens (a, b, c), c.-à-d. tels que a^2 + b^2 = c^2 , dont la somme des composantes vaut 1000 et tels que a &lt; b &lt; c. 1triplets = [(a,b,c) | a &lt;- [1..333],b&lt;-[a..666],c&lt;-[b..1000],a*a + b*b = c*c, a+b+c == 1000] Écrire une fonction reverse qui inverse une liste 123reverse' :: String -&gt; Stringreverse' [] = []reverse' (x:xs) = reverse' xs ++ [x] --列表的拼接是++，[x]表示转为列表 Écrire une fonction delete qui efface la première occurrence d’un élément dans une liste 12delete' x []=[]delete' x (y:xs) = if x == y then xs else y: delete' x xs--记住这里的y： Écrire une fonction maximum qui trouve le maximum dans une liste d’entiers 123456maxi :: Liste -&gt; Integermaxi [] = error &quot;list vide&quot;maxi [x] = x --这行很重要！maxi (x:xs) = if x &gt; maxi xs then x else maxi xs--或者写成maxi (x:xs)= max x (maxi xs) Écrire une fonction trimax qui réalise le tri par extraction du maximum dans une liste d’entiers 1234567trimax :: Liste -&gt; Listetrimax [] = []trimax [x] = [x]trimax xs = maxi xs : trimax (delete' (maxi xs) xs)--或者写成trimax xs = let y = maxi xs in y : trimax(suppr y xs) Types algébriques récursifs 12-- arithmétique de Peanodata Nat = Zero | Succ Nat EXERCICE Écrire une fonction addition qui réalise l’addition de deux Nat. 12345678data Nat = Zero | Succ Nat deriving Showeval :: Nat -&gt; Integereval Zero = 0eval (Succ n) = 1 + eval naddition Zero n = naddditon (Succ n1) n2 = addition n1 (Succ n2) Arbres EXERCICE Écrire un type Liste représentant une liste d’entiers 1data Liste = Vide | Cons Integer Liste deriving Show Écrire une fonction sum qui fait la somme des éléments d’une liste d’entiers 123somme :: Liste -&gt; Integersomme Vide = 0somme (Cons x xs) = x + somme xs Écrire un type ArbreBinaire représentant un arbre binaire d’entiers 1data Arbre = Vide | Cons Integer Arbre Arbre deriving Show Écrire une fonction hauteur qui calcule la hauteur d’un arbre binaire d’entiers. 123hauteur :: Arbre -&gt; Integerhauteur Vide = 0hauteur (Cons _ gauche droit) = 1 + max (hauteur gauche) (hauteur droit) Types génériques On peut définir les fonctions de façon générique : 123-- pour tout type afsquare ::(a-&gt;a)-&gt;(a-&gt;a)fsquare f = f.f Et des types algébriques de façon générique (paramétrée) : pour tout type a, le type [a] est une liste de a et Maybe a est la possibilité d’un a ; 代数类型以通用（参数化）的方式：对于任何类型的a，[a]是一个a的列表，Maybe a是一个a的可能性。 Et des fonctions génériques sur des types algébriques génériques : 12345678-- pour tout type ahead::[a]-&gt;ahead [] = error (&quot;head: Empty list&quot;) -- fct. partielle!head (x:xs) = x-- dans Data.MaybelistToMaybe::[a]-&gt;Maybe alistToMaybe [] = NothinglistToMaybe (x:xs) = Just x [没太看懂这啥呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜] 问题 参数化类型 Types génériques 正方形面积","link":"/2022/09/16/PFONC_CM2&3/"},{"title":"PFONC_CM4&amp;5","text":"PFONC_CM4&amp;5 CHAP4 : Fonctions d’ordre supérieur -Les fonctions sont des objets de première classe : elles se manipulent comme les types de base：函数像基本类型那样被传递[参数和返回值] -Notion de fonction d’ordre supérieur : ensembles de fonctions dans le domaine ou le codomaine：域或共域中的函数[?] Curryfication Haskell 的所有函数都只有一个参数, 所有多个参数的函数都是 Curried functions，下面以max函数为例进行说明 1max x y = if x &gt; y then x else y 他的类型说明是：max::Integer -&gt;Integer -&gt;Integer，但按照我们一般的理解，它应该长这样：max::(Integer,Integer)-&gt;Integer -Pour tout x, (max x) est une fonction d’un entier qui donne un entier Haskell 的所有函数都只有一个参数 -Donc max est aussi une fonction d’un entier qui donne « une fonction d’un entier qui donne un entier » max函数的参数是(一个返回值为int的函数)–&gt;max :: Integer-&gt;(Integer -&gt;Integer) --哎这里为什么不是 max :: (Integer-&gt;Integer) -&gt;Integer Et comme -&gt; est associatif à droite :max :: Integer-&gt;Integer -&gt;Integer Toute fonction de plusieurs variables peut être transformée en une fonction d’une seule variable, pour tous types a,b,c, on peut définir deux fonctions, les fonctions sont « curryfiées » (curried) par défaut en Haskell 1234curry::((a,b)-&gt;c)-&gt;(a-&gt;(b-&gt;c))uncurry::(a-&gt;(b-&gt;c))-&gt;((a,b)-&gt;c)-- et on pourrait définir des versions pour tous-- les tuples de types possibles EXERCICE Quel est le type de map ? 12map _ [] = []map f (x:xs) = (f x):(map f xs) map :: (a-&gt;b)-&gt;list-&gt;list map :: (a-&gt;b) -&gt; [a] -&gt;[b] Écrire une fonction flip, avec son type, qui à partir d’une fonction d’arité 2, donne la même fonction avec les variables inversées. Par exemple : main = print (flip (-) 1 3) --2(pas -2) 123filp :: (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)--为什么不是((a-&gt;b)-&gt;c-&gt;d) -&gt;((a-&gt;b)-&gt;d-&gt;c) --为什么f不是(a-&gt;b)，为什么不是交换b和cfilp f x y = f y xmain = print (flip (-) 1 3) ​ 以及这个神奇的错误 Application de fonction($) L’application de fonction est une fonction. Elle est notée ($) en Haskell : 12($)::(a-&gt;b)-&gt;a-&gt;b($) f x = f x 函数调用符，空格的函数调用符是左结合，而 $ 则是右结合，用于减少代码中括号的数目 Elle est de faible priorité et associative à droite : 123main = print (square (inc 2))-- ou un peu plus concismain = print $ square $ inc 2 Elle sert pour définir certaines fonctions d’ordre supérieur : 将数据作为函数使用：映射一个函数调用符到一组函数组成的 List 12-- valeurs en 0 des fonctions f, g et hmap ($ 0) [f,g,h] Fonctions anonymes (Fonctions λ) On peut définir des fonctions anonymes, appelées fonctions λ : P. ex. λx.(x + 1) ou λx.(λy.(x + y)) En Haskell : 123456inc x = x+1map inc [1,2,3]-- ou simplementmap (\\x -&gt; x+1) [1,2,3]-- plusieurs variables:add = (\\x y -&gt; x+y) 编写 lambda: \\ ，+用空格分隔的参数，±&gt; 后面的函数体。通常用括号将其括起，要不然它就会占据整个右边部分。 Fermetures (Closures): 闭包 On quantifie implicitement[隐式地量化了] x et y quand on écrit : 1f x y = x + y -- ∀x, ∀y La variable y est dite libre dans : 1f' x = x + y -- ∀x--不能这样子 On ne peut pas évaluer f’ x sans une valeur pour y. D’ailleurs, toute seule, ce n’est pas une déclaration correcte Une fermeture est une fonction avec variables libres plus une valeur pour ces variables libres : 12-- Pour tout y, g y est une fermeture，x是自由变量g y = (\\x -&gt; x + y) 那么怎么传参和调用呢？ Récursion sur les listes map -Plutôt que de faire de la récursivité explicite, on utilise plutôt, autant que possible, des fonctions de plus haut niveau [与其说是显式递归，不如说是尽可能地使用了更高层次的函数] -On a déjà vu map qui permet d’appliquer une fonction à chaque élément d’une liste : 123map::(a-&gt;b)-&gt;[a]-&gt;[b]map _ [] = []map f (x:xs) = (f x):(map f xs) EXERCICE: En utilisant map, écrire une fonction an qui donne la liste de toutes les anagrammes d’un mot[找所有字母组合]. On pourra utiliser aussi : concat::[[a]]-&gt;[a] ,delete::Eq a =&gt;a-&gt;[a]-&gt;[a] 12345import Data.List (delete,nub)-- anagrammesan :: String -&gt; [String]an &quot;&quot; = [&quot;&quot;]an xs = concat $ map (\\x -&gt; map (x:) $ an $ delete x xs ) $ nub xs--nub拿来去重复的 filter filter permet de ne garder que les éléments d’une liste qui satisfont un certain prédicat : 1234filter::(a-&gt;Bool)-&gt;[a]-&gt;[a]filter _ [] = []filter f (x:xs) = if f x then x:(filter f xs) else filter f xs EXERCICE Écrire une fonction premiers qui donne la liste des entiers premiers inférieurs à n. On pourra ne pas chercher à optimiser et : écrire une fonction diviseurs donnant une liste de diviseurs de n utiliser la syntaxe [x…y] pour la liste des entiers compris entre x et y ; et rem::Integer-&gt;Integer-&gt;Integer donnant le reste la division entière ; et null::[a]-&gt;Bool indiquant si une liste est vide ; ou length::[a]-&gt;Int donnant la taille d’une liste. 12345premiers n listes = filter (&lt;n) listes--找除数diviseurs n = filter ((==0).(rem n)) [1..n]--rem与mod差不多，但.的用法原则是什么？--找质数premiers' n = filter ((==2).length.diviseurs) [2..n-1] folds foldl et foldr permettent de réduire une liste à une valeur en appliquant une fonction d’arité 2 récursivement à tous les éléments : foldl réduit de la gauche vers la droite : 它从 List 的左端开始折叠，用初始值和 List 的头部调用这二元函数，得一新的累加值，并用新的累加值与 List 的下一个元素调用二元函数 123456789foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldl f x [] = xfoldl f x (y:ys) = foldl f (f x y) ysfoldl f z [x1, x2, ..., xn] == f (...(f (f z x1) x2)...) xn-- ou en notation infixefoldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2)...) `f` xn foldr réduit de la droite vers la gauche : 右折叠 foldr 的行为与左折叠相似，只是累加值是从 List 的右边开始 123456789foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldr f x [] = xfoldr f x (y:ys) = f y (foldr f x ys)foldr f z [x1, x2, ..., xn] == f x1 (f x2 (...(f xn z)...))-- ou en notation infixefoldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` (...(xn `f` z)...)) 右折叠可以处理无限长度的数据结构，而左折叠不可以。将 无限 List 从中断开执行左折叠是可以的，不过若是向右，就永远到不了头 foldl1,foldr1::(a-&gt;a-&gt;a)-&gt;[a]-&gt;a sont des versions sans élément de départ pour les listes non vides [没有起始元素的非空列表]; 无需明确提供初始值。他们假定 List 的首个 (或末尾) 元素作为起始值，并从旁边的元素开始折叠 以sum函数说明 1234suml::[Integer]-&gt;Integersuml xs = foldl (+) 0 xssumr::[Integer]-&gt;Integersumr xs = foldr (+) 0 xs EXERCICE: Écrire les fonctions suivantes (et tester à la main sur quelques exemples) : sum::[Integer]-&gt;Integer qui donne la somme des éléments d’une liste ; 上面 maximum::[Integer]-&gt;Integer qui donne le maximum des éléments d’une liste ; 123maxi'::[Integer]-&gt;Integermaxi' [] = error &quot;list: vide&quot;maxi' xs = foldl1 max xs and::[Bool]-&gt;Bool qui indique si tous les éléments sont vrais ; 12345and'::[Bool]-&gt;Booland' = foldr (&amp;&amp;) Trueor' :: [Bool] -&gt; Boolor' = foldr (||) False any::(a-&gt;Bool)-&gt;[a]-&gt;Bool qui indique si au moins un élément de la liste satisfait un prédicat donné ; 12any'::(a-&gt;Bool)-&gt;[a]-&gt;Boolany' f = or'.(map f) concat::[[a]]-&gt;[a] qui concatène une liste de listes. 12concat' :: [[a]] -&gt; [a]concat' = foldl (++) [] 问题集 Curryfication的max和例题的fild 闭包函数的调用和有什么用 P41的map全排列 上面的3,4,5怎么都不加列表参数，看不懂啊啊啊啊啊","link":"/2022/09/16/PFONC_CM4&5/"},{"title":"PFONC_CM6","text":"PFONC_CM6 Méthodes d’évaluation et Entrées, Sorties en Haskell Méthodes d’évaluation Évaluation stricte (ou eager) Les arguments[参数] d’une fonction sont toujours complètement évalués avant que ladite fonction ne soit évaluée. 一个函数的参数总是在函数被求值之前被完全求值。 C’est le cas de la plupart des langages fonctionnels ou non. Java,C,Python Facilite le raisonnement sur l’ordre d’évaluation, et l’évaluation de performance. Évaluation non-stricte (ou lazy) Les arguments d’une fonction ne sont évalués que lorsqu’on en a besoin. Permet de raisonner sur des constructions infinies : 1234fibs ::[Integer]fibs = 0:1: zipWith (+) fibs (tail fibs)-- le 1234567e nombre de Fibonaccimain = print $ fibs !! 1234567 Donne un gain de performance dans certains cas. EXERCICE: Donner une construction de la liste (infinie) des nombres premiers, en ne testant que les diviseurs potentiels premiers inférieurs ou égaux à √ n pour tout n candidat. On pourra : repartir des fonctions premiers et diviseurs ; utiliser takeWhile::(a-&gt;Bool)-&gt;[a]-&gt;[a] ; utiliser la syntaxe [2…] pour la liste infinie des entiers supérieurs ou égaux à 2 ; 1234diviseurs'' n = filter ((==0).(rem n)) $ takeWhile ((&lt;=n).(^2))premiers''premiers'' = 2:filter (null.diviseurs'') [3..]main = take 10 premiers'' Évaluation non-stricte et folds foldr peut fonctionner sur des listes infinies. 1234567any::(a-&gt;Bool)-&gt;[a]-&gt;Boolany f = (foldr (||) False).(map f)main = do -- Ceci donne vrai print $ any even [1..] -- Mais ceci boucle indéfiniment print $ any (\\x-&gt;False) [1..] Mais foldr n’est pas récursif terminal et peut donc remplir la mémoire avec les opérations en attente sur de grosses listes foldl ne peut pas fonctionner sur des listes infinies mais est récursif terminal. Entrées, Sorties en Haskell En Haskell, les E/S sont explicites[明确的] dans le type, via le type paramétré IO : 123456789101112-- Écrire à l'écran-- () est le type dit unitaire qui représente &quot;rien&quot;putStr::String -&gt;IO ()putStrLn::String -&gt;IO () -- saute une ligne à la fin-- Affichage &quot;intelligent&quot; pour les instance de Showprint::(Show a) =&gt; a -&gt; IO ()print = putStrLn.show-- Lire au claviergetLine::IO String -- une lignegetChar::IO Char -- un caractère-- Dual de Showread::(Read a)=&gt;String -&gt;a IO est une monade[单元，单体] (cf. généricité avancée) L’utilisation de IO est contaminante[污染物] : il n’existe pas de fonction de type IO a -&gt; a &gt;&gt;= On peut par contre appliquer une fonction de type a -&gt; IO b à une valeur de type IO a avec l’opérateur bind[绑定] : (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b 1234-- échomain::IO () -- main fait toujours des E/S et produit le-- type « unitaire » (c.-à-d. rien)main = getLine &gt;&gt;= putStrLn Exercice: Modifier le code précédent pour : afficher l’écho suivi de la même ligne à l’envers : entrer coin affiche coin nioc. 1234echo1 :: IO ()echo1 = do a &lt;- getLine --绑定 putStrLn $ reverse a lire deux lignes et les afficher dans l’ordre inverse : entrer coin puis meuh affiche meuh coin. 12345echo2 :: IO Stringecho2 = do a &lt;- getLine --绑定 b &lt;- getLine putStrLn b ++ a 老师写的 12345echo = getLine &gt;&gt;= putStrLnecho1 = getLine &gt;&gt;= (\\ x -&gt; putStrLn (x ++&quot; &quot;++reverse x))--这里的这个匿名函数理解不了呜呜呜呜echo2 = getLine &gt;&gt;= (\\x -&gt; getLine &gt;&gt;= (\\y -&gt; putStrLn (y++&quot; &quot;++ x)))echo3 = getLine &gt;&gt;= (\\x -&gt; getLine &gt;&gt;= (\\y -&gt; putStrLn y &gt;&gt; putStrLn x)) do • L’enchaînement d’opérations par &gt;&gt;= produit du code peu lisible[可读性降低] ; • Haskell propose la notation do pour simplifier,这里以改写echo2为例 12345echo2 ' :: IO ()echo2 ' = do x &lt;- getLine y &lt;- getLine putStrLn (y ++ &quot; &quot; ++ x) La dernière instruction doit avoir le type promis (ici IO ()), qui est nécessairement de la forme IO a --do的最后一条语句一定是le type promis[QUOI?] La fonction return :: a -&gt; IO a permet de promouvoir une valeur de type a dans la monade IO, 就是说do配retrun就可以了的意思？ 12345putStrLn' :: IO String -&gt; IO ()putStrLn' s = s &gt;&gt;= putStrLnmain = do putStrLn' getLine putStrLn' $ return &quot;coin&quot; Exercice: Écrire une fonction ioLength :: IO Int qui donne la longueur d’une chaîne de caractères lue au clavier. 1234567ioLength :: IO IntioLength = do a &lt;- getLine return $ sum [1|_ &lt;- a]--老师写的：ioLength :: IO IntioLength = getLine &gt;&gt;= return.length Le chiffre de César permet de chiffrer un message sur l’alphabet {a, . . . , z} en décalant chaque lettre de 13 rangs vers z (avec une rotation si besoin) : par exemple a donne n et s donne f . Écrire une fonction cesar qui pour un entier représentant le décalage (classiquement 13 mais on généralise) et une chaîne de caractère produit la chaîne de caractères chiffrée comme ci-dessus. Par exemple, cesar 13 “coin” vaut “pbva” et cesar 13 “pbva” vaut “coin”. La fonction ord :: Char -&gt; Int donne le rang d’une lettre (attention le rang de ‘a’ n’est pas 0) et chr :: Int -&gt; Char donnant la lettre correspondant à un rang. Ces fonctions sont disponibles dans Data.Char. 123cesar_ :: Int -&gt; String -&gt; Stringcesar_ n xs= let a = ord 'a' in map (chr.(+a).(`mod` 26).(+n).(subtract a).ord) xs Écrire la fonction main permettant l’acquisition de l’entier et de la chaîne de caractères, appelant la fonction cesar et affichant le résultat. 12345execCesar :: IO()execCesar = do s &lt;- getLine n &lt;- getLine putStrLn $ cesar_ (read s) n Modifier la fonction main pour forcer l’utilisateur à entrer un entier compris entre 1 et 25. Utiliser let x = … (sans in) pour définir une nouvelle valeur x dans un bloc do 123456789main = do n &lt;- getLine let x = read n :: Int--[!!!] if x &gt;= 1 &amp;&amp; x &lt;=25--and then do n &lt;- getLine putStrLn $ cesar x n else putStrLn &quot;try again&quot; &gt;&gt; loopCesar Évaluation non-stricte des E/S 1234ess = [print &quot;Coin&quot;, print &quot;Meuh&quot;, print &quot;Miaou&quot;]main = doess!!2 -- Affiche Miaousequence_ ess -- Exécute tous les affichages de la liste sequence 接受一串 I/O action，并返回一个会依序执行他们的 I/O action.例： 123456789main = do a &lt;- getLine b &lt;- getLine c &lt;- getLine print [a,b,c]--等价于main = do rs &lt;- sequence [getLine, getLine, getLine] print rs On peut aussi utiliser sequence pour Maybe: 12xs = sequence [Just 1, Just 3, Just 5] -- Just [1,3,5]ys = sequence [Just 1, Nothing , Just 5] -- Nothing","link":"/2022/11/12/PFONC_CM6/"},{"title":"PRO20","text":"序 趁着可能对P2E有点用处的东风，把上学期一个很有意思的softskill给整理了。 中间 就是一个教怎么组织项目的课，具体实例是建养鸡场，选址、选鸡蛋品种（bio或者非bio）、然后风险评估啥的。以下是一些有趣的概念的大略整理。 Définitions Project: Un ensemble de tâches coordonnées accomplies par des personnes utilisant des moyens dans le but de répondre au besoin du client avec la qualité demandée en temps et coûts maitrisés Gestion de projet: La Gestion de projet s’assure du déroulement opérationnel prévu dans la planification. Elle reporte à la fonction de pilotage de projet sur l’avancement, elle sollicite des prises de décisions et remonte des alertes Management de projet: Direction + Gestion = Management Cadrage(框架) du Project L’identité du client Les objectifs du projet 目标应该满足的原则：S(Spécifique)M(Mesurable)A(Atteignable)R(Réaliste)T(Temporel) Les délais à respecter Les limites du budget à investir L’utilité du projet La rentabilité escomptée du projet Décomposer le projet WBS WBS : Work Breakdown Structure. Décomposition hiérarchique, axée sur les livrables, du travail que l’équipe de projet doit exécuter pour atteindre les objectifs du projet et produire les livrables souhaités. 做法： Spécifier les objectifs du projet Identifier spécifiquement les produits, services ou résultats Identifier les travaux Subdiviser les éléments jusqu’au niveau qui permet la planification et le contrôle PBS Product Breakdown Structure 注：当时好像是上课没咋讲这个，后来是按照网上(ZHIHU)的文章说，WBS是以项目结果为导向的工作过程的结构分解，PBS是项目交付结果本身为对象进行的层级结构分解来做的。具体到这道题，就是，WBS包含整个项目管理，PBS只是按照养鸡场本身按照地基、外部建筑、内部建筑、服务设施这样子分级。 Diagramme de Gantt C’est un outil que peut aider à définir un planning réaliste. 貌似就是一个项目的时间的进程表，找出要做的事情，然后分析发生的先后或者并行关系，搞成条状表就行了。 Exemple(红色表示关键事件) : PERT C’est un outil souvent utilisée pour la gestion de projets importants et à long terme. PERT = Program Evaluation and Review Technic (ou CPM: Critical Path Method) 就是把上面那个Gantt图给这样子表示，然后往里面写时间就行，然后选时间最大的那条线（不是我说，这好像算法里面的那个啥图 Exemple: Les risques Principaux risques incluent Risques financiers, Risques marchés, Risques technologiques, Risques liés à l’équipe. Pour gestion des risques, on peut utiliser le table comme ça, 就是两部分：严重程度+发生概率 对，记得当时有个文化shock还蛮有趣的小点就是，当时有个风险是员工absent，然后写应对措施，我说搞时刻表，然后其他人：推迟上班的时间或者改变工作环境。 结语 其实这个项目还有超级多的东西，当时TD课第一节课搞WBS、PBS和GANTT的图，第二节课搞投资和收益计算，第三节课是风险评估，参与程度递减，到最后一节课就除了汇报叭叭两句就完全没太参与进去，不知道在干嘛了T^T 反正最后结论就是要养bio的鸡，唔。","link":"/2022/02/07/PRO20/"},{"title":"PFONC_CM7","text":"PFONC_CM7 Généricité avancée Classes de types(Typeclasses) Instances Une classe de types définit un ensemble de fonctions que toute instance doit définir. 一个类型类定义了一组任何实例必须定义的函数。 比如说等于 123456789101112131415class Eq a where (==), (/=)::a -&gt; a -&gt; Bool -- Minimal complete definition: (==) or (/=) x /= y = not (x == y) x == y = not (x /= y)class (Eq a, Show a) =&gt; Num a where (+), (-), (*) :: a -&gt; a -&gt; a negate :: a -&gt; a abs, signum :: a -&gt; a fromInteger :: Integer -&gt; a -- Minimal complete definition: -- All, except negate or (-) x - y = x + negate y negate x = 0 - x On peut ensuite définir des instances de classes : 123456data Animal = Canard | Vacheinstance Eq Animal where Canard == Canard = True Canard == Vache = False Vache == Canard = False Vache == Vache = True Ou instances automatiques pour Eq, Ord (comparaisons) Enum ([x…y]), Bounded (maxBound::a, minBound::a), Show (show::a-&gt;String), ou Read (read::String-&gt;a) : 1data Animal = Canard | Vache deriving (Eq, Ord, Show) 所以instance是在定义操作符吗 Foncteur (functor) EXERCICE: Définir un type algébrique Expr a pour représenter une expression arithmétique sur des valeurs de type a et comportant les opérateurs d’incrément, de décrément, d’inversion[倒数], et de négation[否定] 123456data Expr a = Val a --这又是什么神奇的写法呜呜呜 | Inc (Expr a) | Dec (Expr a) | Inv (Expr a)--倒数 | Neg (Expr a)-- deriving Show Définir une fonction evaluate qui étant donnée une expression de type Expr a renvoit la valeur de type a correspondante 1234567evaluate :: (Fractional a) =&gt; Expr a -&gt; a--evaluate :: Expr a-&gt; aevaluate (Val a) = aevaluate (Inc a) = 1 + evaluate aevaluate (Dec a) = -1 + evaluate aevaluate (Inv a) = 1 / (evaluate b)evaluate (Neg a) = negate $ evaluate a Tester avec l’expression correspondant à dec(-(inc(4))). Et avec 1/0 ? 第一个因为加上-号所以没有测试成功，1/0输出是Infinity On veut éviter les valeurs infinies et les traiter explicitement à part : définir une fonction isZero qui indique si un Maybe a vaut 0 ; 123isZero :: Maybe a -&gt; BoolisZero Nothing = FalseisZero (Just a) = a==0 définir une fonction mevaluate qui renvoit cette fois un Maybe a, qui sera Nothing ssi l’expression contient une division par 0. 12345678910111213141516171819mevaluate :: (Eq a, Fractional a) =&gt; Expr a -&gt; Maybe amevaluate (Val x) = Just xmevaluate (Inc y) = let my = mevaluate y z = fromJust my--fromJust就是haskell里面一个函数，在说如果a是Jsut就返回a in if isNothing my then Nothing else Just $ 1 + z--fromJust my mevaluate (Dec y) = let my = mevaluate y in if isNothing my then Nothing else Just $ fromJust my - 1mevaluate (Neg y) = let my = mevaluate y in if isNothing my then Nothing else Just $ negate $fromJust mymevaluate (Inv y) = let my = mevaluate y in if isNothing my || isZero my then Nothing else Just $ 1 / fromJust my Les traitements pour les 4 opérateurs sont similaires : écrire une fonction d’ordre supérieur mfmap, qui étant donnés un opérateur de type a-&gt;b (incrément, décrément, etc.), ainsi qu’une valeur de type Maybe a renvoit le résultat de type Maybe b. 123mfmap ::(a-&gt;b)-&gt; Maybe a -&gt; Maybe bmfmap _ Nothing = Nothingmfmap f (Just x) = Just $ f x Simplifier la fonction mevaluate en utilisant mfmap. 12345678mevaluate_ :: (Eq a, Fractional a) =&gt; Expr a -&gt; Maybe amevaluate_ (Val x) = Just xmevaluate_ (Inc x) = mfmap (+1) $ mevaluate_ xmevaluate_ (Dec x) = mfmap (subtract 1) $ mevaluate_ xmevaluate_ (Neg x) = mfmap negate $ mevaluate_ xmevaluate_ (Inv x) = let my = mevaluate_ x in if isZero my then Nothing else mfmap(1/) my 再看也写不出来T^T Maybe, muni de mfmap, est appelé un foncteur Cette construction est généralisable pour d’autres constructeurs de type, elle permet de promouvoir (lift) une fonction de type a-&gt;b en une fonction de type m a-&gt;m b. Haskell possède une classe de types Functor, dans laquelle la fonction de promotion s’appelle fmap, fmap doit vérifier les propriétés suivantes : fmap id == id fmap (f.g) == (fmap f).(fmap g) Maybe, [], r-&gt; ont des instances de la classe Functor. EXERCICE: Vérifier que la fonction mfmap satisfait ces deux propriétés ; Définir la fonction fmap pour le constructeur de type [] ; 123fmap :: (a-&gt;b) -&gt; [a] -&gt;[b]fmap _ [] = []fmap f (x:xs) = f x : fmap f xs Définir la fonction fmap pour le constructeur de type r-&gt;. 1fmap :: (a-&gt;b) -&gt; (r-&gt;a) -&gt; (r-&gt;b)--用复合函数 f(g) = f.g 理解 Foncteur applicatif (applicative functor) EXERCICE: ajouter l’addition, la soustraction, la multiplication et la division au type Expr a 1234567891011data Expr a = Val a | Inc (Expr a) | Dec (Expr a) | Inv (Expr a) | Neg (Expr a) | Addi (Expr a) (Expr a) | Sous (Expr a) (Expr a) | Mult (Expr a) (Expr a) | Divi (Expr a) (Expr a) | Add3 (Expr a) (Expr a) (Expr a) deriving Show compléter mevaluate, en faisant apparaître comme précédemment une fonction mliftA2 qui joue le rôle de mfmap pour les fonctions à deux paramètres. 1234mlift2 ::(a-&gt;b-&gt;c)-&gt; Maybe a -&gt; Maybe b-&gt;Maybe cmlift2 _ Nothing _= Nothingmlift2 _ _ Nothing = Nothingmlift2 f (Just x) (Just y) = Just $ f x y définir apm ; 1234apm :: Maybe(a-&gt;b)-&gt;(Maybe a -&gt; Maybe b)--传入一个函数，然后输出一个函数--&gt;输出的是函数的结果apm Nothing _ = Nothingapm _ Nothing = Nothingapm (Just f) (Just x) = Just $ f x remplacer mliftA2 par mfmap et apm ; 12mlift2 :: (a -&gt; b -&gt; c) -&gt; Maybe a -&gt; Maybe b-&gt;Maybe cmlift2 f = apm.(mfmap f) écrire une fonction add3 qui somme trois éléments de type a ; 12add3 :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; aadd3 x y z = x+y+z ajouter un opérateur d’addition à 3 éléments dans Expr a et compléter mevaluate. 12345678910111213mevaluate_ :: (Eq a, Fractional a) =&gt; Expr a -&gt; Maybe amevaluate_ (Val x) = Just xmevaluate_ (Inc x) = mfmap (+1) $ mevaluate_ xmevaluate_ (Dec x) = mfmap (subtract 1) $ mevaluate_ xmevaluate_ (Neg x) = mfmap negate $ mevaluate_ xmevaluate_ (Inv x) = let my = mevaluate_ x in if isZero my then Nothing else mfmap(1/) mymevaluate_ (Addi x y) = mlift2 (+) (mevaluate_ x) (mevaluate_ y)mevaluate_ (Sous x y) = mlift2 (-) (mevaluate_ x) (mevaluate_ y)mevaluate_ (Mult x y) = mlift2 (*) (mevaluate_ x) (mevaluate_ y)mevaluate_ (Divi x y) = if isZero (mevaluate_ y) then Nothing else mlift2 (/) (mevaluate_ x) (mevaluate_ y) pure Soit mpure :: a -&gt; Maybe a la fonction telle que mpure x = Just x ; mpure transforme a minima un a en Maybe a et on peut l’utiliser à la place de mfmap avec apm : 123-- les deux sont équivalentsmfmap (+) (Maybe 1) `apm ` Nothingmpure (+) `apm ` (Maybe 1) `apm ` Nothing Alors Maybe muni de mpure et apm est un foncteur applicatif ; Cette construction est généralisable et permet de promouvoir des fonctions à plus de un paramètres. Haskell définit une classe de type Applicative dont les instances implémentent pure et ap (aussi notée (&lt;*&gt;)). Ces deux fonctions doivent satisfaire 1234pure id &lt;*&gt; v = v -- identitépure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)-- composition:组成pure f &lt;*&gt; pure x = pure (f x) -- homomorphisme:同态u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u -- interchangeabilité:可交换 Exercice: Définir fmap en fonction de pure et &lt;*&gt; fmap :: (a-&gt;b) -&gt; [a] -&gt;[b] pure fmap &lt;*&gt; a = pure le cas de r-&gt; On peut définir pure et &lt;*&gt; pour que r-&gt; soit un foncteur applicatif : 1234pure::a-&gt;(r-&gt;a)pure x = (\\_ -&gt; x)(&lt;*&gt;)::(r-&gt;(a-&gt;b))-&gt;(r-&gt;a)-&gt;(r-&gt;b)--这不是fmap吗？f &lt;*&gt; u = (\\x -&gt; f x (u x)) Exercice: Donner une expression sans variable ni λ (point-free) des fonctions : f x=(cos x)∗xf\\ x = (cos\\ x) * xf x=(cos x)∗x 1f = (*) &lt;*&gt; cos $ g\\ x = (cos\\ x) * (sin\\ x)$ 1g =pure (*)&lt;*&gt; cos &lt;*&gt; sin Monade Monades et foncteurs Toute monade est un foncteur Toute monade est un foncteur applicatif b站 fmap: (a-&gt;b) -&gt; f a -&gt; f b ,将盒子[Just,Maybe类型]里面的值取出来进行函数操作 &lt;*&gt; (apply函数)：f (a-&gt;b) -&gt; f a -&gt; f b,将盒子装的函数取出来与盒子中的值进行操作 bind函数&gt;&gt;=: Monad f =&gt; f a -&gt; (a -&gt; f b) -&gt; f b, 接收一个值的盒子和一个返回值是盒子的函数，返回一个装着值[结果]的盒子 好难哦","link":"/2022/11/12/PFONC_CM7/"},{"title":"PYTHON_入门学习","text":"PYTHON_入门学习 b站搜python出来的第一个：https://www.bilibili.com/video/BV1wD4y1o7AS?p=25&amp;spm_id_from=pageDriver&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 一般推荐，有点拖，但是一节很短看起来不累 CHAP_0 编码 bit byte: 8 bit kb: 1024 byte mb : 1024kb ASCII码，GB2312(中文)，Unicode,UTF-8 变量 有一些保留字keyword不能用作变量名，list啊class啊这些 定义和实际组成 一些常见的数据类型:int,float,bool,str 获取数据类型: type(变量名) 类型转换:str(age) 可以用单引号’age‘实现 注释 多行注释：三引号 中文注释：#coding:gbk input() 将输入内容存储到变量，注意一般存储的是str类型的 def 函数名(参数):#这里的参数*arg就是表示随意取几个 函数体#不写的话加上pass占位python print 数字不加引号 字符串加单双引号三引号都行，三引号可以在代码里面换行 可以输出含有运算符的表达式：print(3+5)，print(‘我叫’+name)。注意：1.浮点数，以及一个奇怪的解决方法 2.一定是同类型才能相加 输出到文件： 123fp = open('D:/text.txt','a+')#a+表示如果文件不存在就创建，存在就在文件内容里面追加print('输出内容1',file=fp)fp.close() \\n:换行,print(‘hello\\nworld’) \\t:空格 r:输出原字符,print(r’\\n’) 运算符 算术运算符：+,-,*,/(是有小数的),//(整除),%,**(幂运算) 赋值运算符：=，支持+=这种，支持解包赋值：a,b,c=20,‘nana’,5.5-----&gt;交换就可以这样子写a,b = b,a，支持链式赋值，链式赋值指向的存储地址一致 比较运算符：&gt;,&lt;,!=,==,结果是bool类型 布尔运算符：and(与 &amp;&amp;),or(或 ||),not(非 !)； ​ in,not in 可以用于字符匹配 位运算：$按位与，|按位或，&lt;&lt;左移（2倍），&gt;&gt;右移（1/2） 运算符的优先级： pycharm 打断点+shift和f9就是调试模式 CHAP_1 程序的组织结构：顺序，选择，循环 空列表:[],list() 空元组:(),tuple() 空字典:{},dict() 空集合:set() 选择结构 12345678a = int(input('please input a: '))if a &gt; -10 and a &lt; 5: a += 1elif a &gt; 5 : a -= 1else : a = 0print(a) 和C++区别不大，注意elif、冒号和缩进，空的话写pass 简写的那种写法: x if 判断条件 else y 1print(str(a)+'大于'+str(b) if a &gt; b else str(a)+'小于等于'+str(b)) 循环结构 range() 用于创建一个整数序列,在循环中很重要 创建方式 123r = range(10)#0到9r = range(1,10)#1到9r = range(1,10,2)#1到9，步长为2 创建的是迭代器(?)，打印的话转成list,可以使用in和not in 12if 9 not in r: print('wa') while 例：1到100的偶数和 123456a = 0count = 0while a &lt; 101: a += 2 count += aprint(a) for-in for 自定义变量 in 可迭代对象: ​ 循环体 自定义变量: 当它不被使用时可以使用 _ 可迭代对象: 字符串，range() 例：1到100的偶数和 1234count = 0for item in range(0,101,2): count += itemprint(count) break 和 continue break直接退出循环，continue就是不管后面的直接执行下一次循环（好像也可以用pass？）都是本层循环，和c++蛮像的 else 就是说循环体后面可以接着写else，表示在没有break时执行else 123456789for item in range(3): pwd = input() if pwd = '888': print('wa') break else: print('non')else: print('冻结') 嵌套循环 例：打印99乘法表 1234for i in range(1,10): for j in range(1,i+1): print(j*i,end='\\t')#特别注意这里表示不换行打印 print() CHAP_2: list,dict,tuple,set,str 列表 存储多个元素，相当于数组，但可以存不同类型的元素 创建：直接使用中括号，或者调用内置函数list() 12lst = ['hello',98,'world']lst2 = list(['hello',98,'world'])#?有点感觉没太必要的样子 或者列表生成式 lst=[i for i in range(1,10)] 获取元素 index()函数，返回元素在list的索引，相同的返回第一个出现的地方 12lst.index('hello')lst.index('hello',1,4) 单个元素：取某个元素就是lst[0]这样子，lst[-1]表示最后一个，就是负的话就从右开始 多个元素：切片 1234567lst3=lst[1:6]#默认步长为1lst3=lst[1:6:2]lst3=lst[:6:2]#默认从0开lst3=lst[1::2]#默认到最后#step为负表示倒着取lst3=lst[::-1]lst3=lst[7:2:-1] 增删改查 查：in 和 not in，遍历直接循环就行，list是可迭代变量, for item in lst这样子就可以 增： 1234567lst = [10,20,30]lst.append(100)lst2 = ['hello','world']lst.extend(lst2)lst.insert(1,90)#切片lst[1:]=lst2#就是把位置1以后的全换成lst2了，但感觉是修改 删： 1234567lst=[10,20,30,30,40]lst.remove(30)lst.pop(-2)#默认是最后一个lst.clear()lst.del()#切片lst[1:3]=[]#感觉也是修改 改：直接索引或者切片改 排序：sort()函数或者sorted() 123lst=[70,20,50,30,40]lst.sort(reverse=ture)#默认升序，这样是降序lst_ = sorted(lst)#不改变原列表 字典 是一个可变(值可以增删改这样子)的无序序列，以键值对的形式存储，使用花括号定义 类比C++的哈希(那个map 注意：键值不能重复，不可变 创建：花括号直接定义，内置函数dict() 12scores = {'张三':98,'王五':45,'李四':78}student = dict(name='jack',age=20)#多个咋整嘞，不管 **zip()**函数把两个列表组合成字典： 123items = ['A','B','C']prices=[9,6.2,3.1]d = {item:price for item,price in zip(items,prices)} 获取元素 获取value：[]、get() 123scores['张三']#没有的话会报错scores.get('张三')#没有的话输出nonescores.get('张三',56)#没有的话输出56 获取视图： 123keys = scores.keys()#列表values = scores.values()#列表items = scores.items()#列表,但元素是元组 增删改查 查：查的是key，in 与 not in，比如 if ‘张三’ in scores : print(scores[‘张三’]),遍历也是直接循环就行：for item in sorce 删: del scores[‘张三’]，清空scores.clear() 添加: 增加键值对，scores[‘张一’]=97 修改：scores[‘张三’]=96 集合 没有value的字典–&gt;意味着集合中的元素不能重复，无序可变，也是用{}或者set()来定义 12345s = {5,6,3,'yu'}s = set(range(6))s = set([5,6,3,'yu'])#列表转集合s = set((5,6,3,'yu'))#元祖转集合s = set('yu')#字符串转集合 生成式：s = {i for i in range(6)}和列表一样，改个花括号就是，不过出来时无序的 增删改查 查：in 与 not in,遍历也是直接循环就行：for item in s 增：add:加一个和update:加很多 1234s = {5,6,3,'yu'}s.add(80)#无序的，不知道在哪儿s.update(80,'ll')s.update(lst) 删：remove，discard,pop,clear 123s.remove(5)#没有的话会报错s.discard(4)#没有的话不会报错s.pop()#随机删 数据操作 判断：相等：==或者!=，子集关系: issubset()和issuperset(),有没有交集isdisjoint() 取交集：s1.intersection(s2) 或者 s1 &amp; s2 取并集：s1.union(s2) 或者 s1 | s2 取差集：s1.difference(s2) 或者 s1 - s2 取对称差集(就是s1和s2的全集减交集)：s1.symmetric_difference(s2) 或者 s1 ^ s2 注s1和s2都是不发生变化的 元组 是不可变序列（没有增删改操作），使用小括号定义 不可变可以保证安全性 创建：(),tuple() 没有生成式哟 1234t = 'python','world',98t = ('python',)#一个元素记得加逗号t = ('python','world',98,[7,8])t = tuple(('python','world',98)) 其实不是指元组就不能改了，简单理解是数据类型不能改，就是指向的地址不能改，但地址里面的value是可以改的，比如说t[4]是列表，它的那些增删改啊也是能用的 获取元素 直接使用索引：t[0]这样子就可以 查 in 与 not in, 遍历也是一样循环for item in t: 4种数据结构的小结 CHAP_3: 字符串 不可变序列，可以使用单引号、双引号、三引号进行定义 查找子串 12345s = 'hello,hello's.index('lo')#3s.rindex('lo')#9s.find('lo')#没有不会报错s.rfind('lo') 大小写转换 12345s.upper()s.lower()s.swapcase()#小写转大写，大写转小写s.capitalize()#变成第一个字符大写，其余小写s.title()#变成每个单词的第一个字符大写，其余小写 对齐 12s = 'hello,python's.center(20,'*')#结果***hello,python*** split() 123456s = 'hello,python's.split()#默认分割符为空格，返回列表['hello',',','python']s.split(sep=',')s.split(,maxsplit=1)#可以指定最大劈分次数s.rsplit()#从右侧开始劈分 判断 123456s.isspace()#空白字符s.isalpha()#是不是由字母组成s.isnumeric()#是不是由数字组成s.isalnum()#是不是由数字+字母组成s.isdecimal()#十进制数字s.isidentifier()#合法标识符：字母数字下划线 replace() 123s = 'hello,python,python,python's.replace('python','java')s.replace('python','java',2) join:可以把列表、元祖连成字符串 1234lst=['hello','python']'*'.join(lst)#输出字符串：hello*python#也可以连字符串，不过比较怪--&gt;+'*'.join('python')#输出是p*y*t*h*o*n 比较：直接用算术运算符的＞&lt;这些 切片：和列表类似，s1 = s[:6:2]#开始切到6（不包含6），步长为2（负数表示从后往前） 占位符 {}做占位符或者% 12345name = 'A'age = 20print('我是%s，今年%d岁' % (name,age))#可以指定精度宽度啥的%7d,%.3fprint('我是{0}，今年{1}岁'.format(name,age))print(f'我是{name}，今年{age}岁') CHAP_4: 函数 创建和调用 123def calc(a,b): return (a*a-b*b)print(calc(10,20)) 注意冒号和空格 参数 参数的默认值：def fun(a,b=10):#表示说可以传1个参数，传两个就该啥啥 参数传递 python中的参数传递有两种方式:位置实参和关键字实参 1234#位置实参calc(10,20)#关键字实参calc(b=10,a=20) 注意 不可变对象(int，字符串，元组)在函数体的修改不会影响实参的值，可变对象（列表，字典，集合）会影响 123456789101112def fun(a,b): print(a) print(b) a=10 b.append(10) print(a) print(b)a = 11b = [7,8,9]fun(a,b)#a不会变，b会print(a)print(b) 个数可变的参数 位置参数：*,结果是元组 关键字参数：**，结果是字典 12345678def fun(*args): print(args)fun(10)fun(10,20,30)def fun(**args) print(args)fun(a=10,b=20,c=30) 注意：可变的参数只能有1个，但可变的位置参数和可变的关键字参数能一起存在 函数支持参数时，调用能用*这样子搞 返回值 多个时以元组形式返回 例题：斐波那契数列 12345678910def fabo(i): if i &lt;= 0: return elif i == 1 or i == 2:#注意or，写成|愣了好久 return 1 else: return fabo(i-1)+fabo(i-2)print(fabo(6)) CHAP_5: 类与对象 面向过程与面向对象 类与对象 类 类：多个类似事物组成的群体的总称 类的组成：属性，实例方法，静态方法和类方法【类里面的函数叫做方法】 类属性：直接定义在类里面（类方法外）的变量，被类的所有对象共享，可以使用类名直接访问 初始化方法（注意是两个下划线）:相当于构造函数，self理解为this指针 实例方法：类里面的函数 静态方法：用@staticmethod进行修饰，使用类名直接访问的方法（Student.cm()） 类方法：用@classmethod进行修饰，使用类名直接访问的方法 对象 类的实例化就是对象的创建 stu1 = Student(‘张三’，20) 其实stu1由3部分组成，name，age和类指针（指向了Student类） 动态绑定 直接使用对象名添加属性并赋值，也可以给他添加方法 123456def show() print('')stu1.gender = '男'stu1.show = showstu1.show() 好任性啊感觉 封装、继承与多态 封装 私有属性没有专有修饰符，在前面打两个下划线表示私有属性 123456789class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def show(self): print(self.name,self.__age)stu1 = Student('张三'，20)stu1.show()print(stu1.__age)#就不行 硬要使用也是可以的，用dir(stu1)去读然后有个啥就可以用了，不过说不推荐 继承 python支持多继承，如果一个类没有继承任何类，则默认继承object类 子类的构造函数(init)必须调用父类的构造函数：super().init_（） 123456class HaoStudent(Student): def __init__(self,name,age,score): super().__init__(name,age) self.score=scorestu2 = HaoStudent('张一',20,98)stu2.show() 方法重写：调用+重写–&gt;super().xxx()，然后后面加就成 OBJECT类：所有类的父类 多态 没懂 特殊属性与特殊方法 123456789101112class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def __len__(self): return len(self.name) def __add__(self,other): return self.name+other.namestu1 = Student('张二'，20)stu2 = Student('张四'，20)print(len(stu1))print(stu1.__add__(stu2)) new那个不太懂，不太想懂 赋值、浅拷贝、深拷贝 赋值：只是形成两个变量，实际还是指向同一个对象 浅拷贝：包含的子对象内容不拷贝，源对象与拷贝对象引用同一个子对象 12345678910111213141516171819202122232425262728class CPU: passclass Disk: passclass Computer: def __init__(self,cpu,disk): self.cpu = cpu self.disk = disk#赋值--&gt;内存地址是一致的cpu1 = CPU()cpu2 = cpu1print(id(cpu1))print(id(cpu2))#浅拷贝--&gt;computer不一样但cpu和disk是一样的disk = Disk()computer = Computer(cpu1,disk)import copycomputer2 = copy.copy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer2),id(computer2.cpu),id(computer2.disk))#深拷贝--&gt;computer,cpu,disk都不一样computer3 = copy.deepcopy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer3),id(computer3.cpu),id(computer3.disk)) 深拷贝：递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同 CHAP_6: 文件，模块化编程 文件 1234567891011121314151617181920file = open('a.txt','r')#只读file.read()#读所有file.read(3)#读3个file.readline()#读一行file.readlines()#读所有行到列表file.seek(2)#从第几位开始读，默认0file.tell()#返回文件当前指针位置file.close()file2 = open('b.txt','w')#只写，如果文件不存在则创建，覆盖写,追加写是afile2.write('python')file2.flush()#缓冲file2.writelines('python')#不加换行符写file2.close()file3 = open('a.png','rb')#二进制读,可以读图片file4 = open('b.png','wb')#二进制写file4.write(file3.read())file3.close()file4.close() with：上下文管理器，不用写close() 12with open('a.txt','r') as file: file.read() 也可以用在类上 12with A() as file: file.__init__('5',5) OS模块：操作系统和文件系统模块 1234567import os#可以执行exeos.startfile('d:\\\\qq.exe')os.mkdir('newdir')#创建目录#os.pathimport os.path()os.path.abspath()#返回绝对路径 模块化编程 一个.py的文件就是一个模块，导入模块 12import mathfrom math import pi#注意一下顺序哟 自定义模块报错时：在目录文件右键：mark directory–&gt;sources root 主程序：就是这下面的内容只有在运行这个py文件时才运行，调用时不运行 12if __name__ = '__main__': print()","link":"/2022/08/31/PYTHON/"},{"title":"SSTEM_DS","text":"SSTEM期末自救 TD TD1 Question: Après avoir défini les différentes parties prenantes du Système, identifiez les différentes utilisations et modélisez les sous forme d’un diagramme des cas d’utilisation Diagramme des cas d’utilisation 的 étape: Finalité,Missions,Objectifs(套话) Finalité: Assurer le fonctionnement des systèmes d’information de réseau ferroviaire. Missions:具体任务，得在问题中找，可能用到的词：définir,assurer,informer Objectifs: Pendre des dispositions raisonnable pour tous les trains grace à la coopération mutuelle entre [……] Les parties prenantes 找实体，可以画个方框图 comme ca： Les cas d’utilisation 画小人图 一些值得注意的点：方框+标题，拓展的include和extend(都是虚箭头画的) include: Celles qui sont incluses dans une action existante —&gt;obligatoirement,一定被执行 ​ 1.任务与子任务 ​ 2.小人的任务与任务间 extend: Celles qui étendent une action existante–&gt;éventuellement,可能被执行 Les interfaces 随缘 TD2 Question: 1.Identifier les parties prenantes et leur rôle dans ce processus 关键是区分ACTEUR OU COLLABORATEUR–&gt;看是否有开启或者终止活动 然后在行为中找出触发事件(Délencheur)和终止事件(Final) 可能用到的一些词：envoyer,refuse,annulation,verifier 2. Modéliser ce processus en BPMN 表示判断：sinon,valide 表示发信：envoyer,demande 表示收信：recevoir 终止和起始：都是空心圆但终止的要粗一点 TD3 Question: 1.Concevoir le diagramme Entités-Associations de ce système. ​ 画ER图等价于画MCD: Modèle Conceptuel des Données(概念模型) ER(MCD):主体+关系+实体与关系的比 objet &lt;=&gt;entité Propriété &lt;=&gt;attribut，属性，列 没有外键 lien &lt;=&gt;association 记得加比例，关于比例–&gt;est le lien entre l’entité et l’association 是minimum+maximum minimum:0:peut ne pas apparaître ​ 1:doit apparaître maximum:1:ne peut pas apparaître plus d’une fois ​ n:peut apparaître plusieurs fois 一些典型的关系及其比例：être: chefdegare和être是1:1，être和personne是0:1 ​ detype: salle和detype是1:1,detype和typedesalle是0:n TD3的2到5题是对ER的评价和补充，暂时不想展开看（TO BE ADDED） TD4 Question: Cet exercice s’appuie sur la modélisation de gestion de réseau ferroviaire mis en place lors des TDs précédents. Il a pour but de pratiquer SQL à travers l’écriture d’un certain nombre de requêtes. Le MCD utilisé est joint ci-dessous. 1.À partir du MCD, mettre en oeuvre le modèle physique de la base de données (MPD) 逻辑模型MLD: Modèle logiques与物理模型MPD: Modèle physiques：物理模型有数据类型 MPD:含实体的外键+箭头+数据类型 实体 标出主键（PK）与外键（FK） 箭头 箭头指向：从表指向主表的外键所在的位置 从表：以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询. 箭头：从表外键➡️主表 数据类型 integer/float character varying(256/128) date/datetime/timestamp 2.查询 基本语句： 1234SELECT (DISTINCT) 列名 FROM 表名 NATURAL JOIN 表名WHERE: 1.UPPER(Nom) LIKE '%TER%' 2.EXTRACT(YEAR/MONTH/DOW/HOUR/MINUTES FROM 表名)=…… TD5 1.表的创建 1234567891011121314CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY/NOT NULL/或其他 --联合主键 CONSTRAINT 约束名 PRIMARY KEY(列名1,列名2) --外键约束 CONSTRAINT 约束名 FOREIGN KEY(外键名) REFERENCES 表名(外键名) ON DELETE NO ACTION ON UPDATE CASCADE) 2.表的增删改 INSERT 12INSERT INTO 表名 VALUES ('','','')--若插入的列为空，写NULL DELETE 12345678910DELETE FROM 表名WHERE --where里面写查询--EXMPLEWHERE trajet_id in (SELECT trajet_id FROM arret WHERE EXTRACT(YEAR FROM arret_horaireprevu) = 2016 AND EXTRACT(MONTH FROM arret_horaireprevu) = 2 AND EXTRACT(YEAR FROM arret_horaireprevu) &lt; 9) UPDATE 123UPDATE 表名SET 列名WHERE …… TP TP1 查询工作SELECT 1.UNION SELECT: Donner la/les fonction(s) de Yvon Manac’h 123456789101112SELECT 'Mecanicien' FROM Mecanicien NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Agent' FROM Agent NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Conducteur' FROM Conducteur NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'ChefDeGare' FROM ChefDeGare NATURAL JOIN PersonneWHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' 2.嵌套查询:Donner les horaires en gare de Nantes, pour les trains qui relient Nantes à Lyon pour la journée de demain. En pratique, on regardera quels trajets s’arrêtent à Nantes et Lyon. Attention, les gares de Lyon ne s’appellent pas ‘Gare de Lyon’ mais comporte Lyon dans leur nom. 12345678910111213141516SELECT DISTINCT train_id,trajet_id,arret_horaireprevuFROM train NATURAL JOIN trajet NATURAL JOIN arretWHERE trajet_id IN( SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%NANTES%' INTERSECT SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%LYON%')ORDER BY arret_horaireprevu--关于intersect:取交集--&gt;并集：union,差集：except TP2 继续写select(聚集函数) 1.Combien y a-t-il de conducteurs dans la base ? 12SELECT COUNT(*) --COUNT(*)拿来统计列FROM conducteur 2.De combien de gare chaque chef de gare est-il responsable? 12SELECT personne_nom,personne_prenom,personne_id,count(*) FROM gare NATURAL JOIN chefdegare NATURAL JOIN personne GROUP BY personne_nom,personne_prenom,personne_id ORDER BY count 注意点：GROUP BY上写除函数之外的所有的select,聚集函数后可以直接命名，comme ca 3.MAX、AVG TP3 SELECT + 导出PDF Générez un document, nommé rapport05.pdf, avec la liste des 5 propriétaires possédant les plus grandes superficies, triés en ordre décroissant des sommes de superficie de terrain qu’ils possèdent. On utilisera pour cela la fonction ST_AREA（算面积使用） 1234SELECT personne_nom,SUM(ST_AREA(parcelle_geometry)) AS area,COUNT(parcelle_id)FROM culture NATURAL JOIN parcelle NATURAL JOIN appartient NATURAL JOIN personneGROUP BY personne_nomORDER BY area DESC PROJECT TD6&amp;7 et TP 4&amp;5","link":"/2022/01/27/SSTEM-DS/"},{"title":"SSTEM01","text":"概要 介绍SysML和其简单应用,对TD1的内容进行简单的总结与归纳。 定义 SysML: un outil pour modéliser les Systèmes But: Analyse et description des systèmes( Besoin, Description de sous-systèmes, Chîne d’information) But pour cet TD: Analyse externe d’un systèmes Etape（以exemples进行更好说明） 0.Exemples Analyse externe d’un radio-réveil. 1.Identification de la finalité des missions et objectifs du système ​ finalité: Qu’est-ce qu’apporte le Système?à quoi sert-il? ​ missions: Comment le Système contribue-t-il à la finalité. Sur quels principes reposent la mise en oeuvre de la finalité? ​ objectifs: Comment le Système met-il en oeuvre ses missions? Exemples: ​ finalité: réveiller une personne endormie ​ missions: réveiller l’utilisateur à l’aide d’un signal sonore (bip ou radio choisie) à une heure prédéfinie. Diffuser le signal sonore émit par une station radio. ​ objectifs: Émettre un son suffisamment fort pour le réveil (ex: &gt; 90db). 2.Identification de interacteurs ou parties prenantes du système Faire une liste des parties prenantes: les éléments qui sont relies au Systèmes (systèmes physiques, personnes…) via une action sur ce système. Note: Les éléments interne du Système ne font pas partie des ‘parties prenantes’ Exemples: Faire un diagramme de bloc Le système est placé au centre du schéma. Il est relié aux parties prenantes. Sur le lien, on peut faire figurer la nature du lien 3.Les cas d’utilisation Le cycle de vie du Système peut comporter: conception, implémentation, implémentation, utilisation, démantèlement, recyclage. ​ Règles de dessin Les parties prenantes qui utilisent ou ont une action sur le Système seront représentées comme des acteurs, un petit bonhomme Le Système est représenté comme un bloc Dans le bloc figurent les actions(fonctionnalités) que peuvent faire les acteurs. Elles sont représentées par une ellipse. Dans le bloc, on doit dessiner les actions importantes et les liaisons entre les actions. 2 types: extend, include(obligatoirement). 4.Les interfaces Certaines des parties prenantes alimentent/sont alimentées par le Système. Pour chacune d’elle, on peut définir le/les flux(matière-énergie-information) qui sont échangés. ​ Règles de dessin Le système est un bloc au centre du schéma. Les flux entrants et sortants du système sont indiqués par des boites de connexion sur le bord du bloc central. Les flux sont également décrits par des boites sur le coté du diagramme. TD TD1小结：用学长的拼拼凑凑的搞上去的，但自己的第一次思考并没有把finalité,missions,objectif给找好。在理解上存在偏差。希望之后能够有所改进 单词 Outil:工具 Radio-réveil:收音机闹钟 Sert:服务、帮助 Apporte：带来，提供 Mise:安装 oeuvre:工作 Diffuser:扩散、传播 Schéma:图解、提纲 Figurer:画出、代表 conception, implémentation, implémentation, utilisation, démantèlement, recyclage：设计，实施，实施，使用，拆卸，回收。 Flux:流动 Obligatoirement：必须的 结语 来法国后的第一篇博客真的太多想说了的。（虽然在国内也没写几篇 首先就是上这节课的那天下午是流体的期末，所以对课上很多内容都不知道，包括TD1的实例，也有其他许多待修正的部分。 其次就是很多地方都是照搬的PPT，没有起到一个很好的总结和思考。 这篇博客完成的也是磕磕绊绊，对法语键盘的不熟悉（比如打不出oe和^i)和法语的不熟悉。 最后的最后，希望自己坚持下去，做好记录，出现越来越少不认识的单词和行文中越来越少的中文。 就祝自己能以此为新开始，用Blog的形式见证我在南特这两年的跌跌撞撞的成长。","link":"/2021/12/06/SSTEM01/"},{"title":"Voyage-Italie","text":"行程 马耳他⟶\\longrightarrow⟶罗马⟶\\longrightarrow⟶米兰 马耳他 好看！ 看到海就真的超级开心 能在这个岛上过暑假的小孩应该很幸福吧 但就是住的好远（晕车真的难顶 体验了壁炉和烤鸡 还有偷偷摘下来的仙人掌的果 整体风格蛮中东的 但又特别电影 穷途末路的英雄的流浪故事 碰到的司机大叔也人超级好 希望这两年间能再去一次 带着夏企和橘子汽水 想念夏天 罗马 西班牙台阶⟶\\longrightarrow⟶总统府（？maybe）⟶\\longrightarrow⟶圣天使堡⟶\\longrightarrow⟶梵蒂冈⟶\\longrightarrow⟶万神庙⟶\\longrightarrow⟶斗兽场⟶\\longrightarrow⟶什么祭坛 DAY1 西班牙台阶，总统府和一个喷泉(and 张女士) 夕阳好看！ 龙虾意面好吃！ 冰淇淋好吃！ DAY2 圣天使堡+法院+梵蒂冈+万神庙 夕阳好看！ 在梵蒂冈被骗了10欧QAQ 但暴走了两次不亏！（Cappella Sistina 看到了前前前手机壁纸，开心 DAY3 斗兽场+祭坛 中餐好吃！ 臭鸟拉屎（猖狂到当地老太太会打伞的程度，可恶 米兰 个人不官方的宣布 米兰就是旅游荒漠 只就去了大教堂，然后有猥琐的偷偷喂鸽子 但是！ 米兰火锅！好好吃！店名：“巴倒辣”。人生建议：不能点中辣不能点中辣不能点中辣！（上次被辣成瓜娃子还是在重庆的时候了 结语 虽然没去佛罗伦萨和威尼斯，但得歇一段时间不看人文类风光啦~ 意大利再见 ε≡٩(๑&gt;₃&lt;)۶","link":"/2022/02/01/Voyage-Italie/"},{"title":"Voyage-Paris","text":"行程 铁塔⟶\\longrightarrow⟶迪士尼⟶\\longrightarrow⟶卢浮宫⟶\\longrightarrow⟶奥赛⟶\\longrightarrow⟶先贤祠 Day 1 下午到的 铁塔上看的夕阳 超好看！ 顺便打卡盗梦空间的桥 Day 2 迪士尼好玩的 未来的日子永远爱跳跳虎 Day 3 卢浮宫真的好大就是说 法国斥巨资修建这座宫殿或许比里面的展品还要了不起。 雕塑真的好厉害。 伊斯兰教的艺术印象蛮深。 然后镇馆三宝打卡成功：维纳斯、蒙娜丽莎、胜利女神 画的话，宗教类、宫廷很多。一开始很震撼，看多了，嗯，装不下。 Day 4 奥赛博物馆的话就是好看的画 梵高好看 莫奈也好好看 还有个点彩画派 很喜欢的画买了明信片但忘记画家了T^T 出来时的公园，好看到分不清是不是在画中 （或许还记得出来一家商店里面的9000欧的衣服？ Day 5 先贤祠 外面比里面好看 只记得里面的钟摆了 看到了一群穿正装的未来大佬们 听说隔壁是很法国很厉害的大学 站在那里真的会有 一种学术的 很厉害的感觉 听说建筑仿的是意大利的万神庙 那就正好 下一站 意大利！ 最后 巴黎再会~","link":"/2021/12/08/Voyage-Paris/"},{"title":"Voyage-Suisse","text":"行程 日内瓦⟶\\longrightarrow⟶Interlaken⟶\\longrightarrow⟶Grindelwald⟶\\longrightarrow⟶Bern Day 1 浅浅逛了下日内瓦，很舒服也很秋天 没看到喷泉但喂了鹅子，碰见一个普通话贼好的纪念品店老板娘 Day 2 就是莫名其妙花了200欧上雪山了，至今也不知道是first还是少女峰 虽然大家都鬼迷日眼的，但莫名觉得很可爱的一些丑图！ 一起歪歪头吧！ 然后格林德沃真的真的真的太美了,完全无滤镜直拍！虽然一股子牛粪味！ Day 3 滑翔伞！(想吐版 感觉就是只有第一下失重那下爽，还是跳伞爽呜呜呜 转车的功夫去了瑞士首都，好冷的冷知识，瑞士首都是伯恩，去了爱因斯坦故居，可能由于待的时间不多所以对整个城市影响超级好，很有历史韵味的欧洲城市，去的时候是大太阳，走在路上好舒服好舒服，有板栗的香味。 结语 最后回南特的飞机上看到了很好看很好看的落日，要开始新一轮的勇敢学习啦！ 开始期待圣诞","link":"/2022/11/12/Voyage-Suisse/"},{"title":"algorithm-绪论","text":"算法_第一章__绪论 1.算法的五大特征 输入、输出、确定性、有穷性、可行性 2.算法的描述方法 自然语言描述 流程描述 伪代码描述 3.算法的重要问题 排序、查找、字符串匹配、图问题、组合问题、几何问题、数值问题 4.算法基本的数据结构 线性结构、数结构、图结构、集合 5.算法设计的方法策略 蛮力法、递归与分治、动态规划、贪心算法、回溯与分治","link":"/2021/12/06/algorithm01/"},{"title":"序言","text":"序 太晚了，明天写。 截断测试 图片测试： 数学公式测试 T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) 公式测试2 T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) Flags： 侧边栏多级分类 FLUID整理 Pro20整理 SSTEM一周一记","link":"/2021/12/05/hello-world/"},{"title":"那些细碎而美好的存在","text":"序 一个持续更新的日常记录 2022_2_1 我画画真好看，嘿嘿 2022_2_2 -经过一天的讨论，滑雪假兜兜转转起起伏伏，最终成为了和学长一起的法国自驾游（开心期待 -希望快点长大到可以开着车向着随机方向选择随机地点随机停留的那天 -莫名其妙的去测了MBTI，第三次了吧，真的好神奇，还是INFJ，从高考填志愿到大一再到今天。 2022_2_3 安然给的国家爸爸发的大白兔，四舍五入我也收到大使馆的春节礼物啦 2022_2_4 很难不记录 2022_2_7 周六周末没有学习，可恶 看到一个好有意思的财神爷饭，周五做给大家吃，期待复刻，嘿嘿 2022_2_9 关于财神饭的复刻,成功! 2022_2_10 抓住摸鱼的zwl子 2022_2_11 摸了一个谷爱凌 2022_2_12 旅行途中遇到的可可爱爱的善意 2022_2_14 记录我的意外好吃的番茄牛奶辣椒粥 2022_2_21 春天来了 2022_3_4 可以做梦不补考吗(靓女流泪 2022_3_7 好好听 2022_8_8 突然更新 和学长们告别 和贺文城告别 不喜欢告别 2022_8_20 想记录遇见的可爱的人们的那些陌生的善意。 去罗卡角火车上疯狂葡萄牙语输出的阿姨 一直说着CHINA和FRIENDSHIP大概是巴基斯坦的里斯本纪念品店老板 巴塞罗那机场把叫住我们的爷爷奶奶 领着我们走到地铁站的伏林航空的空姐 去往圣家堂小路上因为给窗台上的猫猫打了招呼，抱起了第二只猫猫向我们挥手的叔叔 酷酷又温柔的音乐人房东的香香的洗衣液 热情良善家庭美满的司机师傅 我想记住这些 宇宙温暖，人间也值得 2022_8_22 千山茶客的女将星好好看！ 又哭又笑的看了一整个通宵 肖钰：“凉州城外，有一处峰台，名曰乘风。这些女子生前身不由己，笼鸟池鱼。葬在此处，愿她们来生自由乘风，啸傲湖山吧。” 宴宴：&quot;手中执剑之人，更应该明白剑锋所指何处，是对着身前的人，还是身后的弱者。 我绝不向弱者拔剑。 手中执剑之人，更应该明白剑锋所指何处，是对着身前的敌人，还是身后的弱者。&quot;故在生死间救下女俘虏，提着剑挡在她们面前。“……你若让那些女子也如我一般，见过凉州卫的雪，见过济阳城的水，见过大漠长月，见过江海山川，你说，她们还会不会甘心困在争风吃醋的宅院，还会不会沾沾自喜，麻木愚昧？……因为他们也知道，一旦女子们有了‘选择’的机会，是决计不肯成为后宅里一位伸手等着夫君喂养的花瓶的。那些优秀的女子，会成为将领，成为侠客，成为文士，成为幕僚，与他们争夺天下间的风采，而他们，未必能赢。” 如同背着大刀跨过洗墨江，劈开黑暗的周翡 我真的永远喜欢和敬佩这些女孩，也愿意相信贤昌馆少年郎们真的存在过。 2022_8_27 微博看到的句子 “为什么开学要庆祝” “庆祝有学上，有书读，有知识，有成长，有前途，有未来” 突然也就没有那么怕了 2022_8_29 救命好久好久好久没有这么撑过了 # 2022_11_12 第一学期结束啦 挂与不挂都是3月份担心的事啦","link":"/2022/02/01/%E7%BB%86%E7%A2%8E%E8%80%8C%E7%BE%8E%E5%A5%BD/"},{"title":"排序算法(一)","text":"排序算法 浅学排序[基于对大一数据结构的整理] 3种T(n)=O(n2)T(n) = O(n^2)T(n)=O(n2)的基本排序 选择排序 找最大/最小与头或尾交换 123456789101112131415161718192021222324void SelSort(int R[],int n){ for(i=0;i&lt;=n-2;i++) { m = i; for(j=i;j&lt;n;j++)//找最值 { if(R[j]&lt;R[m]) m = j; } if(m != i) swap(R[i],R[m]) }}//递归实现void SelSort(int R[],int n,int i){ if(i &gt; n-2) return ; m = i; for(j=i;j&lt;n;j++)//找最值 if(R[j]&lt;R[m]) m = j; if(m != i) swap(R[i],R[m]) SelSort(R,n,i+1)} 插入排序 1.教案版 算法描述： 排第i个时用j去找位置，找到位置后插入并使别的元素移动。每次循环完前i个数按升序排列 算法实现 12345678910111213void InsertSort(ElemTp R[],int n){ for(int i = 1 ; i &lt; n;i++) { j = 0; while(j&lt;i &amp;&amp; R[j].valeur &lt;= R[i].valeur) j++; //把R[i]插入到位置R[j]左边 //这里用的是vector的insert函数，有后移操作，复杂度为O(n) R.insert(R.begin()+j,R[i]); R.erase(R.begin()+i+1); }} 时间复杂度为O(n^2) 2.网上看到的 //从后往前，查找的时候就进行后移操作 12345678910111213void insertion_sort(int arr[],int len){ for(int i=1;i&lt;len;i++) { int key=arr[i]; int j=i-1; while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; }} 冒泡排序 每次循环进行两两比较和交换，第i次循环结束，第i大（小）的数排序完成。 算法实现 123456789101112131415161718192021void bubble_sort(int arr[], int len){ for(int i=0;i&lt;len;i++) { int flag=0； for(int j=0;j&lt;k;j++) { if(arr[j]&gt;arr[j+1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = 1； pos = j; } } k = pos; if(!flag) return; }} 时间复杂度为O(n^2) 冒泡排序的优化： 加入flag判断当前是否已经排序完成。 加入记录上次循环发生交换的最后位置pos,说明后(或者前)pos个是已经排好了，下次循环只需比到k即可 希尔排序 将待排序列分割成子序列[序号相同的是一个子序列]，对子序列进行插入排序，当增量为1时，排序完成。 例子： 一般来讲增量序列的size是3或者4//循环次数 代码实现： 1.赵宏宇版 1234567891011121314151617void shell_sort(vector&lt;int&gt; arr[],vector&lt;int&gt; d[])//d里面存增量序列{ for(int i=0;i&lt;d.size;i++) { for(int j=0;j&lt;d[i];j++) { //进行插入排序,从后边查边移,真难看，(bushi for(int k = j+d[i];k&lt;arr.size;k+=d[i]) { int temp = arr[k]; for(int t = k-d[i]; t&gt;=j &amp;&amp; arr[t]&gt;arr[j];t-=d[i]) arr[t+d[i]] = arr[t]; arr[t+d[i]]=temp; } } }} 2.网络版 排两次，增量序列为(4,1) 123456789101112131415161718192021222324252627template&lt;typename T&gt;void shell_sort(T array[], int length) { int h = 1; //[就是说，length为2和3是直接插入排就行了] while (h &lt; length / 3) { h = 3 * h + 1;//增量序列为(4,1) } //增量序列为1是排序完成 while (h &gt;= 1) { //插入排序，对array[0,h] for (int i = h; i &lt; length; i++) { for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) { swap(array[j], array[j - h]); } } //减小增量序列 h = h / 3; }} 时间复杂度分析 增量为2时，T(n)=O(n1.5)T(n) = O(n^{1.5})T(n)=O(n1.5) n在某个特定范围内，T(n)=O(n1.3)T(n) = O(n^{1.3})T(n)=O(n1.3) n趋于无穷时，T(n)=O(n(log2n)2)T(n) = O(n(log_2n)^2)T(n)=O(n(log2​n)2) 快排 找支点，比支点小的放左边，比支点大的放右边。对放左边，放右边的子序列执行同样的操作。直到不能拆分出子序列为止 比支点小的放左边，比支点大的放右边的实现：一个i从头到尾，一个j从尾到头，j遍历到小于支点的位置停下，然后i遍历到大于支点的位置停下，交换。然后重复先j然后i，直到i=j,将基准数与i交换 12345678910111213141516171819void quicksort(int left,int right){ int i,j,t,temp; if(left&gt;right) return; //排序完成 temp = a[left]//支点 i = left; j = right; while(i != j) { while(a[j] &gt;= temp &amp;&amp; i &lt; j) j-- while(a[i] &gt;= temp &amp;&amp; i &lt; j) i++ if(i&lt;j) swap(a[i],a[j]) } //支点归位 swap(a[left],a[i]) //递归 quicksort(left,i-1) quicksort(i+1,right)} 时间复杂度为O(nlogn)O(nlogn)O(nlogn) 堆排序 什么是堆 n个元素组成的序列{R0,R1,...,Rn−1}\\{R_0,R_1,...,R_{n-1}\\}{R0​,R1​,...,Rn−1​}时,但满足Ri.K&gt;=R2i+1.K and Ri.K&gt;=R2i+2R_i.K &gt;= R_{2i+1}.K \\ and\\ R_i.K &gt;= R_{2i+2}Ri​.K&gt;=R2i+1​.K and Ri​.K&gt;=R2i+2​时该序列就是堆[或者同时小于] 存储结构是一维数组，逻辑结构是完全二叉树[插入顺序必须为从上到下从左到右] 大根堆就是每个父节点都比子节点要大，小根堆同理 下标为i的节点的父节点：(i-1)/2,子节点2i+1和2i+2 堆性质的维护 12345678910111213141516void heapify(int arr[], int len, int i){ int largest = i; int lson = i * 2 + 1; int rson = i * 2 + 2; if (lson &lt; len &amp;&amp; arr[largest] &lt; arr[lson]) largest = lson; if (rson &lt; len &amp;&amp; arr[largest] &lt; arr[rson]) largest = rson; if (largest != i) { swap(&amp;arr[largest], &amp;arr[i]); heapify(arr, len, largest);//递归维护剩余位置，注意这里的largest是交换后的那个位置 }} 算法 基本思想：建堆。堆顶与最后一个元素交换，它就是最大了的，然后维护剩余元素的性质。然后循环。 1234567891011121314void heap_sort(int arr[], int len){ int i; // 建堆 for (i = len / 2 - 1; i &gt;= 0; i--) heapify(arr, len, i); // 排序 for (i = len - 1; i &gt; 0; i--) { swap(&amp;arr[i], &amp;arr[0]);//堆顶与最后一个元素交换 heapify(arr, i, 0);//维护剩余元素 }} 时间复杂度是O(nlogn)O(nlogn)O(nlogn) 归并排序 二分到子序列只有一个元素位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 合并void merge(int arr[], int tempArr[], int left, int mid, int right){ int l_pos = left; // 标记左半区第一个未排序的元素 int r_pos = mid + 1;// 标记右半区第一个未排序的元素 int pos = left;// 临时数组元素的下标 //合并 while (l_pos &lt;= mid &amp;&amp; r_pos &lt;= right) { if (arr[l_pos] &lt; arr[r_pos])// 左半区第一个剩余元素更小 tempArr[pos++] = arr[l_pos++]; else // 右半区第一个剩余元素更小 tempArr[pos++] = arr[r_pos++]; } // 合并左半区剩余的元素 while (l_pos &lt;= mid) tempArr[pos++] = arr[l_pos++]; // 合并右半区剩余的元素 while (r_pos &lt;= right) tempArr[pos++] = arr[r_pos++]; // 把临时数组中合并后的元素复制回原来的数组 while (left &lt;= right) { arr[left] = tempArr[left]; left++; }}// 归并排序void msort(int arr[], int tempArr[], int left, int right){ if (left &lt; right)//只有一个元素不需要划分 { //找中间点进行划分 int mid = (left + right) / 2; msort(arr, tempArr, left, mid); msort(arr, tempArr, mid + 1, right); //合并已经排序的部分 merge(arr, tempArr, left, mid, right); }}// 归并排序入口void merge_sort(int arr[], int n){ // 分配一个辅助数组 int tempArr[n]; // 调用实际的归并排序 msort(arr, tempArr, 0, n - 1);} 时间复杂度是O(nlogn)O(nlogn)O(nlogn) 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 把这个新的数组还原回去就可以了 1234567891011121314151617def countingSort(arr,maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) #计算频率 for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 #把它还原回去 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 适用于整数，但容易存在空间浪费 时间复杂度是: O(n+r)O(n+r)O(n+r) 基数排序 基本思想在于：将整数按位数切割成不同数字，然后按照每个位数进行比较 取得数组中的最大数，并取得位数； 对数位较短的数前面补零； 分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中; 收集，再将放置在0~9号桶中的数据按顺序放到数组中; 重复3~4过程，直到最高位，即可完成排序。 1234567891011def radix_sort(arr:List[int]): n = len(str(max(arr))) #记录最大值的位数 for k in range(n):#n轮排序 # 每一轮生成10个列表 bucket_list=[[] for i in range(10)]#因为每一位数字都是0~9，故建立10个桶 for i in arr: # 按第k位放入到桶中 bucket_list[i//(10**k)%10].append(i) # 按当前桶的顺序重排列表 arr=[j for i in bucket_list for j in i] return arr 时间复杂度是O((n+r)∗k)O((n+r)*k)O((n+r)∗k) [n是待排序列的长度，k是最大数字的位数，十进制的基数r为10] 基数排序的本质是依据LSD排序准则的排序[关键字组排序]，关键操作是分配和收集 分配：按最低位关键字[个位，秒]将其排序[相同的放在一个桶] 收集: 得到的新序列按最低位关键字排好序了，同组的先取第一个加进去的","link":"/2022/05/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/"},{"title":"戛纳动机信","text":"Cannes!!! 开头 Je suis une étudiante en double diplôme à l’Ecole Centrale de Nantes, en vue d’obtenir un diplôme d’ingénieur. Je suis très intéressé par le projet “Trois jours à Cannes” et j’aimerais partager avec vous ma principale motivation. 喜欢电影 J’ai 22 ans et je viens d’une petite ville de Chengdu, une province centrale de Chine. Influencé par mes parents, j’aime regarder des films depuis que je suis enfant. Je suis particulièrement reconnaissant aux films de m’avoir fait découvrir un monde après l’autre pendant mon enfance. Je me souviens du choc que j’ai ressenti en regardant Harry Potter pour la première fois quand j’étais enfant, et je n’ai pas pu me calmer longtemps après. Jouer au Quidditch avec Ron dans mes rêves, m’allonger sur le balcon en attendant ma lettre d’acceptation à Poudlard, lutter pour trouver le quai 9 et 3/4 en prenant le train. Je me souviens aussi d’avoir regardé Les Chroniques de Narnia et d’avoir joué à cache-cache avec mes amis pour ensuite me cacher dans l’armoire, désireuse de s’embarquer dans une aventure où il faut aussi faire preuve de courage. Il n’est pas exagéré de dire que les films ont construit mon enfance. 我今年22岁，来自中国中部省份成都的一个小镇。受父母影响，我从小便喜欢看电影。我特别感谢电影给我童年带我走进了一个又一个的世界。我记得我小时候第一次看哈利波特时的震撼，看完以后久久不能平静。在梦里和罗恩打魁地奇，趴在阳台等霍格沃兹的录取通知书，在乘坐火车时努力的寻找9又3/4站台。我也记得我看完纳尼亚传奇后，从此和朋友玩捉迷藏只躲在衣柜，渴望也能开启一段关于勇气的冒险。毫不夸张的讲，电影构建了我的童年。 Lorsque je suis entré dans l’enseignement secondaire, les films n’étaient jamais absents non plus. Je me souviens d’un cours de musique où le professeur de musique nous a montré un extrait de Les choristes, et depuis lors, les films français, ou plutôt la France, ont commencé à entrer dans mon univers. Après avoir regardé Le fabuleux destin d’Amélie Poulain, j’ai été captivé par la romance créée par le film et en même temps déterminé à faire l’expérience du pays et de la culture française par moi-même pendant mes années d’université. Mais je dois admettre que lorsque j’étais jeune, j’étais immature et j’avais une vision unilatérale du monde, mais ces films sur différents sujets m’ont énormément aidé à construire un système de pensée selon lequel le monde est divers, la beauté est diverse et la vie est diverse, et ces films ont façonné ma tolérance. 升入中学后，电影也从未缺席。还记得那时一节音乐课，音乐老师给我们放了放牛班的春天选段，自此法国电影或者说法国开始进入我的世界。在看完天使爱美丽后，我被电影创造出的浪漫所深深吸引，同时坚定了自己要在大学期间亲历这片土地和法国文化。但我不得不承认，年轻时我的思想并不成熟，看世界的角度也很片面，但这些不同题材的电影给我带来了巨大的帮助，让我建立了一个世界是多元的、美是多元的、生活是多元的思维体系，这些电影塑造了我的宽容。 Le célèbre réalisateur français, Abel Gance a dit : “Ce n’est pas l’image qui fait le film, c’est l’âme de l’image”. Je me rappelle encore comment je me suis sentie chez moi cet après-midi de 2020, lorsque j’ai fini de regarder Le grand bleu de Luc Paul Maurice Besson. La scène où Jean-marc regarde tendrement son amant puis se retourne et se jette dans les bras de la mer est gravée dans mon esprit. Peut-être que les gens viennent au monde avec un but, la vie n’est 1/2 qu’un processus, et suivre son cœur au maximum est aussi une façon de vivre. Jean-marc est né seul et ne pouvait pas combler sa solitude dans la foule, préférant se plonger dans l’obscurité de la mer pour profiter d’un moment de paix. 法国著名导演阿贝尔-甘斯说：“拍摄电影的不是影像，而是影像的灵魂”。我仍然记得2020年的那个下午，当我看完吕克-保罗-莫里斯-贝松的《Le grand bleu》时，我在家里的感觉。让-马克温柔地看着他的爱人，然后转身投入大海的怀抱，这一幕深深地刻在我的脑海里。也许人们来到这个世界上是有目的的，生活是1/2个过程，充分跟随自己的心也是一种生活方式。让-马克生来孤独，在人群中无法填补他的孤独，他宁愿将自己沉浸在黑暗的大海中，享受片刻的宁静。 想来戛纳 J’ai travaillé dur et j’ai pu poursuivre mes études en France comme je le souhaitais, les mots ne peuvent décrire mon excitation lorsque j’ai appris que j’aurais peut-être l’occasion d’aller au Festival du film de Cannes et de voir les meilleurs films du monde entier dans cette belle ville du sud, par une belle journée de mai. Le Festival de Cannes est pour moi un sanctuaire pour le pèlerinage des fidèles, un trésor si beau et si désirable pour les gourmands qui le cherchent tant. Mais aussi comme un bon ami, si familier, qui m’a rencontré dans mes rêves à travers d’innombrables films. C’est peut-être notre seule chance de nous rencontrer dans cette vie. Je pense que je n’oublierai jamais cette rencontre avec le Festival de Cannes et que ce sera l’une des expériences les plus importantes de ma vie. C’est pourquoi je demande au comité de me donner la possibilité de réaliser mon rêve de raconter mon histoire d’été à Cannes. Je vous en serais très reconnaissant. 现在我通过努力，如愿在法国开启我的学习生活，当我得知我可能有机会去参加戛纳电影节，在这个美丽的南方城市看到来自世界各地的最佳影片时，我的兴奋之情难以言表。戛纳电影节对我来说是一个供信徒朝圣的圣地，是一个如此美丽、如此令人向往的宝藏，让那些追求它的饕餮之徒欲罢不能。但也像一个好朋友，如此熟悉，通过无数的电影在梦中与我相遇。这可能是我们今生唯一的见面机会。我想我永远不会忘记这次与戛纳电影节的会面，这将是我人生中最重要的经历之一。这就是为什么我请求委员会给我机会实现我的梦想，在戛纳讲述我的夏季故事。我将非常感激。 结尾 Veuillez agréer, Mesdames, Messieurs, l’expression de ma considération distinguée. Li NI","link":"/2022/05/20/%E6%88%9B%E7%BA%B3%E5%8A%A8%E6%9C%BA%E4%BF%A1-1/"},{"title":"PAPY_CM2","text":"PAPY_CM2 是老师的ipynb文件啦 Structuration et types de données Contenu Variables, références et gestion de la mémoire Programmation fonctionnelle Programmation orientée objet (OOP) : les classes Conseils généraux pour la programmation Rappel : les types de base en python int (entier) float (flottant) str (chaîne de caractères) bool (booléen) list (liste) tuple (tuple) complex (complexe) Variables, références et gestion de la mémoire Variables et affectation En python tout est objet ⟹\\Longrightarrow⟹ la variable v peut changer de type. Definition: Une variable est un identificateur associé à une valeur. En Python, c’est une référence d’objet. 123456v=1print(f&quot;{v=},{type(v)}&quot;)v=&quot;bonjour&quot;print(f&quot;{v=},{type(v)}&quot;)def v(param) : return Noneprint(f&quot;{v=},\\t{v(1)=},\\t{type(v)}&quot;) Sytème d’affectation des variables immutables[可变的和不可变的 不可更改的变量的分配系统] 12345678a=1b=2c=3print(f&quot;{a=}, {b=}, {c=}&quot;)c=bprint(f&quot;{a=}, {b=}, {c=}&quot;)a='z'print(f&quot;{a=}, {b=}, {c=}&quot;) Mutables et non-mutables Les variables simples vue jusqu’ici sont dites non-mutable i.e. on ne modifie jamais le contenu d’une case mémoire on affecte la variable à une nouvelle case Il existe des objets dits mutables, dont le contenu est directement modifié. Par exemple les listes ma_liste=[1,&quot;chaine&quot;] Les listes, mutable par excellence 123L=[1,2,3]L2=L #on crée une nouvelle référenceprint(L==L2)--&gt;True ⚠️ Toute modification par l’un des “pointeurs” entraine une modification de la liste pointée. 任何一个 &quot;指针 &quot;的修改都会导致对被指向的列表的修改。 123L2[2]=10print(L==L2, id(L)==id(L2))#True Trueprint(L) 12L2=4 #on change l'affectation de la variableprint(L==L2)#Flase 123456#Si on veut créer une copie de la liste et pas un pointeur#Copie simpleLcopie=L[:]print(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L))#Flase 123456# Par le module copie import copyLcopie=copy.copy(L) #shallowprint(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L)) Les dictionnaires : “listes” clé/valeur 12valeur=10dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]} 1dictionnaire[&quot;clé&quot;] 1234dic2=copy.copy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire) ⚠️ La “shallow” copy n’a créé de copie que pour le niveau supérieur. Pour tout copier, on utilise copy.deepcopy() 深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同。 12345678dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]}dic2=copy.deepcopy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire)#on utilise l'opérateur ** pour &quot;unpack&quot; un dictionnaire, très utile pour en concaténer deux#**操作符用于解压一个字典，这对于连接两个字典非常有用new_dic={**dictionnaire,**{&quot;var&quot;:1.2}} Le tuple, une liste non-mutable 1234# exemple de tuplevecteur=(1,0,0)print(f&quot;{vecteur=}, {type(vecteur)=}&quot;)vecteur[1]=2#会报错，因为不能被修改 L’opération précédente est illégale puisque le tuple n’est pas modifiable après sa création. Il faut réallouer la variable par un nouveau tuple contenant la valeur souhaitée. 123vecteur=(vecteur[0],vecteur[1],2)#que l'on peut remplacer par l'opération suivantevecteur=(*vecteur[:1],2) Quelques autres types qui peuvent etre utile set est une collection itérable non ordonnée d’éléments hachables uniques 集合，无序 module collections collections是Python内建的一个集合模块，提供了许多有用的集合类和方法。可以把它理解为一个容器，里面提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。 defaultdic du propose des dictionnaires avec valeur par défaut：当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值，可以是list、set、str等，用法 12from collections import defaultdictdict1 = defaultdict(int) counter bien pratique pour des dictionnaires de dénombrement: 作用是计算出字符串或者列表等中不同元素出现的个数，返回值可以理解为一个字典 deque pour des listes à accés rapide des extrémités (file,tas ):可以实现双端队列 module heapq pour des opérations efficaces sur les tas：实现堆栈 Plus d’infos dans Programmation Python Avancée, X. Olive Gestion de la mémoire Contrairement aux langages plus bas niveau, python gère “automatiquement” la mémoire. Il l’alloue et la libère tout seul. 自动管理内存：自己分配和释放内存 Garbage collector si une donnée en mémoire n’est plus référencée, le garbage collector gc de Python la supprime automatiquement (car son nombre de références tombe à zéro) 12345import sysdonnee=[1,2,3]print(sys.getrefcount(donnee)) # le texte lui meme plus le passage à getrefcountmaliste=donneeprint(sys.getrefcount(donnee)) la fonction del permet de supprimer une référence, pas son contenu. 1del(donnee) Le contenu est nettoyé par le garbage collector automatiquement. On peut néanmoins accéder au gc ainsi 123import gcgc.collect() # fait le ménagegc.get_threshold() # un second mécanisme &quot;générationel&quot; traite les récursions, avec les propriétés suivantes Evaluation de l’usage mémoire Pour des programmes complexes ou traitant de grandes données, on peut suivre l’usage mémoire par profiler Il existe une multitude de solution, la plupart vont aller chercher activement l’usage mémoire à interval regulier (ou lors des allocations) pour obtenir une bonne estimation de l’usage mémoire. Ici, on peut installer l’outil memory_profiler qui s’intègre facilement à jupyter. 1234!mamba install -c conda-forge memory_profiler -y%load_ext memory_profiler# que l'on appelle ensuite ainsi%memit [i for i in range(100000)] Il existe une version ligne par ligne %mprun qui ne fonctionne que pour les fonctions définies dans des fichiers externe. (cf TP) Programmation fonctionelle Fonctions On défini une fonction de la façon suivante: 12345def fonc(x, y=0, *args, **kwargs): &quot;&quot;&quot;Un docstring est fortement recommandé ---docstring?&quot;&quot;&quot; x*y return # même si on ne renvoie rien! Que l’on appèlerai ainsi: 1234567fonc(10,20)#oufonc(10,y=20)#ou, avec les arguments surnuméraires en supposant args et kwargs bien définisargs=[]kwargs={}fonc(10,args, kwargs) Les arguments d'une fonction peuvent etres passés nommés ou non. S'ils ne le sont pas l'ordre est important. Détails sur le passage des arguments 1234def fonc(x, y=0, *args, **kwargs): #actions return &gt;&gt;&gt; fonc(10,args, kwargs) Le passage se fait par assignation et pas par références en soi. C'est à dire, qu'un nouvel alias est créé, pointant vers la case mémoire concernée. Deux cas de figure suivant que l'objet est: immutable : toute modification dans le corps de la fonction entraine une nouvelle assignation/allocation. mutable : toute modification dans le corps de la fonction entraine une modification de l'objet pointé. Donc de l'objet dans l'espace global. ??????? ⚠️ Ne pas utiliser des mutables en valeur par défaut. Leur durée de vie dépasse l’appel de la fonction! 1234567def ajout_liste(L=[],elem=&quot;elem&quot;): #une liste inutile qui ajoute un élément à une liste L.append(elem) print(L)ajout_liste(elem=1)ajout_liste(elem=2) #quel résultat est attendu? Les fonctions sont des objets/variables comme les autres! Mais on peut les appeler (callable). ➡️ On peut passer une fonction comme argument 函数和其他的对象/变量一样！但它们可以被调用（可调用）。➡️ 可以将一个函数作为参数传入 12def fonc2(fonc): return 2*(fonc(100)) On dispose même des fonctions anonymes lambda function qui sont définies à la volée, tant qu’elles sont mono-instruction. 1fonc2(lambda x: x+1) En pratique on les utilisera seulement si l’instruction est très simple et facile à comprendre. Sinon on déclare une nouvelle fonction! 在实践中，只有在指令非常简单和容易理解的情况下才应使用它们。否则，将声明一个新的函数. Type hinting python&gt;=3.5 12def hello_name(name: str) -&gt; str: return(f&quot;Hello {name}&quot;) Portée[范围] des variables Variables locales, variables globales Les variables définies (ou passées) à la fonctions sont locales i.e. accessibles uniquement depuis la fonction et détruites ensuite. Les variables définies à l’extérieur d’une fonction sont des variables globales. Leur contenu est « visible » de l’intérieur d’une fonction, mais la fonction ne peut pas le modifier. 在一个函数之外定义的变量是全局变量。它们的内容在一个函数中是 “可见的”，但函数不能改变它们。 12345x = &quot;global&quot;def foo(): x = x * 2 #会报错，改成1也不行 print(x)foo() On peut aussi utiliser (rarement) le mot clé global pour s’assurer que l’on modifie une variable globale du programme. 123456789x = &quot;global &quot;def foo(): global x # Essayer avec et sans! y = &quot;local&quot; x = x * 2#字符串也有乘法的 print(x) print(y)foo() Le cas nonlocal pour les fonctions imbriqués 123456789def outer(): x = &quot;local&quot; def inner(): nonlocal x x = &quot;nonlocal&quot; print(&quot;inner:&quot;, x) inner() print(&quot;outer:&quot;, x)outer() Paradigme[范式] : La programmation fonctionnelle Un petit peu de théorie de la programmation La programmation impérative 命令式编程 est le paradigme le plus répendu. On découpe le programme en une séquence d'instructions à exécuter. C'est une description de l'algo à exécuter pour résoudre le problème. 🚀 Offre un bon controle de la performmance. La programmation déclarative声明式编程 considère le programme par une description du problème. Le moteur du language met en oeuve l'algo permettant la résolution. C'est un paradigme de programmation sans effet de bord c.à.d. sans état interne permanent. Exemple : Latex, CSS. ✔️ Formel donc permet de prouver que les résultats sont corrects. La programmation fonctionnelle est une variante de programmation déclarative. La programmation est vue comme l'évaluation de fonctions mathématiques sans effet de bord. ☞ Langages fonctionnels : Haskell, Scala, OCaml Par exemple: 12L=[1,3,7,10,-1]L.sort(),L 12L=[1,3,7,10,-1]sorted(L),L La méthode .sort est impérative[命令]. Elle modifie l’input avec une série d’instructions. La fonction sorted suit un modèle fonctionnel, sans effet de bord. Deux appels successifs ne changent pas le résultat. Un programme utile aura toujours des effets de bords, il interragit avec le monde extérieur. Python n’est pas un langage fonctionnel. Cependant, les recommandations de la programmation fonctionnelle: limiter les effets de bord et états internes limiter les mutables programmation qui caractérise la solution plutot que la procédure permettent un style modulaire et donc compsable. En pratique cela facilite aussi le teste et les débugs et certaines accélérations (jit, parallèlisme, GPU). Les bibliothèques pandas et altair ont une approche très fonctionnelle. numpy beaucoup moins comme on le verra. Fonctions pures et d’ordre supérieur Une fonction pure est une fonction dont le résultat dépend uniquement de ses arguments, donc sans effets de bord. En programmation foncitonnelle on utilise que des fonctions pures Une fonction d'ordre supérieur est une fonction qui prend en argument une fonction ou renvoie une fonction. Exercice: Ecrire une fonction pure fibonacci(et récursive) qui calcule le n-ème terme de la suite de Fibonacci. Rappel $f_0=1,f_1=1$ et $\\forall n >1, \\quad f_n=f_{n-1}+f_{n-2}$. 1234def fibonacci(n:int)-&gt;int: if n in [0,1]: return 1 return(fibonacci(n-1)+fibonacci(n-2)) Exercice: Ecrire une fonction d'ordre supérieur n_premiers qui renvoie une fonction qui calcule les n permiers termes de la suite de Fibonacci. 1234from typing import Listdef n_premiers(func: &quot;int -&gt; int&quot;, n: int) -&gt; List[int]:#注意这里参数的是函数 return [func(i) for i in range(n)]print(n_premiers(fibonacci,10)) Exercice: Ecrire une fonction d'ordre supérieur premiers qui renvoie une fonction qui calcule les n permiers termes d'une suite et l'appliquer Fibonacci. 12345#关于这里声明的理解，输出是函数，然后输出的函数式int做输入，list做输出def premiers(func: &quot;int -&gt; int&quot;) -&gt; &quot;int -&gt; List[int]&quot;: def n_premiers_func(n: int) -&gt; List[int]: return n_premiers(func,n) return n_premiers_func 12n_premiers_fibonacci=premiers(fibonacci)n_premiers_fibonacci(10) Deux mots sur les décorateurs Un décorateur de fonction (d’ordre supérieur) est un outil qui permet de marquer une fonction afin d’en modifier le comportement. Il est marqué par le @décorateur avant une fonction. 12345678910111213141516171819from time import timedef timer(func:&quot;fonction&quot;)-&gt;&quot;fonction&quot;: name=func.__name__ def timed_func(*args): t1=time() arg_str=', '.join(repr(arg) for arg in args) resultat=func(*args) elapsed=time()-t1 print(f&quot;{name}({arg_str}) elapsed time [{elapsed:0.8f}s]&quot;) return resultat return timed_func@timerdef factorielle(n: int)-&gt;int: res=1 for i in range(1,n): res*=i return resprint(factorielle(20)) Attention aux fonctions réccursives, l’appel sera affiché à chaque fois! 123456@timerdef factorielle_rec(n: int)-&gt;int: if n in [0,1]: return 1 return n*factorielle_rec(n-1)print(factorielle_rec(20)) Itérateurs et générateurs En programmation fonctionelle, la récursion joue souvent le role d’itérateur à la place des boucles for. Si on voit l’itération comme une structure générique qui fourni un service, alors les structures itérables fournissent des élément un à un sans avoir à les charger intégralement en mémoire. On peut: les parcourir avec un for construire des structures en les consommant les manipuler par compréhension les déballer 12type(range(10))#rangelist(range(10)) Retour sur l’écriture en compréhension On peut utiliser les listes en compréhension pour créer des nouvelles structures et améliorer (un peu) la performance. 1234567%%timeit L=[2*x**3 for x in range(1000000)]#等价于%%timeit #可以用于计时L=[]for x in range(1000000): L.append(2*x**3) Créer ses propres itérateurs avec le mot clé yield Une fonction qui contient le mot-clé yield renvoie un générateur. Lorsqu’une fonction rencontre yield: elle renvoie la valeur courante attend la prochaine itération dans la boucle reprend le programme la ou il s’était arrété La suite de Syracuse est définie ainsi: Pour tout entier nnn, l’entier suivant est défini par new n={n2si n est pair3n+1if n sinon. \\mathrm{new} \\; n = \\begin{cases} \\frac{n}{2} &amp;\\text{si } n \\; \\text{est pair} \\\\[4px] 3n+1 &amp; \\text{if } n \\text{ sinon}.\\end{cases}newn={2n​3n+1​si nest pairif n sinon.​ Exercice: Ecrire un générateur de al suite de Syracuse grâce au mot-clé yield. Y ajouter une fonction qui calcule la longueur jusqu'à atteindre 1 length et celle qui donne la hauteur max max 123456&gt;&gt;&gt; def syracuse(n: int)-&gt;&quot;generator&quot;:&gt;&gt;&gt; ...&gt;&gt;&gt; yield n&gt;&gt;&gt;&gt;&gt;&gt; list(syracuse(10))[10, 5, 16, 8, 4, 2, 1] 123456789101112131415def syracuse(n: int)-&gt;&quot;generator&quot;: yield n #première itération, renvoie simplement l'input (pas de récursion ici) while n!=1: # le programme s'interrompt lorsque n=1, comme prévu if n%2==0: n=n//2 else: n=3*n+1 yield n # renvoie la nouvelle valeur de n à chaque passagelist(syracuse(10)) #[10,5,16,8,4,2,1]def length(iterable): return sum(1 for _ in iterable)length(syracuse(27))#122# trick&quot;-&gt;&quot;.join(str(i) for i in syracuse(27)) Pour aller plus loin : le module itertools permet des manipulations poussées des itérateurs la fonction next renvoie la première valeur du générateur les coroutines consomment des éléments à chaque appel Des “built-ins” et functool map map(func, sequence) applique une fonction à tous les éléments d’une séquence avec évaluation paresseuse (lazy). 12map(fibonacci,[1,10,20])list(map(fibonacci,[1,10,20])) filter filter(func,x) fonctionne de la même façon et renvoie les éléments de x pour lesquels func renvoie vrai. 123def paire(n:int)-&gt;bool: return(n%2==0)list(filter(paire,[1,10,11])) reduce reduce(func,x) applique de façon cummulative [累积] la fonction func aux éléments de x. 12345from functools import reducefrom operator import addreduce(add,[1,10,100])#sum fait le meme travail...sum([1,10,100]) Dans le meme esprit on a : any et all pour les opérations booléennes Programmation orientée objet Python est un langage fondamentalement orienté objet (OOP), les classes, instances et méthodes étant omniprésentes. A reprendre au tableau Quelques notions à avoir en tete avant de commencer : encapsulation: l’objet embarque toutes ses propriétés (varibales, méthodes) dans un espace de nommage 封装 interface: on part du service rendu qui est présenté à l’utilisateur pour concevoir la machinerie interne 接口 factorisation [结构化]: on mutualisera au maximum les portions de code similaires grace aux concepts d’héritage[继承] et de composition[组合] Les classes On va suivre l’excellente présentation du livre de Xavier Olive, “Programmation python avancée” qui utilise les “Boids” Un Boid (bird-oid) est une représentation simplifiée proposée par Craig Reynolds pour modéliser le comportement d’oiseaux avec les regles suivantes : de séparation pour préserver une distance minimum entre les individus de cohésion pour que les boids volent en groupe d’alignement pour qu’ils volent dans la meme direction [博伊德（鸟类）是克雷格-雷诺兹提出的一种简化表示法，用于模拟鸟类的行为，其规则如下。 隔离*以保持个人之间的最小距离 凝聚力*，从而使boids成群结队地飞行 对齐*，使它们飞向同一方向] Création d’une classe 123import numpy as npclass Boid: pass 12b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1 Attention: Il n'y a pas de notion d'attributs publics et privés en python[没有私有或者公有的概念] ! On utilisera des attribus pseudo privés notés par _x Une méthode est une “fonction” définie dans le corps de la classe et qui vie dans son espace de nommage. 1234567class Boid: def module_vitesse(self): return np.sqrt(self.v_x**2+self.v_y**2) b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1b.module_vitesse() La méthode réservée __init__ est le constructeur de la classe. Il est appelé chaque fois que cette classe est instanciée. 123456789101112class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y 123b=Boid((0,0),(1,2))b.avance()b __repr__(self) -&gt; str définie une représentation de l’objet qui est renvoyée par l’interpréteur __str__(self) -&gt; str est l’affichage renvoyé par print(). Renvoie __repr__ si non défini 1234567891011121314class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y def __repr__(self)-&gt;str: return f&quot;Boid({self.x,self.y}, {self.v_x,self.v_y})&quot; 123b=Boid((0,0),(1,2))b.avance()b On peut choisir de programmer des méthodes qui modifient ou non l'état interne. De même, on peut choisir des méthodes qui renvoient ou non un résultat. Arguments par défaut. On veut pouvoir initialiser automatiquement nos instances (avec un peu de hasard). C’est l’idée programmatique de factory. Une variable de classe est une variable qui est liée à la classe et non à l’instance. 1234567891011121314151617181920212223242526class Boid: taille = 300 # dimension du domaine des positions count = 0 def __init__(self, position=None, vitesse=None) -&gt; None: self.x = ( position if position is not None else np.random.uniform(-Boid.taille, Boid.taille, 2) ) self.dx = vitesse if vitesse is not None else np.random.uniform(-5, 5, 2) Boid.count +=1 def __repr__(self) -&gt; str: return f&quot;Boid({self.x.round(2)}, {self.dx.round(2)}, parmi {Boid.count})&quot; def vitesse(self)-&gt; float: return np.linalg.norm(self.dx) def avance(self) -&gt; &quot;Boid&quot;: return Boid(self.x+self.dx, self.dx) def __del__(self): #on implémente un destructeur pour s'assurer que count est mis à jours correctement Boid.count-=1 print('__del__ was called') 123b=Boid()c=b.avance()b, c 123b=0del(b)c=None 1Boid.count ☣️ Nous n'avons pas de contrôle direct sur le garbage collector. Le comportement est plus reproductible sur un appel python type python file.py Décorer ses objets A défaut d’attributs privés, on peut imposer certains comportements: @property définit un raccourcis qui s’utilise comme une variable. (utile de l’ustiliser avec _var_name pour “protéger” une variable. @var_name.setter pour pouvoir modifier la valeur de la variable On défini une propriété vitesse de la façon suivante 1234567@propertydef vitesse(self) -&gt; float: return np.linalg.norm(self.dx)@vitesse.setterdef vitesse(self, value: float) -&gt; None: self.dx = self.dx * value / self.vitesse De même il est parfois utile de définir une nouvelle façon d’initialiser une instance de notre classe. Le décorateur @classmethod le permet: 123@classmethoddef polaire(cls, r, theta, v, direction): return cls(r*np.array([np.cos(theta),np.sin(theta)]),v*np.array([np.cos(direction),np.sin(direction)])) Enfin, on peut souhaiter encapsuler une “fonction” dans une classe par exemple pour controler sa visibilité. On utilisera le décorateur @staticmethod lors de la déclaration de la fonction. 123@staticmethoddef scene(n:int) -&gt; &quot;list[Boid]&quot;: return [Boid() for _ in range(n)] Exercice : Make'em fly Avec le squellette de classe fourni dans boid_partial.py, faire voler la nuée. Appel pour exécuter le script et tracer la figure. La classe animation est déjà écrite. 1234567891011fig, ax = plt.subplots(figsize=(7, 7))simulation = Simulation(n=100, ax=ax)anim = animation.FuncAnimation( fig, simulation.iteration, frames=range(0, 200), interval=150, blit=True, repeat=True,)anim.save(&quot;boids.mp4&quot;) On pourra aussi jouer avec les variables de classes qui modifient le rapport de force entre les composantes qui dirigent le vol. 1234sep_coef=10align_coef=8cohere_coef= 100centripete_coef= 200 Héritage et composition Une classe fille peut hériter des propriétés (et méthodes) d’une classe mère. Ceci permet de factoriser efficacement le code. Attention, dans bien des cas, une relation de composition est plus judicieuse. Dans ce cas, un des attribus de la classe est un objet d’une autre classe. 123456789101112131415161718192021222324# exemple d'héritage: class Personne: def __init__(self, nom, prenom, age): self.nom=nom self.prenom=prenom self.age=age def __repr__(self): return f&quot;{self.nom} {self.prenom} ({self.age}ans)&quot; def gen_ID(self): return (self.nom+self.prenom[0]).lower() def anniversaire(self): self.age+=1 print(&quot;Joyeux anniversaire&quot;) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; 123eleve=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)print(eleve.anniversaire())print(super(eleve).name) 123456789101112131415161718192021#Exemple de compositionclass Bulletin: def __init__(self, date, notes :&quot;ndarray&quot;): self.date=date self.notes=notes def moyenne(self): return np.average(notes) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() self.bulletins=[] def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; def meilleure_note(self): return np.array([B.notes for B in self.bulletins]).max() 1234jean=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,2,1])))jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,20,1])))jean.meilleure_note() Quelques conseils de structuration Bien comprendre le problème et le cahier des charges analyser le problème quels sont les objectifs quel structure générale est nécessaire exécutable script API quelles sont les classes/variables de haut niveau choisir le bon environnement de travail Ebauche écrire un petit code test n’est pas interdit créer les grandes structures et fonctions en premier, quitte à les laisser vide mais commentées &quot;simple is beautiful&quot; -&gt; zen of python Dev / Test si possible écrire les tests / appels API en premier -&gt; contraint le dev dans la bonne direction test driven programming? s’assurer du bon fonctionnement des briques élémentaires au fur et à mesure Rappel : développer c'est environs 90% de débuggage => Il faut absolument écrire du code lisible!! Vers un code en production : Optimisation et parallèlisme Optimisation ne pas chercher à optimiser dès le départ mais avoir en tête un ensemble de pratiques favorables utiliser des outils de profiling Améliorer son code python / algo Utiliser (mieux) des libraries Chercher des améliorations techniques (JIT, langages compilés) Parallèlisation python n’est pas très propice au // un bon code séquentiel est un prérequis absolu dans quelques cas, on pourra avoir un gain de performance pour les tableaux : calcul GPU","link":"/2022/09/16/PAPY_CM2/"},{"title":"遗传算法","text":"遗传算法 帮ZZ做SRTP学的一些东西 1.简介 一些生物学常识 基因型、表现型 进化：群体，个体，适应度(Fitness) 优化问题–&gt;优化问题模型 f(X)目标函数+约束条件 求最优化问题的方法：枚举，启发式算法（？），搜索 遗传算法中的基本过程 选择：按照个体适应度，按照一定的规则，从t代群体P（t）中选择优良个体遗传到P（t+1） 交叉 ：将P（t）内的各个个体随机搭配成对，以每一对个体，以某个概率交换 变异：对群体P（t）中的每一个个体，以某一概率改变某一个或者某一些值 流程 群体：可行解编码成基因的个体的一个集合 模拟遗传算法的简单实例 个体编码 初始群体的产生 选取起始搜索点的初始群体数据，需要选取群体规模，这里选4。个体则随机产生 适应度计算 这里直接以目标函数为适应度 第6列表示适应度概率，7进行选择，注意选择完成时，群体规模是保持不变的 ​ 9,10,11进行交叉的过程：配对的第2位进行交叉（等位基因） ​ 12,13进行变异 ​ 13产生子代群体，完成一次迭代。 最优解可由迭代次数决定 2.基本的遗传算法 遗传算法解决TSP问题 问题抽象 1.如何将答案编码成基因 旅行路线–&gt;一个数组 2.如何定义个体适应度 路程（目标函数）","link":"/2022/07/29/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"循环不变量","slug":"循环不变量","link":"/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"},{"name":"图灵机","slug":"图灵机","link":"/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"},{"name":"SAT","slug":"SAT","link":"/tags/SAT/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动规","slug":"动规","link":"/tags/%E5%8A%A8%E8%A7%84/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"全排列","slug":"全排列","link":"/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"AVL","slug":"AVL","link":"/tags/AVL/"},{"name":"指针与引用","slug":"指针与引用","link":"/tags/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"},{"name":"实验汇总","slug":"实验汇总","link":"/tags/%E5%AE%9E%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"name":"BBC_6mintues","slug":"BBC-6mintues","link":"/tags/BBC-6mintues/"},{"name":"DNN","slug":"DNN","link":"/tags/DNN/"},{"name":"haskell","slug":"haskell","link":"/tags/haskell/"},{"name":"SOFTSKILLS","slug":"SOFTSKILLS","link":"/tags/SOFTSKILLS/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"模型融合","slug":"模型融合","link":"/tags/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"},{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"monade","slug":"monade","link":"/tags/monade/"},{"name":"SysML","slug":"SysML","link":"/tags/SysML/"},{"name":"Paris","slug":"Paris","link":"/tags/Paris/"},{"name":"Suisse","slug":"Suisse","link":"/tags/Suisse/"},{"name":"算法基础","slug":"算法基础","link":"/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"生活区","slug":"生活区","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/"},{"name":"NANTE_EI2|1","slug":"NANTE-EI2-1","link":"/categories/NANTE-EI2-1/"},{"name":"学习区","slug":"学习区","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/"},{"name":"杂谈","slug":"生活区/杂谈","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/%E6%9D%82%E8%B0%88/"},{"name":"NANTE_第一年","slug":"NANTE-第一年","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/"},{"name":"ALGOA","slug":"NANTE-EI2-1/ALGOA","link":"/categories/NANTE-EI2-1/ALGOA/"},{"name":"SWJTU","slug":"SWJTU","link":"/categories/SWJTU/"},{"name":"暑假的乱七八糟","slug":"学习区/暑假的乱七八糟","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/%E6%9A%91%E5%81%87%E7%9A%84%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"},{"name":"ALGORITHM","slug":"NANTE-第一年/ALGORITHM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ALGORITHM/"},{"name":"ALGORITHM","slug":"SWJTU/ALGORITHM","link":"/categories/SWJTU/ALGORITHM/"},{"name":"CCUBE","slug":"NANTE-第一年/CCUBE","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/CCUBE/"},{"name":"ANG","slug":"NANTE-第一年/ANG","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ANG/"},{"name":"INDUR","slug":"NANTE-EI2-1/INDUR","link":"/categories/NANTE-EI2-1/INDUR/"},{"name":"IAM11","slug":"NANTE-EI2-1/IAM11","link":"/categories/NANTE-EI2-1/IAM11/"},{"name":"MATHS","slug":"NANTE-第一年/MATHS","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/MATHS/"},{"name":"PYTHON","slug":"NANTE-EI2-1/PYTHON","link":"/categories/NANTE-EI2-1/PYTHON/"},{"name":"PFONC","slug":"NANTE-EI2-1/PFONC","link":"/categories/NANTE-EI2-1/PFONC/"},{"name":"PRO20","slug":"NANTE-第一年/PRO20","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/PRO20/"},{"name":"SSTEM","slug":"NANTE-第一年/SSTEM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/SSTEM/"},{"name":"Voyage","slug":"生活区/Voyage","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/Voyage/"}],"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"一个平平无奇的美女罢了","link":"/about/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"}]}