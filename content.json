{"posts":[{"title":"ALGOA_CM1&amp;2","text":"ALGOA_CM1&amp;2 Algorithmique avancée_CM1&amp;2 Introduction Pourquoi étudier l’algorithmique ? Résoudre plus facilement les problèmes (Problem solving) ; Ne pas réinventer[再次创作] la roue ; Produire des programmes : corrects, efficaces, et lisibles（可读性）. Pourquoi faire des programmes efficaces ? Pour optimiser l’utilisation des ressources : temps de calcul, mémoire, énergie. 下面是一个提高算法效率的例子（斐波那契） 123456789101112def fib1 (n): if n == 0 or n == 1: return 1 else : return fib1 (n=1) + fib1(n=2)def fib2 (n): x = 1 y = 1 for i = 2 to n: y = x + y#后两个数相加得第三个数 x = y - x#舍弃第一个数 return y Objectifs du cours • Prouver la correction de programmes ; • Analyser leur performance ; • Connaître et savoir utiliser les principales stratégies génériques de résolution de problèmes (algorithmiques) ; • Connaître et savoir utiliser les principaux types abstraits（抽象的） ; • Comprendre le fonctionnement de leurs principales implémentations（实施方法） et leurs limites. Analyse d’algorithmes Prouver des propriétés Propriétés des algorithmes (et programmes)： Propriétés non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] Performances Prouver des propriétés： exhaustif:全面，formelles:正式的 Invariants de boucles：循环不变量 Pour prouver ce type de propriétés[什么属性？] : ​ • Invariants de boucles : ​ • Propriétés inductives[归纳的，电感的，感应的] ; ​ • À prouver par induction[归纳] sur les itérations. ​ • Contrats de type assume-guarantee : ​ • Sous réserve de la précondition[前提条件] X, la postcondition[后置条件] Y est vraie ​ • Version informelle des triplets de Hoare dans la logique du même nom. 源于网上的一些解释 在计算机科学中，循环不变量，是一组在循环体内、每次迭代均保持为真的某种性质，通常被用来证明程序或算法的正确性。 我们使用循环不变量帮助我们理解一个算法为什么是对的。对于一个给定的循环不变量，我们必须遵循以下三个属性： 初始化：在循环的第一次迭代之前，循环不变量为真。 保持：如果在循环的一次迭代之前循环不变量为真，那么在下一次迭代之前循环不变量同样为真。 终止：当循环结束时，不变量能够提供我们有用的属性，用于帮助我们证实算法是正确的。 当保证前两个属性时，循环不变量在循环的任意迭代之前都满足。注意它与数学归纳法的相似性，当你想证明一个属性存在时，你需要证明一个基准和一个归纳步。相应的，我们第一次迭代之前保证不变量成立对应于一个基准，我们在每次迭代之间保证不变量成立对应于一个归纳步。 因为我们用循环不变量证明算法正确性，所以第三个属性或许是最重要的。通常，我们必须保证在循环结束时“循环不变量”和“循环终止条件”同时成立。 这与数学归纳法有所不同。数学归纳法常采用无限的归纳步，而循环不变量的归纳往往随着循环的终止而结束。 EXEMPLE 对于插入算法的12到14行，有如下分析 après la nen^ene itération, on a 0 ≤ j &lt; x vrai pour n = 0, par la ligne 11 et l’hypothèse x ≥ 1 si vrai pour n ≥ 0, alors : • soit j = 0 (ou A[x] ≤ A[j]), la boucle s’arrête et pas d’itération n + 1 ; • soit j &gt; 0 (et A[j] &lt; A[x]) et après la ligne 14, au début de l’itération n + 1, on a bien 0 ≤ j &lt; x. EXERCICE 1.插入排序 123456789101112def sort (A, n): for i = 1 to n = 1: insert(i , A) def insert (x , A): key = A[x] j = x - 1#j从后往前遍历 while j &gt; 0 and A[j] &gt; key:#比key大的都往后移 A[j + 1] = A[j] j = j - 1 A[j] = key#放入key 1.quel invariant pour la boucle dans sort ? --回答第n次迭代会发生什么事情，从功能上和参数变化上来考虑 Après kek^eke iteration, les k+1 premieres cases de A sont par ordre croissant. 2.quelles préconditions et postconditions pour insert ? Après kek^eke appel de insert: ​ préconditions: les k permiers triés ​ postconditions: les k+1 permiers triés 3.quel invariant pour le while d’insert ? après la mem^eme itération du while: j=x−1−mj = x -1 - mj=x−1−m les m éléments d’indice plus grand que j sont &gt; key soit A[j] &gt; key, soit (A[j] &lt;= key et pour tout i&lt;=j, A[i]&lt;=key) soit A’ la valeur de A au début de itération ​ si $ i &gt; j , A[i+1] = A’[i]$ ​ si i&lt;=j,A[i]=A′[i]i &lt;=j, A[i] = A'[i]i&lt;=j,A[i]=A′[i] 2.Algorithme d’Euclide#相减求最大公约数 12345678# pour a et b strictement positifsdef euclid (a , b): while a != b: if a &gt; b: a = a - b else : b = b - a return a On note ai la valeur de a à la n de l’itération i (donc a0 est la valeur initiale) et on définit bi de façon similaire. Quel invariant de la boucle while pour la correction de l’algorithme?–从功能上解释：Propriétés fonctionnelles : le résultat est celui attendu. [结果符合预期] ​ après iei^eie itération: pgcd(ai,bi)=pgcd(a,b)pgcd(a_i,b_i) = pgcd(a,b)pgcd(ai​,bi​)=pgcd(a,b) Quel invariant de la boucle while pour la terminaison ? --从参数上解释：non-fonctionnelles[非功能性属性] : Terminaison, Indices de tableaux, Pointeurs, Débordements[溢出] de capacité, etc. ​ 0&lt;ai&lt;ai−10&lt;a_i&lt;a_{i-1}0&lt;ai​&lt;ai−1​ ou 0&lt;bi&lt;bi−10&lt;b_i&lt;b_{i-1}0&lt;bi​&lt;bi−1​ Conclure quand à la terminaison et la correction de l’algorithme en utilisant les deux invariants. Invariants pour les programmes récursifs EXEMPLE: 123456# Pour i &lt; n = len(A)def maximum(i, A): if i == len(A) - 1: return A[i] else : return max(A[i], maximum(i + 1, A)) EXERCICE: 123456789# pour a et b strictement positifsdef euclid (a , b): if a == b: return a else : if a &gt; b: return euclid (a - b, b) else : return euclid (a , b - a) Invariants et problèmes insolubles On peut aussi utiliser les invariants pour démontrer qu’un problème n’a pas de solution ; L’invariant est satisfait[满足] par les itérations de tout hypothétique algorithme ; Il n’est pas satisfait par la configuration finale recherchée. EXERCICE: 第一个是奇数不行–&gt;每次循环增加的一个多米洛是2 第二个是缺同色的不行–&gt;每次循环增加的是一黑一白，但棋盘缺了两白色 Preuve automatique et indécidabilité[不可决定性] Peut-on écrire un programme qui prend un programme quelconque[任何] en entrée et décide s’il a une propriété donnée ? 比如说，我们Écrire un programme qui décide si un programme quelconque s’arrête (sur une entrée donnée). • Supposons qu’un tel programme existe : on l’appelle H ; • Pour un programme P et une entrée i donnés, H(P, i) vaut vrai si P s’arrête pour l’entrée i et faux sinon • Soit le programme H‘ , qui prend en entrée un programme P dont l’entrée est un programme, et défini par : 1234if H(P,P): while True: passelse: print(&quot;coin !&quot;) Que se passe-t-il pour l’exécution de H’ pour le programme H’? H’ est bien un programme qui prend un programme en entrée • Si l’exécution se termine alors H(H’, H’) est vrai… et on devrait aller dans le while qui ne s’arrête jamais ; • Si l’exécution ne se termine pas, alors H(H’, H’) est faux… et on devrait s’arrêter en affichant “coin !”. –&gt;Donc le programme H‘ ne peut pas exister ! Indécidable Un problème algorithmique dont la réponse est vrai ou faux est appelé problème de décision ; Un problème de décision pour lequel il n’existe pas d’algorithme qui le résout est dit indécidable ; Le Théorème de Rice dit (informellement) que toute propriété non-triviale[琐碎，平凡] sur les programmes est indécidable. 下面是3个Indécidable的例子 le 10e problème de Hilbert 不定方程又称丢番图方程[ Une équation diophantienne]的可解性 Problème de correspondance de Post (PCP) Machines à deux compteurs Complexité 定义 La complexité d’un problème est celle du meilleur algorithme[最佳算法] qui le résoud ; Deux mesures principales : 1 temps de calcul ; 2 mémoire maximale utilisée. Ces mesures dépendent de l’instance du problème considéré : 1.on mesure en fonction de la taille de l’entrée ; 2. meilleur cas ou pire cas ; 3.cas moyen (espérance) ; Elles dépendent aussi du modèle de calcul considéré : Informatique théorique : machines de Turing. Par exemple le problème de décision du voyageur de commerce est NP-complet Analyse pratique : modèle RAM. Par exemple le tri fusion opère[归并排序] en O(nlog2n)O(nlog_2n)O(nlog2​n) Machines de Turing EXEMPLE 负数的补码计算：取反+1 EXERCICE Écrire une machine de Turing sur l’alphabet {a, b} qui décide si un mot est un palindrome. Par exemple abba ou ababa sont acceptés mais abbaa est rejeté. 本质思想还是第一个和最后一个比。 Complexité d’une machine de Turing -Les machines de Turing sont le modèle le plus simple d’algorithme -Un seul type d’instruction, un seul type de données (symbole) 单一指令单一数据类型 -La taille de l’entrée est le nombre de cases initialement non vides -Les notions de complexité sont simples et naturelles : Complexité temporelle : nombre d’instructions réalisées avant arrêt[执行的指令数] Complexité spatiale : nombre maximal de cases non vides simultanément[同时最大数量的非空方格] SAT quelques classes de complexité des problèmes de décision PTIME: temps polynomial --&gt; O(nk)O(n^k)O(nk) ​ existence d’une solution dans un programme linéaire PSPACE: espace polynomial ​ décider si on peut passer d’un conguration à une autre dans Rush Hour ou Sokoban[独木桥] EXPTIME: temps exponentiel --&gt; O(2n)O(2^n)O(2n) ​ déterminer si le 1er joueur gagne pour une position de Go[围棋] (en fonction de la taille du plateau) EXPSPACE: espace exponentiel ​ déterminer si 2 expression régulières (simples) ont le même langage (a∗b∗+c)∗=(a+b+c)∗(a^*b^*+c)^* = (a+b+c)^*(a∗b∗+c)∗=(a+b+c)∗ PTIME⊂PAPACE⊂EXPTIEM⊂EXPSPACEPTIME⫋EXPTIEMPTIME\\subset PAPACE \\subset EXPTIEM \\subset EXPSPACE\\\\ PTIME\\subsetneqq EXPTIEM PTIME⊂PAPACE⊂EXPTIEM⊂EXPSPACEPTIME⫋EXPTIEM Le problème SAT 布尔可满足性问题: 确定是否存在满足给定布尔公式的解释的问题。 -Entrée: une formule booléenne avec des variables propositionnelles. -Sortie: existe-t-il une valeur des variables telle que la formule est vraie ? EXEMPLE：8皇后问题的SAT表示 Le problème des huit reines : Placer huit reines sur un échiquier telles qu’elles ne soient pas en prise. Comment résoudre ce problème avec le problème SAT ? X11∨X12∨...∨X18∧X21∨X22∨...∨X28∧...∧X11=¬X22∧¬X33∧...∧¬X88∧...X_{11} \\vee X_{12} \\vee ... \\vee X_{18}\\\\\\land\\\\X_{21} \\vee X_{22} \\vee ... \\vee X_{28}\\\\\\land\\\\...\\\\\\land\\\\ X_{11} = \\neg X_{22} \\land \\neg X_{33} \\land ... \\land\\neg X_{88}\\\\\\land\\\\... X11​∨X12​∨...∨X18​∧X21​∨X22​∨...∨X28​∧...∧X11​=¬X22​∧¬X33​∧...∧¬X88​∧... Complexité de SAT -问题是时间复杂度是EXPTIME: temps exponentiel --&gt; O(2n)O(2^n)O(2n) -On peut encoder une partie d’échecs ou de go avec SAT ⇒ mais avec une formule de taille exponentielle ! -Si on donne une valeur des variables, il est facile de vérifier que c’est une solution ou non -De nombreux problèmes utiles ont cette propriété : existence d’un cycle hamiltonien dans un graphe orienté ; #有向图的哈密顿回路[一笔画] coloration de graphes[着色] problème du sac-à-dos (Knapsack) [背包问题]; problème des cartons (Bin packing) [装箱问题]; programmation linéaire en nombre entiers (ILP)[整数线性规划]. -Pour les étudier : abstraire la recherche de la solution[将问题答案01编码] Permettre à la machine de deviner[猜想，尝试] une solution avant de la vérifier ; Permettre à la machine de se dupliquer[赋值] et vérifier plusieurs candidats en même temps → Machine non-déterministe Machines de Turing non-déterministes 就是读到的东西一样可能导致不同的操作 Dans ce cas, la machine se duplique[自我复制] et chaque copie exécute l’une des possibilités. La machine accepte si l’une des copies atteint l’état accept, mais la machine rejette si toutes les copies atteigent l’état reject. EXEMPLE Écrire une machine de Turing non-déterministe qui étant donnée une séquence de 0, 1 et x décide s’il existe une valeur de x ∈ {0, 1} telle que la séquence est un palindrome sur {0, 1}. NP La classe de complexité NP -Une machine non-déterministe résout SAT en temps polynomial：[PTIME: O(nk)O(n^k)O(nk)] -NPTIME (ou NP) : les problèmes qu’on peut résoudre en temps polynomial . ​ ex. SAT, knapsack, ILP, etc. -Mais aussi NPSPACE, NEXPTIME, NEXPSPACE, etc. Le Théorème de Savitch implique que PSPACE = NPSPACE et EXPSPACE = NEXPSPACE. P⊆NP⊆PSPACEP ⊆ NP ⊆ PSPACE P⊆NP⊆PSPACE Une question ouverte importante est P=NP? Bornes inférieures et complétude -Soit un problème P tel que : on peut transformer toute instance d’un problème quelconque de la classe de complexité C en une instance de P la transformation n’est pas trop coûteuse[昂贵] (typiquement polynomiale, ou logarithmique pour PTIME) -P est C-dificile ; -Si de plus P ∈ C alors P est C-complet ; -Les problèmes C-complets sont les plus dificiles de la classe C ; -Le Théorème de Cook-Levin dit que SAT est NP-dificile (et donc NP-complet). EXERCICE Le problème de décision ILP est : étant donnée une intersection de demi-espaces, contient-elle un point entier ? Montrer que ILP est NP-dificile. 证明所有的SAT问题都能转换成ILP问题。 任何SAT:X1∧ ¬X2∧¬X3转化为ILP:0&lt;=X1&lt;=1,0&lt;=X2&lt;=1,0&lt;=X3&lt;=1X1+(1−X2)+(1−X3)&gt;=3任何SAT: X_1 \\land \\ \\neg X_2 \\land \\neg X_3\\\\ 转化为ILP:0 &lt;= X1 &lt;= 1, 0&lt;= X2 &lt;= 1 , 0 &lt;= X3 &lt;= 1\\\\ X_1+(1-X_2)+(1-X_3)&gt;=3 任何SAT:X1​∧ ¬X2​∧¬X3​转化为ILP:0&lt;=X1&lt;=1,0&lt;=X2&lt;=1,0&lt;=X3&lt;=1X1​+(1−X2​)+(1−X3​)&gt;=3 RAM Les opérations arithmétiques ont une complexité polynomiale pour une machine de Turing Idem pour l’accès à une case particulière de la mémoire Pour l’analyse pratique des algorithmes, on considère un modèle plus réaliste : opérations arithmétiques simples, indexage [索引] (Random access memory), etc. en temps constant#简单的算术运算、索引（随机存取存储器）等，在恒定的时间内进行。 accès direct à des variables (registres) #直接访问变量[寄存器] contrôle du ot d’exécution (branchements) types de données classiques à précision innie (en général) #精度不高 On peut adapter le modèle en fonction de ce qu’on cherche à mesurer.","link":"/2022/09/06/ALGOA_CM1&2/"},{"title":"ALGOA_CM4&amp;5","text":"ALGOA_CM4&amp;5 Énumeration exhaustive et Backtracking et Diviser pour régner Énumeration exhaustive EXEMPLE Carré magique. Pour n ∈ N&gt;0, placer une fois et une seule chaque nombre de 1 à n^2 dans une grille carrée de taille de côté n de façon à ce que la somme de chaque ligne, chaque colonne, et chaque grande diagonale soit la même. 123456789def carre(C,T,k,n): if k == n^2 and test\\_carre(C, n):#递归终止条件 return C for i = 1 to n^2: if not T[i]: T[i] = true#标记有没有取过 C[(k / n),(k mod n)]=i#这里下标很有意思，这样i和j都能取[0..n-1] carre(C,T,k+1,n) T[i]=false#回退 EXERCICE Backtracking 解空间树，DFS+约束函数 Exemple 八皇后： 123456789101112131415def aligned(L,i,j):#约束函数 for (k,l) in L: if k==i or l == j or abs(k-i) == abs(l - j): return True return Falsedef queen(L,i,n): if i==n: return L else: for j = 1 to n-1: if not aligned(L,i,j): L2 = L L2 = L2 ++ [(i,j)] queen(L2,i+1,n) return [] EXERCICE: Trouver des valeurs de x, y, z et w pour satisfaire cette formule de 3-SAT par backtracking : (x∨z∨w)∧(x∨y∨¬w)∧(¬x∨¬y∨w)∧(¬x∨¬y∨z)∧(¬x∨¬w)∧¬z(x ∨ z ∨ w) ∧ (x ∨ y ∨ ¬w) ∧ (¬x ∨ ¬y ∨ w) ∧ (¬x ∨ ¬y ∨ z) ∧ (¬x ∨ ¬w) ∧ ¬z(x∨z∨w)∧(x∨y∨¬w)∧(¬x∨¬y∨w)∧(¬x∨¬y∨z)∧(¬x∨¬w)∧¬z X=0,Y=1,W=1,Z=0 OU X=1,Y=0,W=0,Z=0 Le voyage du cavalier. On considère un échiquier de taille n avec un cavalier sur la case en haut à gauche. On rappelle que le cavalier se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale. Écrire un algorithme pour trouver dans quel ordre le cavalier doit visiter les cases de l’échiquier pour les voir toutes exactement une fois. -se déplace de 2 cases dans une direction puis 1 case dans une direction orthogonale: ​ -老师写的算法 12345678910111213141516def moves(B,i,j): n = len(B) deps = [(2,1),(-2,1),(2,-1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)] L = [] for (x,y) in deps: if i+x &gt;= 0 and i+x &lt; n and j+y &gt;= 0 and j+y &lt; n and B[i+x][j+y] == 0: L.append((i+x,j+y)) return Ldef knight(B,i,j,k): if k == n*n+1: print_board(B)#注意终止条件！ else: for (x,y) in moves(B,i,j): B[x][y]=k knight(B,i,j,k+1) B[x][y]=0 Diviser pour régner (Divide &amp; Conquer ) Principe général: Diviser en sous-problèmes Résoudre les sous-problèmes Combiner les solutions. En général, on parle de diviser pour régner , quand on divise en (au moins deux) problèmes indépendants identiques au problème initial mais plus petits. Donne naturellement des algorithmes récursifs. EXEMPLE: merge sort 归并排序 1234567891011121314151617181920def merge_sort(A,d,f): if f - d &gt; 1 : //划分 m = int((f+d)/2) merge_sort(A,0,m) merge_sort(A,m,f) B = A //合并 i = 0 j = m k = 0 while i &lt; m or j &lt; n: if j == n or B[i]&lt;B[j]#左半区更小 A[k] = B[i] i = i+1 else: A[k] = B[j] j = j + 1 k = k + 1 时间复杂度分析 T(n) = 2T(n/2) + Θ(n) a=2,b=2,k=1–&gt;T(n)=Θ(nlogn) EXERCICE: Recherche dichotomique. Proposer un algorithme pour la recherche d’un élement dans un tableau trié et donner sa complexité au pire cas. 二分查找 12345678def dicho(A,x,d,f): if d &gt; f : return False else: m = (d+f)/2 if x == A[m]: return m else: if x &lt; A[m]: return dicho(A,x,d,m) else : return dicho(A,x,m+1,f) Occurrences. Écrire un algorithme pour compter le nombre d’occurrences d’un élément donné dans un tableau trié et donner sa complexité pire cas. 查找出现的次数 123456789101112131415161718192021def find_first(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m] or (m &gt; d and A[m-1] == x): --这里的m&gt;d等价于f&gt;d，看着没啥必要的样子哎 return find_first(A,x,d,m) elif x &gt; A[m]: return find_first(A,x,m+1,f) else: return mdef find_last(A,x,d,f): if d &gt;= f : if A[d] == x: return d else: return None else: m = (d+f)//2 if x &lt; A[m]: return find_last(A,x,d,m) elif x &gt; A[m] or (m &lt; f and A[m-1] == x): --这里的m&gt;f也等价于f&gt;d，看着也没啥必要的样子 return find_last(A,x,m+1,f) else: return m 多米诺棋盘覆盖问题 用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//tr,tc表示棋盘左上角//dr,dc表示表示特殊方格void ChessBoard(int tr , int tc , int dr , int dc , int size){ if(size == 1)return;//棋盘只有一个方格其是特殊方格 int number = ++t;//L型骨牌号 int s = size/2;//划分棋盘 //覆盖左上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s-1][tc+s-1]=number; ChessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)//特殊方格在右上角子棋盘中 ChessBoard(tr,tc+s,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖左下角，再递归处理子棋盘 board[tr+s-1][tc+s]=number; ChessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左下角子棋盘中 ChessBoard(tr+s,tc,dr,dc,s);//递归处理子棋盘 else { //用t号L型骨牌覆盖右上角，再递归处理子棋盘 board[tr+s][tc+s-1]=number; ChessBoard(tr+s ,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr+s,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s][tc+s]=number; ChessBoard(tr+s,tc+s,tr+s,tc+s,s); }} a = 4 , b = 2 , k = 1 Pesées. On a n pièces de monnaies dont une exactement est fausse et plus légère que les autres. On dispose d’une balance de type Roberval ou à éau : en une pesée on peut déterminer si un ensemble de pièces est plus lourd qu’un autre. Écrire un algorithme pour trouver la pièce fausse à l’aide de la balance et donner sa complexité au pire cas. On représente les pièces par un tableau de poids et on veut l’indice de la pièce fausse. On dispose d’une fonction compare(A, d1, f1, d2, f2) qui renvoit −1, 0 ou 1 si la somme des poids des pièces aux indices d1 jusqu’à f1 est respectivement plus petite, égale, ou plus grande que celle des pièces de d2 à f2 12345678910def pesses(A,d,f): if d &gt; f : return False elif d == f : return d else: m = (d+f)//2 if compare(A,0,m,m+1,f) == -1 : return pesses(A,0,m) elif compare(A,0,m,m+1,f) == 1 : return pesses(A,m,f) else: return False Tri rapide (quick sort). Si on choisit un élément du tableau (le pivot), on peut partionner les autres éléments en ceux qui sont plus petits, et ceux qui sont plus grands que le pivot. En exploitant ce principe, proposer un algorithme de tri d’un tableau et donner sa complexité au pire cas 123456789101112131415def quicksort (A, d, f ): if d &lt; f : p = partition (A, d, f ) quick_sort(A, d, p-1) quick_sort(A, p+1, f)def partition (A, d, f ): p = random_int(d, f) swap(A, f , p) j = d for i = d to f - 1: if A[i] ≤ A[f]: swap(A, j , i ) j = j + 1 swap(A, j , f ) return j a = 2,b=,k=1","link":"/2022/09/16/ALGOA_CM4&5/"},{"title":"ALGOA_CM3","text":"ALGOA_CM3 Complexité asymptotique et Algorithmes probabilistes Complexité asymptotique 对O，Ω，Θ等的一些理解 EXEMPLE 求解插入排序在最坏情况下的时间复杂度 EXERCICE 求解下面两个算法的时间复杂度 On veut évaluer en un point x un polynôme de degré n en donné par la liste A de ses coefficients. On considère deux approches : 12345678910111213def naive(A,x,n): s = [0] for i = 1 to n: p = A[i] for j = 1 to i: p = p*x s = s+p return sdef horner(A,x,n): s = 0 for i = n downto 0: s = s*x + A[i] return s Calculer proprement la complexité des deux approches. naive:1+2∗n+∑1n∑1i1=1+2n+∑1ni=1+2n+n(n−1)/2=Θ(n2)1+2*n+\\sum^n_1\\sum^i_1 1 = 1 + 2n + \\sum^n_1 i = 1 + 2n + n(n-1)/2 = Θ(n^2)1+2∗n+∑1n​∑1i​1=1+2n+∑1n​i=1+2n+n(n−1)/2=Θ(n2) horner: 1+n=Θ(n)1+n=Θ(n)1+n=Θ(n) Quelle est la complexité du tri par insertion en fonction du nombre d’inversions I (le nombre de couples (i, j) tels que i &lt; j et A[i] &gt; A[j]) et de n ? 移动的次数就是等于翻转对的个数：移动一次就少一个翻转对，直到排序完成 然后需要加上定位到所有位置的一个遍历的复杂度n O(n+l) Complexité pire cas des algorithmes récursifs -On peut les résoudre parfois directement : récurrences linéaires à coefficients constants ; deviner une expression et la prouver[归纳法归纳法] ; Théorèmes dédiés : Master Theorem (voir divide and conquer), récurrences d’Akra-Bazzi. 不能直接解决的那种证明可以用归纳法！ EXEMPLE 阶乘 12345def fact(n): if n == 0: return 1 eles: return n * fact(n-1) T(n)=T(n−1)+1T(0)=1−−&gt;T(n)=n+1=Θ(n)T(n) = T(n-1)+1 \\quad T(0)=1 --&gt; T(n)=n+1=Θ(n)T(n)=T(n−1)+1T(0)=1−−&gt;T(n)=n+1=Θ(n) fib: 12345def fib(n): if n == 0 or n == 1: return 1 else: return fib(n-1)+fib(n-2) T(n+2)=T(n+1)+T(n)+1&gt;=T(n+1)+T(n)etT(0)=1,T(1)=2T(n+2) = T(n+1) + T(n) +1 &gt;= T(n+1) +T(n) \\quad et \\quad T(0)=1,T(1)=2T(n+2)=T(n+1)+T(n)+1&gt;=T(n+1)+T(n)etT(0)=1,T(1)=2 x2−x−1&gt;=0x^2-x-1 &gt;= 0x2−x−1&gt;=0 是因为偏微分方程 EXERCICE Montrer que la complexité de fib est O(2n)O(2^n)O(2n) 归纳法归纳法 假设∃C、N，tq∀n&gt;Nf(n)&lt;=c∗2n现在证n+1:f(n+1)=f(n)+f(n−1)+1&lt;=c12n+c22n−1+1&lt;=max(c1,c2)2n&lt;=max(c1,c2)2n+1假设\\quad{\\exists} C、N，tq\\quad{\\forall}n&gt;N\\quad f(n)&lt;=c*2^n\\\\ 现在证n+1: f(n+1)=f(n)+f(n-1)+1&lt;=c_12^n+c_22^{n-1}+1&lt;=max(c_1,c_2)2^n&lt;=max(c_1,c_2)2^{n+1} 假设∃C、N，tq∀n&gt;Nf(n)&lt;=c∗2n现在证n+1:f(n+1)=f(n)+f(n−1)+1&lt;=c1​2n+c2​2n−1+1&lt;=max(c1​,c2​)2n&lt;=max(c1​,c2​)2n+1 Complexité moyenne -Pour calculer la complexité moyenne, il faut une distribution de probabilité[概率分布] sur les données d’entrée -On calcule, l’espérance de la complexité selon cette distribution.[期望] EXEMPLE:引例 1234567# on suppose n&gt;0def maximum(A,n): r = A[1] for i = 2 to n-1: if A[i] &gt; r : r = A[i] return r Combien de fois le if est-il pris[prendre] ? -Au pire cas, la liste est triée dans l’ordre ascendant, et le if est pris à chaque fois (n − 1 fois) Mais en moyenne ? –但是感觉这里讨论应该是if下面那条交换语句，就不管怎样if都得执行n-1 fois variables aléatoires indicatrices: 随机指标变量 -Soit XiX_iXi​ la variable aléatoire indicatrice de l’événement EiE_iEi​ = le if est pris à l’itération i XiX_iXi​是随机变量,EiE_iEi​表示if在第i次迭代被prendre的事件 -Le nombre total de prises est : X=∑i=2n−1XiX=\\sum^{n-1}_{i=2}X_iX=∑i=2n−1​Xi​ -L’espérance de X est donc (linéarité de l’espérance) : $E(X) = \\sum^{n-1}_{i=2}E(X_i) $ -Par construction, E(Xi)E(X_i)E(Xi​) est la probabilité que que l’événement soit vrai : E(Xi)=P(Ei)Xi(Ei)+P(¬Ei)Xi(¬Ei)=P(Ei)×1+P(¬Ei)×0=P(Ei)E(X_i) = P(E_i)Xi(E_i) + P(¬Ei)Xi(¬Ei) = P(Ei ) × 1 + P(¬Ei ) × 0 = P(Ei )E(Xi​)=P(Ei​)Xi(Ei​)+P(¬Ei)Xi(¬Ei)=P(Ei)×1+P(¬Ei)×0=P(Ei) Donc : E(X)=∑i=2n−1P(Ei)E(X) = \\sum^{n-1}_{i=2}P(Ei)E(X)=∑i=2n−1​P(Ei) Reste à calculer P(Ei)P(E_i)P(Ei​). 有了这些概念再回去看刚刚那个exemple： -Sans information supplémentaire[进一步的], on suppose que chaque permutation des éléments de A est équiprobable[等效的]. -Pour simplifier, on suppose les éléments de A tous distincts[不同的]; -Comme tous les ordres pour A sont équiprobables : 随时牢记：EiE_iEi​ 表示执行第i次迭代的概率 il y a autant de séquences avec A[1] &gt; A[0] qu’avec A[1] ≤ A[0] donc P(E2)=12P(E_2)=\\frac12P(E2​)=21​ on peut découper[切出] les séquences possibles en trois groupes de même taille : dans les 3 premiers chiffres, le 1er est le plus grand : E3E_3E3​est faux 2 dans les 3 premiers chiffres, le 2e est le plus grand : E3E_3E3​est faux 3 dans les 3 premiers chiffres, le 3e est le plus grand : E3E_3E3​ est vrai donc P(E3)=13P(E_3)=\\frac 13P(E3​)=31​ plus généralement, P(Ei)=1iP(E_i)=\\frac 1iP(Ei​)=i1​ -Et finalement E(X)=∑i=2n−11iE(X) = \\sum^{n-1}_{i=2}\\frac 1iE(X)=∑i=2n−1​i1​ et donc : E(X)=lnn+O(1)E(X) = lnn+O(1)E(X)=lnn+O(1)[牛顿欧拉啥的近似] Exercices On réalise une permutation aléatoire uniforme de la la liste [1, 2, . . . , n] ? Quel est l’espérance du nombre de points fixes ? (le nombre d’éléments qui sont toujours à la même place). E(X)=∑inP(Ei)=∑in1n=1E(X)=\\sum_i^nP(E_i)=\\sum_i^n\\frac1n=1 E(X)=i∑n​P(Ei​)=i∑n​n1​=1 On a vu que le nombre d’échanges faits par le tri par insertion est égal au nombre d’inversions dans le tableau A : le nombre de couples (i, j) tels que i &lt; j et A[i] &gt; A[j]. Quel est l’espérance du nombre d’inversions si on suppose le tableau A est une permutation aléatoire uniforme de l’ensemble [1, 2, . . . , n] ? E(X)=∑i≠jnP(Eij)P(Eij)=P(i&lt;j)P(Eij∣i&lt;j)E(X)=\\sum_{i\\neq j}^nP(E_{ij})\\quad P(E_{ij})=P(i&lt;j)P(E_{ij}|i&lt;j) E(X)=i=j∑n​P(Eij​)P(Eij​)=P(i&lt;j)P(Eij​∣i&lt;j) Écrire un algorithme pour trouver un élément dans une liste de longueur n non triée ; Quelles sont les complexités au meilleur cas, au pire cas et en moyenne de cette algorithme ? (Pour la moyenne, on suppose x borné par une valeur N ≥ n) 算法[老师写的真的超级厉害！] 123456789def find(x,A): lens = len(A) find = false i = 0 while i &lt; lens and not find: if x == A[i]: find = true i++ return find meilleur cas:1; pire cas: n en moyenne: EiE_iEi​ 表示执行第i次迭代的概率–&gt;1.x n’est pas dans la liste; 2.il y a l’indice i ou après. P(Ei)=P(Ei∣x dans la liste)P(x dans la liste)+P(Ei∣x n′est pasdans la liste)P(x n′est pasdans la liste)=n−in∗nN+1∗(1−nN)P(A)=P(A∣B)P(B)+P(A∣¬B)∗P(¬B)P(E_i)=P(E_i|x\\ dans\\ la\\ liste)P(x\\ dans\\ la\\ liste) + P(E_i|x\\ n'est\\ pas dans\\ la\\ liste)P(x\\ n'est\\ pas dans\\ la\\ liste)\\\\=\\frac{n-i}n*\\frac nN+1*(1-\\frac nN)\\\\P(A)=P(A|B)P(B)+P(A|\\neg B)*P(\\neg B)P(Ei​)=P(Ei​∣x dans la liste)P(x dans la liste)+P(Ei​∣x n′est pasdans la liste)P(x n′est pasdans la liste)=nn−i​∗Nn​+1∗(1−Nn​)P(A)=P(A∣B)P(B)+P(A∣¬B)∗P(¬B) ​ E(X)=∑i=1nP(Ei)=∑i=1n(1−iN)=(n−1)(1−n2N)E(X) = \\sum^{n}_{i=1}P(Ei)=\\sum_{i=1}^n(1-\\frac iN)=(n-1)(1-\\frac n{2N})E(X)=∑i=1n​P(Ei)=∑i=1n​(1−Ni​)=(n−1)(1−2Nn​) Algorithmes probabilistes: 概率算法 -Pour la complexité, le cas moyen est souvent plus favorable que le pire cas, pour ne pas tomber systématiquement sur des cas défavorables, on peut mélanger aléatoirement les données[为了避免系统地找到不利的案例，可以将数据随机地混合起来] -Un algorithme probabiliste est un algorithme qui utilise des instructions random ou similaires qui fournsissent leur résultat en suivant une certaine distribution de probabilité ; -L’exécution d’un algorithme probabiliste est caractérisée par son temps d’exécution attendu[预期执行时间] -La complexité attendue au pire cas est l’espérance de la complexité quand on résoud les choix non-probabilistes de la façon la plus défavorable ; -L’espérance du nombre de fois où le if est pris au pire cas dans maximum_alea est O(ln n) quelles que soient les données d’entrée même si elles sont fournies par une entité adverse EXEMPLES Monte-Carlo Les algorithmes de décision de type Monte-Carlo fournissent toujours une réponse mais peuvent se tromper[可能是错误的] 123456def fermat_prime(x,n): for k = 1 to n: x = random_int(2,n-2) if x^(n-1) != 1 (mod n):#1 mod n永远等于0 return false#所以在说x取到0返回flase？ return true#永远vari Pour les problèmes d’optimisation, ils donnent une réponse approchée (typiquement avec une garantie probabiliste[概率保证]) 12345678def eval\\_pi(n):# estimer la valeur de π r = 0 for k = 1 to n: x = random(0,1) y = random(0,1) if x^2+y^2 &lt;= 1:#x,y在圆[(0,0),1]里面 r = r + 1 return 4*r/n #？？？？？？ Las Vegas Les algorithmes de type Las Vegas peuvent échouer à trouver une solution.[可能无法找到解决方案] Mais s’ils en renvoient une elle est correcte. L’espérance de leur temps d’exécution est finie 1234567891011def random_queen(L,i,n): if i == n: return L else: M=[] for j=1 to n-1: if not aligned(L,i,j): M = M ++ [j] j = random_int(0,len(M)-1)#就是说把所有可以的j全加进去然后随机选，不太对怎么觉得len(M)这里 random_queen(L++[(i,j)],i+1,n) return DO_NOT_KNOW EXERCICES 1.On dispose d’une fonction biased_random() qui renvoit 1 avec une certaine probabilité p inconnue. Écrire un algorithme qui renvoit 1 avec probabilité 0.5 et 0 avec probabilité 0.5. 12345while true: x = biase_random() y = biase_random() if x != y : return x 假设P(x=0 et y=1)=r=P(x=1 et y=0) P(ret=0)=r+(1−2r)r+(1−2r)2r+..=r∑n=0∞(1−2r)n=r∗11−(1−2r)=0.5P(ret = 0)=r+(1-2r)r+(1-2r)^2r+..=r\\sum_{n=0}^{\\infty}{(1-2r)^n}=r*\\frac1{1-(1-2r)}=0.5P(ret=0)=r+(1−2r)r+(1−2r)2r+..=r∑n=0∞​(1−2r)n=r∗1−(1−2r)1​=0.5 Donner l’espérance de sa complexité temporelle. E(x)=∑E(Xi)=∑i=1nP(Ei)E(x)=\\sum E(X_i)=\\sum^{n}_{i=1}P(Ei)E(x)=∑E(Xi​)=∑i=1n​P(Ei) P(Ei)=(1−2r)iP(E_i)=(1-2r)^iP(Ei​)=(1−2r)i E(x)=∑(1−2r)i=12r=12p(1−p)E(x)=\\sum (1-2r)^i=\\frac1{2r}=\\frac 1{2p(1-p)}E(x)=∑(1−2r)i=2r1​=2p(1−p)1​ 2.On considère la function suivante : 123def permutation_aleatoire(A, n): for i = 0 to n = 1: swap(A[i], A[random_int(i,n=1)]) Une k-permutation de A est une séquence qui contient k éléments de A. Si la taille de A est n alors une n-permutation est une permutation. Démontrer l’invariant suivant de la boucle pour : après l’itération i, les i premiers éléments de A contiennent chaque i-permutation de A avec probabilité (n−i)!n!\\frac {(n-i)!}{n!}n!(n−i)!​ 归纳法归纳法归纳法！！！ soit p une k+1-permutation, p’ le préfixe de longueur k de p P(p′ et x)=P(x∣p′)P(p′)=1n−k∗(n−k)!n!=[n−(k+1)]!n!P(AB)=P(A∣B)∗P(B)P(p'\\ et\\ x)=P(x|p')P(p')=\\frac1{n-k}*\\frac{(n-k)!}{n!}=\\frac{[n-(k+1)]!}{n!}\\\\ P(AB)=P(A|B)*P(B) P(p′ et x)=P(x∣p′)P(p′)=n−k1​∗n!(n−k)!​=n![n−(k+1)]!​P(AB)=P(A∣B)∗P(B) Quel est le résultat de l’algorithme? 就是在做交换但是随机这样子？ Quelle est la complexité de l’algorithme ? Θ(n) Classes de complexité des algorithmes probabilistes 问题集 rapple: EiE_iEi​ 表示执行第i次迭代的概率,E(X)=∑P(Ei)E(X) = \\sum P(Ei)E(X)=∑P(Ei) 同一个式子是不是可以同时等于O，Ω，Θ 是的，但是一般写Θ，因为它表达的信息能更多 P40的插入排序翻转对的问题 移动的次数就是等于翻转对的个数，然后需要加上定位到所有位置的一个遍历的复杂度n，所以是n+l P43的斐波那契Ω((32)n)Ω((\\frac32)^n)Ω((23​)n) P47的ex2 P50的pi和随机八皇后","link":"/2022/09/16/ALGOA_CM3/"},{"title":"ALGORITHM-Prem","text":"Prem 问题描述：全排列问题的两种递归实现 1.DFS(来自啊哈算法一书) 123456789101112131415161718192021222324void dfs(int step , int n ,int book[] , int a[]){ if (step == n )//排到第n个数，排列完成 { print(a,n); return;//【返回之前一步，很重要】 }//每一步的操作for (int i = 0; i &lt; n; i++){ if (!book[i])//还没有排 { a[step] = i+1; book[i] = 1; //开始排下一个了 dfs(step+1,n,book,a); book[i] = 0;//排序完成，回收本次数【！！！】 }} return;} DFS：深度优先搜索，这里的DFS不单指图论，理解为一种递归的思想。下一步操作与当下操作是一样的,一直执行，直到符合条件。基本模型为： void dfs(int step) { 判断边界(递归结束条件)return; 尝试每一种可能 for(int i = 0 ; i &lt; n ; i++) { 继续下一步 dfs(step + 1); } return ; }","link":"/2021/12/06/ALGORITHM-Prem/"},{"title":"ALGORITHM-期末","text":"期末实验汇总 西南交通大学算法实验期末题型汇总 凸包问题 蛮力法 文字描述 找所有构成凸包的点 对由n个点构成的集合S中每两个点进行遍历，判断这两点是否能构成凸多边形的边。如果能，则将这两点的标志位flag置位1。具体判断方法为：集合S内的所有点都在这两个点构成边的同一侧。(一侧的判断由ax+by&gt;=c的点的个数为n-2或0完成) （以凸包内一点）用的斜率反推角度进行逆时针排序 说明：本算法中因输入设置为当x0&amp;&amp;y0时停止输入，因此在选择计算凸包边界各点的斜率的原点时选用(0,0)。 角度求解（由于atanx的范围为-π/2到π/2，但a的实际范围为-π到π，因此在求角度时要进行不同情况的判断计算）： ​ x = 0 ：y &gt; 0 时，a = π / 2；y &lt; 0 时，a = - π / 2 ; ​ a = atan(y / x) : 第一象限 x&gt;0,y&gt;0 :a = a;第二象限：x&lt;0,y&gt;0,a= a +π；第三象限：x&lt;0,y&lt;0,a= a +π；第四象限：x&gt;0,y&lt;0,a= a +2π 排序:用algorithm库封装的sort函数用每个点的角度信息对点进行快排，输出并压入数组Q。 计算凸包边长 依次计算数组Q中相邻点的距离，即distance(p[i],p[i+1])，注意加上首尾即distance(p[0],p[n-1])求得周长。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;#define M 10#define PI 3.1415926struct Point { int x; int y; int flag = 0; double a = 0;};Point Q[M];void print(Point P[], int n){ int k = 0; cout &lt;&lt; &quot;凸包的顺序输出为：&quot;; for (int i = 0; i &lt; n; i++ ) { if (P[i].flag) { Q[k] = P[i]; cout &lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt; &quot;(&quot; &lt;&lt; Q[k].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[k].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; k++; } } cout &lt;&lt; endl;}//自己定义的排序规则:按角度排int comp(const Point&amp; p_1, const Point&amp; p_2) { return p_1.a &lt; p_2.a;}//使其按逆时排列void sortP(Point P[], int n){ for (int i = 0; i &lt; n; i++) { if (!P[i].x) { if(P[i].y &lt; 0) P[i].a = 3.0*PI / 2.0; else P[i].a = PI / 2.0; } else { P[i].a = atan((double)P[i].y / P[i].x); //一象限不变 if (!P[i].y) if (P[i].x &lt; 0) P[i].a = PI;//0和PI的判断 else if (P[i].a * P[i].y &lt; 0) P[i].a += PI;//二、三象限加PI else {//四象限加2*PI if (P[i].y &lt; 0)P[i].a += 2 * PI; } } } sort(P , P+n , comp);//按序排 print(P, n);}//检查点在不在线一侧bool OneSide(Point P[], int n ,int a , int b ,int c){ int sign_1 = 0, sign_2 = 0; for (int k = 0; k &lt; n; k++) { if (a * P[k].x + b * P[k].y == c) { ++sign_1; ++sign_2; } if (a * P[k].x + b * P[k].y &gt; c) ++sign_1; if (a * P[k].x + b * P[k].y &lt; c) ++sign_2; } if (sign_1 == n || sign_2 == n) return 1; return 0;}void ConvexHull(Point P[] ,int n){ int k = 0; for (int i = 0; i &lt; n; ++i) { for (int j = i + 1; j &lt; n; ++j) { int a = P[j].y - P[i].y; int b = P[i].x - P[j].x; int c = P[i].x * P[j].y - P[i].y * P[j].x; if (OneSide(P, n, a, b, c)){ P[i].flag = 1; P[j].flag = 1; } } } sortP(P, n);//打印}double distance(const Point&amp; p_1 , const Point&amp; p_2){ return sqrt((p_1.x - p_2.x)* (p_1.x - p_2.x) + (p_1.y - p_2.y) * (p_1.y - p_2.y));}//计算凸包的边长double c_ConvexHull(int n){ double sum = 0; for (int i = 0 ; i &lt; n-1 ; i++) { // cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[i].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[i].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; sum += distance(Q[i], Q[i + 1]); } //首尾 sum += distance(Q[0], Q[n-1]); return sum;}int main(){ Point P[M]; int i=0; cout &lt;&lt; &quot;输入点集：&quot;; for (; i &lt; M; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (!x &amp;&amp; !y)break; P[i].x = x; P[i].y = y; } ConvexHull(P, i); cout &lt;&lt; &quot;凸包周长是：&quot; &lt;&lt; c_ConvexHull(i-1); return 0;} Gramph算法 文字描述 总体思路：先找到凸包上的一个点，然后从该点开始有方向的逐个寻找凸包上的点。 1.点集中纵坐标最小的点一定是凸包上的点，将其作为原点P0，重新求解点集S 2.计算点集中所有点相对于P0的幅角a，对其排序。a相同时，距离小的排在前面。P0、p1入栈。 3.连接P0和栈顶的点，得到直线L。看p1后面的点（即p2,计作当前点）是在直线L的右边还是左边。如果在直线的右边就执行步骤4；如果在直线的左边（上）就执行步骤5。 4.如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤3。 5.当前点是凸包上的点，把它压入栈，执行步骤6。 6.检查P2是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把P2后面那个点做当前点，返回步骤3。 最终栈中为凸包各点的按序存储 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define M 10struct Point{ double x, y;};Point P[M];//inoutPoint Q[M];//outputdouble distance(const Point&amp; p_1, const Point&amp; p_2)//距离{ return sqrt((p_2.x - p_1.x) * (p_2.x - p_1.x) + (p_2.y - p_1.y) * (p_2.y - p_1.y));}double x(const Point&amp; p_1, const Point&amp; p_2, const Point&amp; p_3)//叉积公式{ return (p_2.x - p_1.x) * (p_3.y - p_1.y) - (p_3.x - p_1.x) * (p_2.y - p_1.y);}bool cmp(const Point&amp; p_1, const Point&amp; p_2)//极角排序{ double pp = x(p_1, p_2, P[0]); if (pp &gt; 0) return true; if (pp &lt; 0) return false; return distance(P[0], p_1) &lt; distance(P[0], p_2);}int Graham(int n)//Graham算法{ int k = 0; for (int i = 1; i &lt; n; i++) { if (P[i].y &lt; P[k].y || (P[i].y == P[k].y &amp;&amp; P[i].x &lt; P[k].x)) k = i; } swap(P[0], P[k]); sort(P + 1, P + n, cmp); int top = 2; Q[0] = P[0], Q[1] = P[1]; for (int i = 2; i &lt; n; i++) { //去共线 while (top &gt; 1 &amp;&amp; x(Q[top - 2], Q[top - 1], P[i]) &lt;= 0) top--; Q[top++] = P[i]; } return top;}void show(int n){ for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[i].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[i].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; endl;}double sum(int n){ double sum = 0; for (int i = 0; i &lt; n - 1; i++) sum += distance(Q[i], Q[i + 1]); sum += distance(Q[0], Q[n - 1]);//首尾 return sum;}int main(){ int i = 0; cout &lt;&lt; &quot;输入点集：&quot;; for (; i &lt; M; i++){ int x, y; cin &gt;&gt; x&gt;&gt; y; if (!x &amp;&amp; !y)break; P[i].x = x; P[i].y = y; } int a = Graham(i); cout &lt;&lt; &quot;凸包是：&quot; ;show(a); cout &lt;&lt; &quot;凸包周长是：&quot;&lt;&lt; sum(a); return 1;} 动态规划 文字描述 无 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define PI 3.1415926#define M 10struct Point{ int x, y; double a = 0;};Point P[M];//inputPoint Q[M];//outputint book[M];//标记点// 计算三角形面积int area_t(Point p1, Point p2, Point pi){ return p1.x*p2.y + pi.x*p1.y + p2.x*pi.y - pi.x*p2.y - p2.x*p1.y - p1.x*pi.y;}//角度排int comp(const Point&amp; p_1, const Point&amp; p_2){ return p_1.a &lt; p_2.a;}//横坐标bool cmp(const Point&amp; p1, const Point&amp; p2){ if(p1.x==p2.x) return p1.y&lt;p2.y; return p1.x&lt;p2.x;}void print(Point P[], int n){ int k = 0; cout &lt;&lt;&quot;relusts:&quot;; for (int i = 0; i &lt; n; i++ ) { if (book[i]) { Q[k] = P[i]; cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[k].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[k].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\\t&quot;; k++; } } cout &lt;&lt; endl;}//使其按逆时排列void mysort_P(Point *P, int n){ for (int i = 0; i &lt; n; i++) { if (!P[i].x) { if(P[i].y &lt; 0) P[i].a = 3.0*PI / 2.0; else P[i].a = PI / 2.0; } else { P[i].a = atan((double)P[i].y / P[i].x); //一象限不变 if (!P[i].y) if (P[i].x &lt; 0) P[i].a = PI;//0和PI的判断 else if (P[i].a * P[i].y &lt; 0) P[i].a += PI;//二、三象限加PI else {//四象限加2*PI if (P[i].y &lt; 0)P[i].a += 2 * PI; } } } sort(P , P+n , comp);//按序排 print(P, n);}// 递归求凸包// ps 是当前要求解的点的集合，ps保存这些点在points数组中的下标// mode 表示递归s1 s2，还是递归s3，s4，还是同时递归 s1，s2，s3，s4// mode = 3 递归 s1，s2，s3，s4，只有第一次调用会出现该情况// mode = 2 递归s3，s4// mode = 1 递归s1 s2void ConvexHull(vector&lt;int&gt; &amp;ps, int mode){ // 边界处理：少于两个点的集合一定是凸包上的点 if(ps.size()&lt;=2) { for(int i=0; i&lt;ps.size(); i++) book[ps[i]]=1; return; } // 最左右一定是凸包上的点， pa最左点，pb最右点 book[ps.front()]=1, book[ps.back()]=1; Point pa=P[ps.front()], pb=P[ps.back()]; // 找距离 pa，pb组成的直线最远的点，imax是上方最远，imin是下方最远 int maxs=INT_MIN, mins=INT_MAX, imax=-1, imin=-1; for(int i=1; i&lt;ps.size()-1; i++) { int s = area_t(pa, pb, P[ps[i]]); if(s&gt;maxs &amp;&amp; s&gt;=0) maxs=s, imax=ps[i]; if(s&lt;mins &amp;&amp; s&lt;=0) mins=s, imin=ps[i]; } // pa,pb与imax，imin的连线，分割出下一趟递归的点集合 s1 s2 s3 s4 vector&lt;int&gt; s1, s2, s3, s4; for(int i=0; i&lt;ps.size()-1; i++) { if(area_t(pa, P[imax], P[ps[i]]) &gt;= 0) s1.push_back(ps[i]); if(area_t(pa, P[imin], P[ps[i]]) &lt;= 0) s3.push_back(ps[i]); } for(int i=1; i&lt;ps.size(); i++) { if(area_t(P[imax], pb, P[ps[i]]) &gt;= 0) s2.push_back(ps[i]); if(area_t(P[imin], pb, P[ps[i]]) &lt;= 0) s4.push_back(ps[i]); } if(mode==3) ConvexHull(s1, 1), ConvexHull(s2, 1), ConvexHull(s3, 2), ConvexHull(s4, 2); else if(mode==1) ConvexHull(s1, 1), ConvexHull(s2, 1); else if(mode==2) ConvexHull(s3, 2), ConvexHull(s4, 2);}//计算凸包的面积double s_ConvexHull(int n){ double sum = 0; for (int i = 1 ; i &lt; n-2 ; i++) sum += fabs(area_t(Q[0],Q[i],Q[i+1]))/2; return sum;}int main(){ int n, x, y; cin&gt;&gt;n; vector&lt;int&gt; ps(n); for(int i=0; i&lt;n; i++) { cin &gt;&gt; P[i].x &gt;&gt; P[i].y; ps[i]=i; } sort(P, P + n, cmp); ConvexHull(ps, 3); mysort_P(P, n); cout&lt;&lt;&quot;ConvexHull's area is:&quot;&lt;&lt;s_ConvexHull(n); return 0;} 背包问题 蛮力法 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define M 20int max_value = 0;int max_weight = 0;int max_a[M];int k = 0;void print(int n){ sort(max_a , max_a + n); cout &lt;&lt; &quot;获胜者所选取的商品编号为：&quot;; for (int i = 0 ; i &lt; n ;i++) cout &lt;&lt; max_a[i]&lt;&lt;&quot;\\t&quot;; cout &lt;&lt; endl&lt;&lt;&quot;获胜者所能选取的商品的总重量和总的价格为：&quot; &lt;&lt; max_weight&lt;&lt;&quot;\\t&quot;&lt;&lt;max_value &lt;&lt; endl;}void sum(int a[] ,int n , int m , int object[M][2]){ int value = 0; int weight = 0; int i = 0; for (; i &lt; n+1; i++) { if (weight &gt; m)break; weight += object[a[i] - 1][0]; value += object[a[i] - 1][1]; } k = i; value = value - object[a[i - 1] - 1][1]; weight = weight - object[a[i - 1] - 1][0]; if (value &gt; max_value){ max_value = value; max_weight = weight; for (int j = 0; j &lt; i-1; j++) max_a[j] = a[j]; }}void Prem(int a[] , int start , int end , int m, int object[M][2]){ if (start == end)sum(a,end+1,m,object);//递归结束条件 else { for (int i = start; i &lt;= end; i++) { swap(a[start], a[i]);//全排列时start的后位依次做第一位 Prem(a, start + 1, end , m , object); swap(a[start], a[i]);//换回来才能保证下一次交换 } }}int main(){ int m, n; int a[M]; cout &lt;&lt; &quot;输入商场中商品的数量:&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;输入小车能装载的最大装载量:&quot;;cin &gt;&gt; m; for (int i = 0; i &lt; n; i++) a[i] = i + 1; int object[M][2]; cout &lt;&lt; &quot;输入每种商品的重量和价格:&quot;&lt;&lt;endl; for (int i = 0 ; i &lt; n ; i++) for (int j = 0; j &lt; 2; j++) cin&gt;&gt;object[i][j]; Prem(a,0, n-1 , m , object);//寻找各种可能结果 print(k);//打印 return 1;} TSP旅行商问题 蛮力法 文字描述 无 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;#define M 20int MIN = 1000;//用于计算最短路径int min_a[M];//用于保存最短路径编号void print(int n){ cout &lt;&lt; &quot;最短路径为：&quot;; for (int i = 0; i &lt; n; i++)cout &lt;&lt; min_a[i] &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;这条路长：&quot; &lt;&lt; MIN;}void sum(int a[] , int d[M][M] ,int n , int m){ int sum = d[m-1][a[0]-1]; for (int i = 0; i &lt; n; i++){ if (i == n - 1) sum += d[a[i]-1][m-1]; else sum += d[a[i]-1][a[i + 1]-1]; } if (sum &lt; MIN){ MIN = sum; for (int i = 1; i &lt; n+1; i++) min_a[i] = a[i-1]; }}//全排列void Prem(int a[] , int d[M][M] , int start , int end , int m){ if (start == end)sum(a,d,end+1,m);//递归结束条件 else { for (int i = start; i &lt;= end; i++) { swap(a[start], a[i]);//全排列时start的后位依次做第一位 Prem(a, d ,start + 1, end ,m); swap(a[start], a[i]);//换回来才能保证下一次交换 } }}int main(){ int n, m; int a[M],d[M][M]; cout &lt;&lt; &quot;输入待旅行的城市数量:&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;输入旅行者出发的城市编号:&quot;;cin &gt;&gt; m; for (int i = 0 ; i &lt; n-1 ;i++){ a[i] = i + 1; if (a[i] &gt; m-1)a[i] = i+2; } cout &lt;&lt; &quot;输入城市之间的距离：&quot;&lt;&lt;endl; for (int i = 0 ; i &lt; n ;i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; d[i][j]; min_a[0] = m;min_a[n] = m; Prem(a, d, 0 ,n-2 ,m); print(n+1); return 0;} 动态规划 文字 用邻接矩阵g来表示各城市间的距离，问题可抽象为:从结点s出发，令d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。 当V为空集，那么d(i,V)表示直接从i回到s，此时d(i,V) = g[i][s]。 如果V不为空，那么就是对子问题的最优求解，必须在V这个城市集合中，尝试每一个，并求出最优解。 在求解d(i, V)时，必须在V中找出这样一个结点k，它满足(从i到k的距离 + 从k出发经过 V-(k)这个集合回到s)是V的所有结点中最小的。 可得出状态转移方程：d(i,V) = min(g[i][k] + d(k,V–(k)))，其中k代表遍历当前V集合中所有的城市。 综上，可得出动态规划方程： ![img](file:///C:/Users/NILI99~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png) 其中s为起点。 用代码实现时，由于V的状态有很多种，因此考虑采用状态压缩的办法表示V，即用数的二进制状态来表示V，第i个二进制位为0就代表V中没有i，为1则代表有。例如(5)D = (101)B, 代表V中的城市有0和2，而没有1，(7)D = (111)B, 代表V中的城市有0、1、2。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define INF 10e7int n, m;//保存顶点i到状态s最后回到起始点的最小距离int dp[10001][10001];//核心函数，求出动态规划dp数组void TSP(int **a){ //初始化dp[i][0] for (int i = 0; i &lt; n; i++) { dp[i][0] = a[i][0]; } //求解dp[i][j],先跟新列在更新行 for (int j = 1; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { dp[i][j] = INF; //如果集和j(或状态j)中包含结点i,则不符合条件退出 if (((j &gt;&gt; (i - 1)) &amp; 1) == 1) { continue; } for (int k = 1; k &lt; n; k++) { if (((j &gt;&gt; (k - 1)) &amp; 1) == 0) { continue; } if (dp[i][j] &gt; a[i][k] + dp[k][j ^ (1 &lt;&lt; (k - 1))]) { dp[i][j] = a[i][k] + dp[k][j ^ (1 &lt;&lt; (k - 1))]; } } } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); int** a,bestc; cin &gt;&gt; n; a = new int* [n + 1]; for (int i = 0; i &lt;= n; i++) a[i] = new int[n + 1]; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) { cin &gt;&gt; a[i][j]; a[j][i] = a[i][j]; } for (int i = 0; i &lt; n; i++) a[i][i] = 0; m = 1 &lt;&lt; (n - 1); TSP(a); cout &lt;&lt; &quot;TSP: &quot; &lt;&lt; dp[0][m - 1] &lt;&lt; endl; fclose(stdin); return 0;} 因子分解 分治法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;math.h&gt;#define M 10using namespace std;int a[M];int i,m;void show(int n){ int i = 0; cout&lt;&lt;n&lt;&lt;&quot; = &quot;&lt;&lt;a[i++]; while(a[i]){ cout&lt;&lt;&quot; * &quot;&lt;&lt;a[i]; a[i++] = 0; } cout&lt;&lt;endl;}void fun(int x,int b){ if(x == 1 &amp;&amp; a[0])//递归退出 { show(m); return; } int y = 2; while(y &lt;= x) { if(!(x%y)){ a[b] = y; fun(x/y,b+1); } y++; }}int main(){ int n; cin&gt;&gt;n; m = n; fun(n,0); return 0;} 格雷码 分治法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;#define N 10int a[N][N];void show(int n){ for(int i = 0 ; i &lt; pow(2,n) ; i++) { for(int j = 0 ; j &lt; n ; j++) cout&lt;&lt;a[i][j]; cout&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}void Gray(int n){ if(n==1) //退出递归 { a[0][0] = 0;a[1][0] = 1; return; } int m = pow(2,n); for(int i=0; i&lt;m/2; i++) { a[i][n-1] = 0;//第一排为0 a[m-i-1][n-1] = 1; //第二排为1 } Gray(n-1); //格雷码拼接操作 for(int i=m/2; i&lt;m; i++) for(int j=0; j&lt;n-1; j++) a[i][j] = a[m-i-1][j];}int main(){ int n; cin&gt;&gt;n; Gray(n); show(n); return 0;} 最大子矩阵 动态规划 文字描述 采用自顶向下的思想进行递推。从初始的m x n矩阵开始，对矩阵进行求和，并与不同方向的m x (n-1)和(m-1) x n 矩阵进行递推和比较，在寻找过程中设置book数组保存访问状态和子矩阵的和，最终返回最大值。 阶段：当前子矩阵的左上角坐标为start_x, start_y 状态：当前子矩阵的size为m x n 阶段目标：book[a[start_x][ start_y],m,n]表示当前的值,为左上角坐标为start_x,start_y的m x n矩阵的最大的子矩阵和。 状态转移方程:book[a[start_x][ start_y],m,n] = max{ book[a[start_x][ start_y],m,n],book[a[start_x][ start_y],m-1,n],book[a[start_x+1][ start_y],m-1,n], book[a[start_x][ start_y],m,n-1],book[a[start_x][ start_y+1],m,n-1]} 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int row,col;int a[105][105];struct Books{ int sum; int flag=0;}book[105];int fun(int start_x,int start_y,int m , int n){ if(!m||!n||start_x+m&gt;row||start_y+n&gt;col) return 0; if(m==1 &amp;&amp; n == 1 ) return a[start_x][start_y]; if(book[a[start_x][start_y]+10*m+100*n].flag==1) return book[a[start_x][start_y]+10*m+100*n].sum; int temp_sum=0; for(int i = start_x ; i &lt; start_x+m ; i++) for(int j = start_y ; j &lt; start_y+n ; j++) temp_sum += a[i][j]; book[a[start_x][start_y]+10*m+100*n].sum = temp_sum; book[a[start_x][start_y]+10*m+100*n].flag=1; return max({temp_sum, fun(start_x+1,start_y,m-1,n), fun(start_x,start_y,m-1,n), fun(start_x,start_y,m,n-1), fun(start_x,start_y+1,m,n-1)});}int main() { cout&lt;&lt;&quot;input row,col: &quot;; cin &gt;&gt; row &gt;&gt; col; for(int i = 0; i &lt; row ; i++) for(int j = 0 ; j &lt; col ; j++) cin&gt;&gt;a[i][j]; cout &lt;&lt; &quot;max:&quot; &lt;&lt; fun(0, 0, row, col) &lt;&lt; endl; return 0;} 数字三角形 动态规划 文字描述 先根据元素个数填充三角形，行数为求解T=n*(n+1)/2的向上取整结果。若不能构成完整的数字三角形，空位补0。 行数为 n的三角形路径之和的最大值，可看做行数为n-1的三角形路径之和的最大值加上顶层。先求出第n-1阶段(第n-1行上各点)到第n行的最大和，再依次求出第n-2阶段、第n-3阶段……第1阶段(起始点)各决策点至第n行的最佳路径。按照自底向上的思想编写代码。 阶段：当前所在塔的层数i 状态：当前所在某层的位置j 阶段目标：f[i,j]表示当前的值,为从第i阶段中的点j至第n行的最大的数字和。 状态转移方程：f[i][j]=f[i][j]+max(f[i+1][j],f[i+1][j+1]) ​ 图示分析： n=5 9+max(50,49)=59 n=4 12+max(38,34)=50 15+max(34,29)=49 n=3 10+max(21,28)=38 6+max(28,19)=34 8+max(19,21)=29 n=2 2+max(19,7)=21 18+max(7,10)=28 9+max(10,4)=19 5+max(4,16)=21 n=1 19 7 10 4 16 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &quot;math.h&quot;using namespace std;int dp[105][105];//动规矩阵，存放每次结果int main() { int T;//T表示元素个数 cin&gt;&gt;T; int n;//n表示层数 n = ceil((sqrt(1+8*T)-1)/2.0); cout&lt;&lt;&quot;n: &quot;&lt;&lt;n&lt;&lt;endl; int k = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cin &gt;&gt; dp[i][j]; k++; if(k&gt;T) break; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } //自底向上动态规划 for (int i = n - 1; i &gt;= 1; i--) { for (int j = 1; j &lt;= i; j++) { dp[i][j] += max(dp[i + 1][j], dp[i + 1][j + 1]); } } cout&lt;&lt;&quot;dp is &quot;&lt;&lt;endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cout&lt;&lt;&quot;max : &quot;&lt;&lt;dp[1][1]&lt;&lt;endl; return 0;} 最长递增子序列 动态规划 文字描述 算法思想： 阶段：当前子序列长度为i 阶段目标：L[i]表示当前序列的最长递增子序列长少-1（L[i]初始值为0） 状态转移方程:if(a[i]&gt;a[j])then L[i]=max{L[j]}+1(j:1ài)，否则L[i]值不变。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int max_long=-9999;int dp_long[105];void find_long(int a[], int n){ for (int i = 0; i &lt; n; i++){ for (int j = 0; j &lt; i; j++) { if (a[i] &gt; a[j] &amp;&amp; dp_long[i] &lt; dp_long[j] + 1) dp_long[i] = dp_long[j] + 1; } } for (int i = 0; i &lt; n; i++) { if (dp_long[i] &gt; max_long) max_long = dp_long[i]; }}int main(){ int n; cin&gt;&gt;n; int a[105]; for(int i = 0 ; i &lt; n ;i++) cin&gt;&gt;a[i]; find_long(a,n); cout &lt;&lt; max_long+1 &lt;&lt; endl; return 0;} 图结点着色 回溯 文字描述 该题实质为图结点的着色问题。可以具体抽象为：输入无向连通图的各节点和其连接的点，找一种需要最少颜色的着色法使图中每条边的2个顶点着不同颜色。 输入设计：关键在于从字符串到邻接矩阵的转换。先使用s.erase(s.find('😂,1)去除字符串的”:”,然后使用if(s[j]&amp;&amp;(s[j]-s[0]))c[i][s[j]-s[0]+i]=1 的判断语句转换成邻接矩阵。 回溯设计：在图着色问题的解空间树中，如果从根结点到当前结点对应一个部分解，也就是所有的颜色指派都没有冲突，则在当前结点处选择第一棵子树继续搜索，也就是为下一个顶点着颜色1，否则，对当前子树的兄弟子树继续搜索，也就是为当前顶点着下一个颜色，如果所有m种颜色都已尝试过并且都发生冲突，则回溯到当前结点的父结点处，上一个顶点的颜色改变，以此类推。具体描述： 1.将数组color[n]初始化为0并令k=1; 2.while(k&gt;=1)：a)依次考察每一种颜色，若顶点k的着色与其他顶点的着色不发生冲突，则转步骤b；否则，搜索下一个颜色；b)若顶点已全部着色，则输出数组color[n]，返回。c)若顶点k是一个合法着色，则k=k+1,处理下一个顶点；否则，重置顶点k的着色情况，k=k-1，转步骤c）。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &quot;algorithm&quot;using namespace std;int n;//城市数int m;//当前着色数int c[10][10];int color[10];int ok(int k){ int i; for(i=0;i&lt;k;i++) if(c[k][i]==1&amp;&amp;color[i]==color[k]) return 0; return 1;}//法1void GraphColor(int n){ int i,k; for(i=0;i&lt;n;i++)color[i]=0; k=0; while(k&gt;=0) { color[k]=color[k]+1; while(color[k]&lt;=n) { if(ok(k)==1)break; else color[k]=color[k]+1; } //深度到n,着色完全 if(color[k]&lt;=n&amp;&amp;k==n) { sort(color,color+n); cout&lt;&lt;color[n-1]&lt;&lt;endl; return; } //深度不到n，节点下移 else if(color[k]&lt;=n&amp;&amp;k&lt;n)k=k+1; //回溯，着色未完全,返回父节点 else { color[k]=0; k=k-1; } }}//法2void dfs(int step){ if(step==n)//着色数=城市数 { sort(color,color+n); cout&lt;&lt;color[n-1]&lt;&lt;endl; exit(0); } else { for(int i=0;i&lt;n;i++) { color[step]=i+1; if(ok(step))dfs(step+1); color[step]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n; string s; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s; s.erase(s.find(':'),1); for(int j=0;j&lt;n;j++) { if(s[j]&amp;&amp;(s[j]-s[0]))c[i][s[j]-s[0]+i]=1; } }// for(int i=0;i&lt;n;i++)// {// for(int j=0;j&lt;n;j++)// cout&lt;&lt;c[i][j]&lt;&lt;&quot; &quot;;// cout&lt;&lt;endl;// } // GraphColor(n); dfs(0); fclose(stdin); return 0;} 集合找和为C 文字描述 回溯设计： 目标函数：sum+=out[k],sum=t&amp;k=n；约束条件：sum&lt;t，k&lt;n；限界函数：sum&lt;t,k&lt;n 具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件： sum&lt;t&amp;k&lt;n，继续dfs到下一层 sum=t&amp;k=n，输出 sum&gt;t||k&gt;n，进行剪枝并回溯到上一层。 去除重复输出设计:将每次回溯所得的结果存入二维数组out_comp中，其中i表示结果序号，即存回溯得到的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &quot;algorithm&quot;using namespace std;int c,n;vector&lt;int&gt; s;//inputint sum,k,out[10000],book[10000];int out_comp[10000][10000];//去重复int num;//记录解个数//去重复结果bool fun_row(int *a, int *b){ for(int i=0;i&lt;n;i++) if(a[i] != b[i]) return false; return true;}bool fun(){ for(int p=0;p&lt;10000;p++) if(fun_row(out, out_comp[p]))return true; return false;}void output(){ int n=0,m=0; if(!fun())//输出不重复的结果 { while (out[n]) { cout&lt;&lt;out[n]&lt;&lt;&quot; &quot;; out_comp[num][m] = out[n]; m++;n++; } num++; cout &lt;&lt; endl; } return;}void backtrack(int step){ if(sum == c &amp;&amp; k== n) { output(); return; } if(sum&gt;c || k&gt;n) return; for(int i=0;i&lt;s.size();i++) { if(!book[i] &amp;&amp; (s[i]&lt;=out[k-1]||k==0)) { //存入out out[k]=s[i]; sum+=out[k]; book[i]=1; k++; //向下dfs backtrack(step+1); //回退 k--; sum-=out[k]; book[i]=0; out[k]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;c&gt;&gt;n; if(n&lt;0||n&gt;10000) { cout&lt;&lt;&quot;worry input n!&quot;&lt;&lt;endl; return 0; } int temp; while(cin&gt;&gt;temp)s.push_back(temp); sort(s.begin(),s.end(),greater&lt;int&gt;()); backtrack(0); if(!num) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; fclose(stdin); return 0;} 构成最小倍数 分支界限 文字描述 本题主要采用了BFS(广度优先搜索)+剪枝回溯的思路编写程序。主要使用了数组来存m位不同的十进制数字，使用队列来进行BFS的搜索的数据结构类型。为找寻最小倍数，先将输入的数组x进行升序排序，因为x数组中的数据可以重复使用，所以每次拓展活结点时，其子节点为x[]中的所有元素。找到则退出，没有找到则继续在该层遍历，然后拓展下一层继续按层寻找。 具体算法设计为：1.先对输入的数据进行判断，若x[i]%n=0，即单位输入的数字即为自然数n的最小倍数，则直接输出，退出程序。2.若没有，则非零元素按大小依次进入队头。3.遍历组合队头元素的每个活结点，out=front*10+x[i]，若out[i]%n=0，代表找到，输出并退出程序，否则，队头元素出队并将out入队作为下一层拓展遍历的活结点。4.若out&gt; pow(2,32)-1,表示查找失败，输出0且退出程序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &quot;algorithm&quot;#include &quot;queue&quot;using namespace std;int n,m,*x;//input__int32 out;queue&lt;int&gt; q;int front;void backtrack()//bfs广度搜索{ for(int i=0;i&lt;m;i++) { if(x[i]) { if(!(x[i]%n)) { cout&lt;&lt;x[i]&lt;&lt;endl; exit(0); } q.push(x[i]); } } while(!q.empty()) { front=q.front(); q.pop(); for(int i=0;i&lt;m;i++) { out=front*10+x[i]; if(!(out%n)) { cout&lt;&lt;out&lt;&lt;endl; exit(0); } if(out&gt;pow(2,32)-1)return ; q.push(out); } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m; int i; x=new int[m]; for(i=0;i&lt;m;i++)cin&gt;&gt;x[i]; sort(x,x+m); backtrack(); cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; fclose(stdin); return 0;} 贪心法求解最优服务次序 文字描述 算法思想：利用贪心的思想，优先服务需要时间少的顾客，直到最后。运用到了队列的数据结构。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &quot;vector&quot;#include &lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int wait_pos[101][101];int main(){ freopen(&quot;../input&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; int s; cin&gt;&gt;s; vector&lt;int&gt; t_temp; int temp; while(cin&gt;&gt;temp) t_temp.push_back(temp); sort(t_temp.begin(), t_temp.end(), greater&lt;int&gt;()); queue&lt;int&gt; t; while(!t_temp.empty()) { t.push(t_temp.back()); t_temp.pop_back(); } int j=0; //排位置 while(!t.empty()) { for(int i=0;i&lt;s;i++){ if(t.empty()) break; wait_pos[i][j] = t.front(); t.pop(); } j++; } //找时间并输出 int sum=0; for(int i=0;i&lt;s;i++) { int k=1; cout&lt;&lt;i+1&lt;&lt;&quot;:&quot;&lt;&lt;wait_pos[i][0]&lt;&lt;&quot; &quot;; while(k&lt;j &amp;&amp; wait_pos[i][k]) { cout&lt;&lt;wait_pos[i][k]&lt;&lt;&quot; &quot;; for(int z=0;z&lt;k;z++)sum+=wait_pos[i][z]; k++; } cout&lt;&lt;endl; } cout&lt;&lt;(double)sum/n&lt;&lt;endl; return 0;} 自然数分解积最大问题 文字描述 算法思想：贪心的想使每个分解出来的数尽可能的接近，因此得到的乘积最小。采取的策略：设n的加数为2+3+…+m+k;m为最大加数，k为剩余的数(k&lt;=m)；然后将k分到其他数中，策略就是从m-&gt;2的数值一次加一，直至把k消耗完。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;int a[1000];int main(){ freopen(&quot;../input&quot;, &quot;r&quot;, stdin); int n; cin&gt;&gt;n; int sum = 0, m = 0, k; //找最大加数a[m-1] for (int i = 2; i &lt;= n; i++) { a[m++] = i; sum += i; if (sum &gt; n) { sum -= i; m--; k = n - sum;//余数k break; } } //cout&lt;&lt;&quot;a[m-1]:&quot;&lt;&lt;a[m-1]&lt;&lt;&quot;\\t&quot;&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;endl; //消耗余数 for (int i = m - 1; k; k--) { a[i]++; i--; if (i &lt; 0) i = m - 1; } //输出和累乘 int out=1; for (int i = 0; i &lt; m; i++) { cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;; out *= a[i]; } cout&lt;&lt;endl&lt;&lt;out; return 0;} 贪心法最大删除数字问题 文字描述 该算法同样涵盖了贪心算法的思想，根据分析，应当优先清除高位的小数，这样就可以带来局部最优解。所以从最高位开始寻找，从左到右依次遍历s[i]，若s[i]&lt;s[i+1]，则删除s[i]，并且缩短一位即可；若未找到，直接将len=len-1，即删除最后一位，输出即可。根据验证，此方法得到的解即为全局最优解。 最终，标记第一位非0的字符，从该位开始输出，得到的结果即为删除后的最大整数。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 10002int main(){ int k,len,flag,i,j; char s[MAX]={0}; gets(s); len=strlen(s); scanf(&quot;%d&quot;,&amp;k); while(k) { for(i=0;i&lt;len-1;i++) { if(s[i]&lt;s[i+1]) { for(j=i;j&lt;len-1;j++) { s[j]=s[j+1]; } len--; break; } } if(i==len-1) { len--; } k--; } for(i=0;i&lt;len;i++) { if(s[i]!='0') { flag=i; break; } } for(i=flag;i&lt;len;i++) { printf(&quot;%c&quot;,s[i]); } return 0;} 迷宫问题的分支界限 文字 约束条件：箱子没有撞墙、机器人没有撞墙、位置不重复（若重复则代表一定有更少的解决步骤）。程序中将可以走的位置全部用0来代表，不能走的位置用1来代表，因此撞墙的约束条件可用如下式子来判断： if (maze[next.bx][next.by] == 0 //箱子所在位置不是墙 ​ &amp;&amp; maze[next.px][next.py] == 0) //&amp;&amp;人所在位置不是墙 箱子和机器人的位置用一个四维数组来存储，四维分别是箱子和人的行、列下标，则位置不重复的约束条件： if (used[next.bx][next.by][next.px][next.py] == 0) //节点不重复 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAX = 20;char maze[MAX][MAX];struct node{ int px, py; //箱子位置 int bx, by; //人位置 bool useful; //本节点是否有效}; //无效条件：箱子越界、撞墙、节点重复int n, m; //n行m列node start;int tx, ty; //目标位置queue &lt;node&gt; q1;int used[MAX][MAX][MAX][MAX]; //判重数组int step[MAX][MAX][MAX][MAX]; //步数数组int walk[4][2] = //走一步后的新坐标变化{ 0, -1, //左 +1, 0, //下 0, +1, //右 -1, 0 //上};void input();int bfs();node moveto(node cur, int i); //返回人向i方向走一格的新节点int main(){ input(); cout &lt;&lt; bfs() &lt;&lt; endl; return 0;}void input(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin&gt;&gt;maze[i][j]; //将数字按字符读入，再转换成数字 switch (maze[i][j]) { case '#': maze[i][j] = 1; break; case '.': maze[i][j] = 0; break; case 'B': //箱子 { start.bx = i; start.by = j; maze[i][j] = 0; //将此处标记为0，意为“可以走” break; } case 'T': //目标位置 { tx = i; ty = j; maze[i][j] = 0; //同上 break; } case 'S': //人 { start.px = i; start.py = j; maze[i][j] = 0; //同上 break; } default:break; } } } //标记初始节点并入队 used[start.bx][start.by][start.px][start.py] = 1; step[start.bx][start.by][start.px][start.py] = 0; q1.push(start); fclose(stdin);}int bfs(){ node cur, next; while (!q1.empty()) { cur = q1.front(); q1.pop(); for (int i = 0; i &lt; 4; i++) //人向4个方向试探 { next = moveto(cur, i); //返回扩展所得的新节点 if (next.useful) //若该节点有效 { if (next.bx == tx &amp;&amp; next.by == ty) //判断箱子是否到达目标位置 { return step[next.bx][next.by][next.px][next.py]; } else //还未到达，新节点入队 { q1.push(next); } } } } return -1; //无法到达，返回-1}//节点无效条件：箱子或人越界、箱子或人撞墙、节点重复node moveto(node cur, int i){ node next; bool moved = false; //判断箱子是否移动 next.bx = cur.bx; //箱子位置暂时不动 next.by = cur.by; next.px = cur.px + walk[i][0]; //人向i方向移动一格 next.py = cur.py + walk[i][1]; if (next.px == next.bx &amp;&amp; next.py == next.by) //若此时人与箱子位置重叠 { next.bx += walk[i][0]; //那么箱子也要向i方向移动一格 next.by += walk[i][1]; moved = true; } //判断新节点next是否有效 next.useful = false; //初始为无效 if (maze[next.bx][next.by] == 0 //箱子所在位置不是墙 &amp;&amp; maze[next.px][next.py] == 0) //&amp;&amp;人所在位置不是墙 { if (used[next.bx][next.by][next.px][next.py] == 0) //节点不重复 { next.useful = true; //同时满足上述条件，该节点才有效 //标记“到达过” used[next.bx][next.by][next.px][next.py] = 1; //根据箱子是否移动来修改步数 if (moved) { step[next.bx][next.by][next.px][next.py] = 1 + step[cur.bx][cur.by][cur.px][cur.py]; } else { step[next.bx][next.by][next.px][next.py] = step[cur.bx][cur.by][cur.px][cur.py]; } } } return next; //返回新节点} 迷宫最长回路的分支界限 文字描述 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cerrno&gt;using namespace std;namespace LongestRoute{ struct block { int x; int y; int state; int visit[2]; block(int x = 0, int y = 0, int state = 0) { this-&gt;x = x; this-&gt;y = y; this-&gt;state = state; this-&gt;visit[0] = this-&gt;visit[1] = 0; }; }; int n = 0; int m = 0; vector&lt;vector&lt;block&gt;&gt; map; int direction[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1},};//上， 右， 下， 左 int longest_route = 0; int root_x; int root_y;};using namespace LongestRoute;void create_map(){ cin&gt;&gt;n&gt;&gt;m; string cur_str; for(int i = 0; i &lt; n; i++) { vector&lt;block&gt; cur_block_array; cin&gt;&gt;cur_str; for(int j = 0; j &lt; m; j++) { switch (cur_str[j]) { case '/': cur_block_array.emplace_back(block(i, j , 0)); break; case '\\\\': cur_block_array.emplace_back(block(i , j , 1)); break; default: fprintf(stderr, &quot;input error at (%d, %d), input is : %c \\n&quot;, i, j, cur_str[j]); exit(0); } } map.emplace_back(cur_block_array); }}void search_longest_route(int x, int y, int position, int cur_route_length){ //由于每个在分支限界中每个节点只有一次成为最优解的机会，故当一个节点被搜索过后，它不再有再次被置入搜索栈的资格 if(x == root_x &amp;&amp; y == root_y &amp;&amp; cur_route_length != 1) { if(cur_route_length - 1&gt; longest_route) { longest_route = cur_route_length - 1; cout&lt;&lt;&quot;update longest_route : &quot;&lt;&lt;longest_route&lt;&lt;endl; } return; } for(int i = 0; i &lt; 4; i++) { int cur_x = x + direction[i][0]; int cur_y = y + direction[i][1]; int cur_position = -1; if(cur_x &lt; 0 || cur_x &gt;= n || cur_y &lt; 0 || cur_y &gt;= m) { continue; } if(i == 0 || i == 2) { if(map[x][y].state != map[cur_x][cur_y].state) { if(i == 0 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 1; else if(i == 0 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 0; else if(i == 2 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 1; else if(i == 2 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 0; }else { if(i == 0 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 2 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 0 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 2 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; } } else { if(map[x][y].state^map[cur_x][cur_y].state) { if(i == 1 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 1 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 3 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 3 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; }else { if(i == 1 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 1) cur_position = 0; else if(i == 1 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 1) cur_position = 0; else if(i == 3 &amp;&amp; map[x][y].state == 0 &amp;&amp; position == 0) cur_position = 1; else if(i == 3 &amp;&amp; map[x][y].state == 1 &amp;&amp; position == 0) cur_position = 1; } } if(cur_position != -1 &amp;&amp; map[cur_x][cur_y].visit[cur_position] == 0) { cout&lt;&lt;&quot;(&quot;&lt;&lt;cur_x&lt;&lt;&quot;,&quot;&lt;&lt;cur_y&lt;&lt;&quot;,&quot;&lt;&lt;cur_position&lt;&lt;&quot;)&quot;&lt;&lt;endl; map[cur_x][cur_y].visit[cur_position] = 1; search_longest_route(cur_x, cur_y, cur_position, cur_route_length + 1); } }}int main(){ freopen(&quot;../input&quot;, &quot;r+&quot;, stdin); create_map(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { for(int k = 0; k &lt; 2; k++) { if(!map[i][j].visit[k]) { root_x = i;root_y = j; search_longest_route(i, j, k, 1); map[i][j].visit[k] = 1; } } } } cout&lt;&lt;&quot;Longest Route Length : &quot;&lt;&lt;longest_route&lt;&lt;endl; return 0;} 回溯法求和因子 文字 输入设计：while(cin&gt;&gt;t)直到n=0跳出输入，结束程序 回溯设计： 目标函数：sum+=out[k],sum=t; 约束条件：sum&lt;t,out[k]的k&lt;=n,即加数不超过n 限界函数：sum&lt;t 具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件： sum&gt;t，继续dfs到下一层 sum=t，输出 sum&gt;t，进行剪枝并回溯到上一层。 去除重复后输出结果:将每次回溯所得的结果存入二维数组out_comp[i][j]中，其中i表示结果序号，即存回溯的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include&quot;string.h&quot;#include &quot;algorithm&quot;using namespace std;int t,n,list[12];//inputint out[12],out_comp[100][12];//outputint sum=0;int book[12];int num=0;//保存结果数int k=0;//去重复结果bool fun_row(int *a, int *b){ for(int i=0;i&lt;12;i++) if(a[i] != b[i]) return false; return true;}bool fun(){ for(int p=0;p&lt;100;p++) if(fun_row(out, out_comp[p]))return true; return false;}void output(){ int n=1,m=1; if(!fun())//输出不重复的结果 { cout&lt;&lt;out[0]; out_comp[num][0] = out[0]; while (out[n]) { cout &lt;&lt; &quot;+&quot;&lt;&lt;out[n]; out_comp[num][m] = out[n]; m++;n++; } num++; cout &lt;&lt; endl; } return;}void backtrack(int step){ if(sum == t) output(); if(sum&gt;t)return; for(int i=0;i&lt;n;i++) { if(!book[i] &amp;&amp; (list[i]&lt;=out[k-1]||k==0))//没有访问过且要求降序 { //存入out out[k]=list[i]; sum+=out[k]; book[i]=1; k++; //dfs向下搜索 backtrack(step+1); //回退 k--; sum-=out[k]; book[i]=0; out[k]=0; } }}int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;t) { //输入设置 if(t&gt;1000 || t &lt; 0) { cout&lt;&lt;&quot;worry input t&quot;&lt;&lt;endl; continue; } cin&gt;&gt;n; if(n == 0) { cout&lt;&lt;&quot;end&quot;&lt;&lt;endl; exit(0); } if(n&gt;12 || n&lt;1) { cout&lt;&lt;&quot;worry input n&quot;&lt;&lt;endl; continue; } int i,flag=1; for(i=0;i&lt;n;i++) { int j; cin&gt;&gt;j; list[i] = j; if(list[i]&gt;100 || list[i]&lt;0) { cout&lt;&lt;&quot;worry input list[i]&quot;&lt;&lt;endl; flag = 0; } } if(!flag)continue; //output cout&lt;&lt;&quot;result :&quot;&lt;&lt;endl; //初始化 sum=num=k=0; memset(book,0,12*sizeof(int)); memset(out,0,12*sizeof(int)); for(int i=0;i&lt;100;i++) memset(out_comp[i],0,12*sizeof(int)); //回溯 sort(list,list+n,greater&lt;int&gt;()); backtrack(0); if(num==0)cout&lt;&lt;&quot;NONE&quot;&lt;&lt;endl; } fclose(stdin); return 0;} 贪心算法解任务调度器 文字 任务调度分配的最短时间由任务数最多的任务所决定，设最多的任务数有max个，有max个任务数的任务共num个，任务总数为sum。则在任务之间的max-1个间隔贪心的插入n*( max-1)个任务(可能含待命)。最后计算最终调度时间：当需要插入的个数大于可插入利用的最大个数时，除任务A本身和间隔，需在末尾补上余下的num-1个任务，因此最短时间为max+ n*(max-1)+num-1。否则最短调度时间为任务总数sum。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &quot;string.h&quot;using namespace std;int main(){ freopen(&quot;../input&quot;,&quot;r&quot;,stdin); string s; cin&gt;&gt;s; int n; cin&gt;&gt;n; int task[26]; //初始化 memset(task,0,26*sizeof(int)); //任务统计 for(int i = 0; i &lt; s.size(); i++) task[s[i]-'A']++; //统计max和max个数num int mymax = 0,num = 0; for(int i = 0; i &lt; 26; i++) { if(mymax &lt; task[i]) { mymax =task[i]; num=0; } if(mymax == task[i] )num++; } cout &lt;&lt; max((int)s.size(), (mymax + (mymax - 1) * n + num - 1)) &lt;&lt; endl; return 0;} 二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;#define M 10int m,n;bool binarySearch(int matrix[M][M], int i, int target){ int left = 0, right = n; while(left &lt; right) { int mid = left + (right - left)/2; if(target &gt; matrix[i][mid]) left = mid + 1; else if(target &lt; matrix[i][mid]) right = mid; else return true; } return false;}//不成熟的二分尝试1bool searchMatrix(int matrix[M][M], int target) { for(int i = 0; i &lt; m; ++i) if(binarySearch(matrix, i, target)) return true; return false;}//最后采用的二分法int searchMatrix_(int matrix[M][M], int target, int bottle_r , int bottle_c) { if(matrix[bottle_r][bottle_c] == target) return 1; if(bottle_r==m || bottle_c==n || bottle_c==-1|| bottle_r==-1)return 0; else if(matrix[bottle_r][bottle_c] &gt; target) searchMatrix_(matrix, target, bottle_r-1 , bottle_c); else searchMatrix_(matrix, target, bottle_r , bottle_c+1);}int main() { cout&lt;&lt;&quot;input m,n:&quot;; cin&gt;&gt;m&gt;&gt;n; int matrix[M][M]; cout&lt;&lt;&quot;input matrix&quot;&lt;&lt;endl; for(int i = 0 ; i &lt; m ; i++){ for(int j = 0 ; j &lt; n ; j++)cin&gt;&gt;matrix[i][j]; } int target; cout&lt;&lt;&quot;input target:&quot;; cin&gt;&gt;target; if(searchMatrix(matrix, target))cout&lt;&lt;&quot;ture&quot;; if(searchMatrix_(matrix, target,m-1,0))cout&lt;&lt;&quot;ture&quot;; return 0;} 时间+快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#define N 100000void quickSort(int *r, int begin, int end){ int i,j; if(begin &lt; end) { i=begin;j=end;r[0]=r[i]; while(i!=j) { while(r[j]&gt;r[0]&amp;&amp;i&lt;j) j--; if(i&lt;j) { r[i]=r[j]; i++; } while(r[i]&lt;r[0]&amp;&amp;i&lt;j) i++; if(i&lt;j) { r[j]=r[i]; j--; } } r[i]=r[0]; quickSort(r, begin, i - 1); quickSort(r, i + 1, end); } else return;}int main(){ clock_t t1,t2; double t; srand((unsigned)time(NULL)); int r[N],i,n; char ch[40]; FILE* fp; fp=fopen(&quot;D:/algorithm/test_2_1.csv&quot;,&quot;w&quot;); for(n=1000;n&lt;=100000;n+=1000)//建立横坐标n { itoa(n,ch,10); strcat(ch,&quot;,&quot;); fwrite(ch,sizeof(char),strlen(ch),fp); } fwrite(&quot;\\n&quot;,sizeof(char),1,fp); for(n=1000;n&lt;=100000;n+=1000)//输入纵坐标t { //生成随机数 for(i=0;i&lt;n;i++) r[i]=rand()%1001; t1=clock();//开始计时 quickSort(r, 1, n - 1); t2=clock();//结束计时 t = (double)(t2-t1)/CLOCKS_PER_SEC*1000; itoa(t,ch,10); strcat(ch,&quot;,&quot;); fwrite(ch,sizeof(char),strlen(ch),fp); } fwrite(&quot;\\n&quot;,sizeof(char),1,fp); fclose(fp); return 0;} 棋盘覆盖 分治 文字 分治法求解棋盘覆盖问题的技巧在于划分棋盘，使划分后的子棋盘的大小相同，并且每个子棋盘均包含一个特殊方格，从而将原问题分解为规模较小的棋盘覆盖问题。 k&gt;0时，可将2k×2k的棋盘划分为4个2k-1×2k-1的子棋盘，这样划分后，由于原棋盘只有一个特殊方格，所以，这4个子棋盘中只有一个子棋盘包含该特殊方格，其余3个子棋盘中没有特殊方格。为了将这3个没有特殊方格的子棋盘转化为特殊棋盘，以便采用递归方法求解，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。 ​ 每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量s来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。其次还要有一个变量nCount来记录L型骨牌的数量。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;#define M 10int t = 0;//全局变量，表示L型骨牌编号int board[M][M];//全局变量，表示棋盘//tr,tc表示棋盘左上角//dr,dc表示表示特殊方格void ChessBoard(int tr , int tc , int dr , int dc , int size){ if(size == 1)return;//棋盘只有一个方格其是特殊方格 int number = ++t;//L型骨牌号 int s = size/2;//划分棋盘 //覆盖左上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr,tc,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s-1][tc+s-1]=number; ChessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)//特殊方格在右上角子棋盘中 ChessBoard(tr,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖左下角，再递归处理子棋盘 board[tr+s-1][tc+s]=number; ChessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在左下角子棋盘中 ChessBoard(tr+s,tc,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右上角，再递归处理子棋盘 board[tr+s][tc+s-1]=number; ChessBoard(tr+s ,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在左上角子棋盘中 ChessBoard(tr+s,tc+s,dr,dc,s);//递归处理子棋盘 else{ //用t号L型骨牌覆盖右下角，再递归处理子棋盘 board[tr+s][tc+s]=number; ChessBoard(tr+s,tc+s,tr+s,tc+s,s); }}int main() { int size , x , y; cout&lt;&lt;&quot;input size and (x,y)&quot;; cin&gt;&gt;size&gt;&gt;x&gt;&gt;y; board[x][y] = 0; ChessBoard(0,0,x,y,size); //输出棋盘 for(int i = 0; i &lt; size; i++) { for(int j = 0; j &lt; size; j++) { cout &lt;&lt; board[i][j] &lt;&lt; &quot;\\t&quot;; } cout &lt;&lt; endl; } return 0;}","link":"/2021/12/06/ALGORITHM-%E6%9C%9F%E6%9C%AB/"},{"title":"ALGPR-1","text":"序 第一周的算法课都讲了什么T.T CM1 TD1 从字符的匹配开始讲的，说了蛮多伪代码的东西，真难看(bushi 字符的匹配 貌似没啥，就是熟悉一下子法语书写的伪代码 L 123456789101112131415Variables://定义变量 Caractère:courant//串，定义为字符类型 Entier:nbL//拿来计数的int Début nbL &lt;- 0 courant &lt;- lire()//这里的读是一个个读 tantque(courant != '.') si(courant == 'L') nbL &lt;- nbL+1 finsi courant &lt;- lire() fintanque afficher(nbL)//输出Fin LE 1234567891011121314151617Variables: Caractère:courant,précédent Entier:nbLE Début nbLE &lt;- 0 précédent &lt;- '.' courant &lt;- lire() tantque(courant != '.') si(courant == 'L' ET courant = 'E') nbLE &lt;- nbLE+1 finsi précédent &lt;- courant courant &lt;- lire() fintanque afficher(nbLE)Fin ELLE 就是把子串固定，然后拿courant去做匹配 以ELELLELLLLEL找ELLE为例 1234567891011121314151617181920212223242526272829303132Variables: Chaine de caractère:courant,motif//motif是子串 Caractère: c Entier: nbMotif Début nbMotif &lt;- 0 afficher(&quot;quel est le motif cherché?&quot;) motif &lt;- lire() //初始化串为...courant[0] pour i de 0 à taille(motif)-2 courant[i] &lt;- '.' finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c //串变成了...E tantque(c != '.') si (courant = motif) nbMotif &lt;- nbMotif+1 finsi //从后往前移 pour i de 0 à taille(motif)-2 courant[i] &lt;- courant[i+1] finpour c &lt;- lire() courant[taille(motif)-1] &lt;- c fintanque afficher(nbMotif)Fin 妙的！时间复杂度的话N*n，可能比用想的的find函数要好哎 实际写的好艰难,string里面真的好多东西哦:( 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main(){ int nbMotif=0; string courant,motif; cin&gt;&gt;courant; cin&gt;&gt;motif; size_t p=0;//注意返回类型 while((p = courant.find(motif,p)) != courant.npos) { nbMotif++; p += motif.size(); } cout&lt;&lt;nbMotif&lt;&lt;endl; return 0;} 老师的奇妙方法 用矩阵还是图的知识来实现匹配(example:LE 123456789101112131415161718192021Variables: Caractère:c Entier: s,ss,x,nbLE Tableau d'Entiers m &lt;- {{0,1,0,2},{0,1,0,2}} Début nbLE &lt;- 0 s &lt;- 0 tantque(s != 2) courant &lt;- lire() x &lt;- 0 si(c == 'L') alors x &lt;- 1 finsi si(c == 'E') alors x &lt;- 2 finsi si(c == '.') alors x &lt;- 3 finsi ss &lt;- m(s,x) si (s = 1 ET x = 2) alors nbLE &lt;- nbLE+1 finsi s&lt;- ss fintanque afficher(nbLE)Fin 时间复杂度的话应该有两部分，一是在写m矩阵那里，然后是主程序。主程序的时间复杂度的话，有个逐个读的n，然后剩下的话我感觉有m^2。—&gt; ? 矩阵长这样 好像是在用s和x来表示前后两次的匹配的结果 但感觉就是时间也多了，空间也给浪费了嘛(；′⌒`) TD题 题 1.1 Points et polygone (enregistrement) On souhaite calculer quelques propri´et´es d’un polygone quelconque (p´erim etre, longueur moyenne des arˆetes, boite englobante). La boite englobante est un rectangle englobant le polygone de cˆot´es paralleles aux axes. Les sommets du polygone sont donn´es (dans l’ordre de parcours du p´erimetre) par leurs coordonn´ees r´eelles dans un plan et le nom du point (caractere). La liste de coordonn´ees est suppos´ee correcte et n’est lue qu’une seule fois. Exemple de fichier a lire : — 1,5 3,7 A — 6,4 4,6 B — 5,8 8,3 C — … — 1,5 3,7 A (dernier sommet a ne pas ajouter dans la structure de donn´ees) Les coordonn´ees du dernier sommet sont ´egales a celles du premier. Ce sommet permet uniquement de d´etecter la fermeture du polygone. Il ne faut pas rentrer ce sommet dans la structure de donn´ees. — Proposez une structure de donn´ee pour stocker le polygone, — Ecrivez l’algorithme principal pour lire le fichier contenant les points du polygone, ´ appeler les fonctions permettant de calculer les propri´et´es demand´ees et afficher les r´esultats a l’´ecran, — Ecrivez les fonctions secondaires pour calculer la longueur du p´erim`etre, calculer la ´ longueur moyenne des arˆetes et d´elimiter la boite englobante. 解 1234567891011121314151617181920Types//应该是在定义结构体 point: enregistrement caratère: nom réel: x réel: y fin_enregistrement tabPoint: tableau de pointAlgorithme principal PolygoneVariables://定义变量 tabPoint polygone,boiteEnglobante réel périmètre, longMoy Début polygone &lt;- lirePolygone(&quot;data.txt&quot;)//读文件 périmètre &lt;- calcuPérimètre(polygone)//周长 longMoy &lt;- périmètre/taille(polygone)//棱边数 boiteEnglobante &lt;- calculBoite(polygone)Fin Algorithme 我想的C++ 不知道能不能成 1234567891011121314151617181920212223struct Point{ char Nom; float x; float y;};float distance(Point A, Point B){ return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}class Polygone{ vecter&lt;Point&gt; PonitsDePolygone; public: //构造函数 Polygone(Point A){PonitsDePolygone.push(A);} //拷贝构造 ou 析构？？？？ float périmètre(); int longMoy();} 结语 KMP,CM和未完成的C++就是明天一定","link":"/2022/02/08/ALGPR-1/"},{"title":"ALGORITHM-算法效率","text":"算法_第二章__算法效率分析 1.算法分析概述 对算法所需要的两种计算机资源：时间资源和空间资源进行估算。 目的是为了设计和选择更好的算法 （1）时间效率 **时间效率：**设输入的元素个数为n,执行该算法的第i步操作记为op（i）,该步骤执行的次数为Cop(i)，则该算法的总执行时间为： T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) （2）时间复杂性 时间复杂性：指执行算法所消耗或占用时间资源的量【程序步数】 ​ 在最坏、最好、平均三种情况下的时间复杂度 （3）例题 1.非递归程序顺序检索：在具有n个元素的数组a[1……n]中找出值等于x的元素的位置 1234567template&lt;class Type&gt;int seqSearch(Type *a, int n, Type x){ for(int i=0;i&lt;n;i++) if (a[i]==x) return i; return -1;} 最坏：T(n) = n 最好：T(n) = 1 平均：Tavg（n）=sum[p(I)T(I)] 变式：设计一个尽可能高效的算法，在长度为n的一维数组a[n]中查找值最大的元素max和最小的元素min，并分析算法的最好、最坏和平均时间复杂度。 123456789void MaxMin(int a[],int n,int &amp;max,int &amp;min){ int I; max=min=a[0]; for(i=1;i&lt;n;i++) if(a[i]&gt;max) max=a[i]; else if(a[i]&lt;min) min=a[i];//【要特别注意这的else！！！】} 最好：是一个递增的，n-1 最坏：递减，2*（n-1） 平均：假设a中有一半元素比max大，a[i]&gt;max执行n-1次，else语句执行（n-1）/2次------&gt;平均3*（n-1）/2次 2.递归程序的时间复杂性分析 123456789float RSum(float list[],const int n){ if (n) //1 { return RSum(list,n-1)+list[n-1]; //? } return 0; //1} T(n) = T(n-1)+2[T(0)=2] 程序步骤不能确切反映程序运行的实际时间 2.渐进 定义：只关心f(n)的阶 **大O表示法：**若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≤c×f(n)，则称f(n)是T(n)的上界，记为：T(n)=O(f(n)) **大Ω表示法：**若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≥c×g(n)，则称g(n)是T(n)的下界，记为：T(n)= Ω(g(n) **Θ表示法：**若存在三个正的常数c1、c2和n0，对于任意n≥n0都有c1×f(n)≥T(n)≥c2×f(n)，则称f(n)与T(n)同阶，记为：T(n)=Θ(f(n)) 求解方法： \\lim_n {t(n)\\over g(n)}=0\\mbox{\\quad \\quad t(n)的增长次数比g(n)小}\\\\ \\lim_n {t(n)\\over g(n)}=c&gt;0\\mbox{\\quad \\quad t(n)的增长次数和g(n)相同}\\\\ \\lim_n {t(n)\\over g(n)}=\\infty\\mbox{\\quad \\quad t(n)的增长次数比g(n)大} 为0时，大O；为无穷时，大Ω；c为Θ 3.时间复杂度 定义：针对指定基本运算，计数算法所做运算次数 例： 123456x=1; for(i=1; i&lt;=n; i++) for(j=1 ; j&lt;=i; j++) for(k=1; k&lt;=j; k++) x++; 执行次数为： ∑i=1n∑j=1i∑k=1j1=∑i=1n∑j=1ij=∑i=1ni(i+1)2=[n(n+1)(2n+1)/6+n(n+1)/2]/2=n3+3n2+2n6\\sum^n_{i=1}\\sum^i_{j=1}\\sum^j_{k=1}1=\\sum^n_{i=1}\\sum^i_{j=1}j=\\sum^n_{i=1}{i(i+1)\\over2}=[n(n+1)(2n+1)/6+n(n+1)/2]/2 \\\\ ={n^3+3n^2+2n\\over6} i=1∑n​j=1∑i​k=1∑j​1=i=1∑n​j=1∑i​j=i=1∑n​2i(i+1)​=[n(n+1)(2n+1)/6+n(n+1)/2]/2=6n3+3n2+2n​ 时间复杂度T(n) = O(n^3) 4.递归的高阶方程的数学分析 先化简再计算 例： 1.汉诺塔问题的递归算法的复杂度分析 代码： 12345678910void Hanoi(int n , A ,B,C){ if(n == 1)MoveOne(n,A,B); else { Hanoi(n-1 , A ,C , B); MoveOne(n,A,C); Hanoi(n-1 , B , A , C); }} M(n) = 2M(n-1)+1 M(n) = Θ(2^n) 2.斐波那契 代码： 1.递归实现 123456int Fibonacci1(int n){ if(n &lt; 0) return -1; if(n &lt;= 0) return (n); else return Fibonacci1(n-1)+Fibonacci1(n-2);} A(n) = A(n-1)+A(n-2)+1 2.迭代法 123456789int Fibonacci2(int n){ int F[n+1]; F[0] = 0; F[1] = 1; for(int i = 2 ; i &lt;= n ; i++) F[i] = F[i-1] + F[i - 2]; return F[n];} 时间复杂度低但空间资源浪费高 A(n) = n - 1 = Θ(n) 3.最优解法 123456789101112int Fibonacci3(int n){ int F , Fa , Fb; Fa = 0 ; Fb = 1 ; for(int i = 2 ; i &lt;= n ; i++) { F = Fa + Fb; Fb = Fa; Fa = F; } return F;}","link":"/2021/12/06/ALGORITHM02/"},{"title":"ALGPR-3","text":"序 ALGPR的第三周 TD TD2_Division euclidienne 1234567891011121314151617181920212223242526272829303132couplEntier qr &lt;- divEuclid(entier n, entier d)Types couplEntiers: enregistrement entier: quotient entier: reste fin_enregistrement Variables couplEntiers qr,inter Début Si(n &lt; d) alors qr.reste &lt;- n; Sinon qr.quotient++; divEuclid(n - d , d); fin_Si retourner qrFinDébut Si(n &lt; d) alors qr.quotient &lt;- 0; qr.reste &lt;- n; Sinon inter &lt;- divEuclid(n - d , d); qr.quotient &lt;- inter.quotient + 1; qr.reste = inter.reste ; fin_Si retourner qrFin TD3_Définition Notion de lien vers une structure de données: ce lien est un type de données à part entière défini par le mot-clé lien, suivi du type lié. Cette notion de lien sera traduite(翻译) en C++ par la notion de pointeur（指针） Lien Type_x 1: pour créer ou déclarer un lien sur une variable contenu(1): pour accéder au contenu du lien 1 指针和引用 指针本质也是变量，存储地址。引用本质是取地址。 注： 引用必须初始化，引用不能为空，引用只是别名不是实体 就是说不能这样子 int &amp;n 要这样 int &amp;n = m(m之前定义) 然后in &amp;n = 3这样子也会报错（？） 引用没有const 引用的自增和指针的自增问题 123456789101112131415int *p,entier;int &amp;q = entier;entier=5;p = &amp;q;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;*p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;q++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;p++;cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&amp;q&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl; 指针自增就是还挺多，*运算符的优先级低于右++，然后还有什么移位不安全啥的，看到再说 Exemple 1234567891011121314Variables Lien Entier lienEnt Entier nDébut lienEnt &lt;- lien(n) conteun(lienEnt) &lt;- 5 afficher(n)Finint *lienEnt,nlienEnt = &amp;n;*lienEnt = 5;cout&lt;&lt;n; [?] ne transmettre que la valeur de la variable: utiliser le passage par valeur modifier la valeur originale de la variable: utiliser le passage en partage TD3_Swap 1234567Variables Entier cDébut c &lt;- a a &lt;- b b &lt;- cFin TD3_Swap+lien+struct 12345678910111213141516fonction creerArticleproblème : création d'un novel articleapecification: fonction: Lien Article &lt;- creerArticle(r,n,p) paramètres: Entier r, VectCar n , Réel p résultats: Lien Article 1A Variables Lien Article 1ADébut 1A &lt;- nouveau() contenu(1A).reference &lt;- r contenu(1A).nom &lt;- n contenu(1A).prix &lt;- p renvoyer 1AFin 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/21/ALGPR-3/"},{"title":"ALGPR-2","text":"序 第二周的算法课都讲了什么T.T TD2 尝试在课上直接记blog的第一天 Récursivité calcule la puissance d’un nombre principe_1: calcul récursif pour n != 0,et puissance(x,0)=1 123456entier puissance(entier x,entier n):Début si (n = 0) alors retourner 1//结束递归的跳出条件 sinon retourner x * pusissance(x,n-1)//递归 finsiFin principe_2: par la méthod “diviser pour régner”,et puissance(x,0)=1,et puissance(x,1)=x div étant la division entiere 1234567891011121314151617Début //结束递归的跳出条件 si (n = 0) alors retourner 1 finsi si (n = 1) alors retourner x finsi //本质还是在所递归，有减少一些递归的次数 entier y = puiss2(x, (n div 2)) si (n mod 2 = 0 ) alors retourner y*y sinon alors retourner x*y*y finsiFin ----&gt;堆栈！ L’ordre inversé 12345678910111213141516171819202122232425262728293031323334affiche_1(vecteur&lt;entier&gt; w)Début pour i de 0 à taille(w) -1 faire écrire(w[i]+'') fin_pourFin affiche_2(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors écrire(w[debut]+'') affiche_2(w,debut+1) fin_siFinentier debut = taille(w) -1affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut = -1) exit(0) fin_si écrire(w[debut]+'') affiche_inv(w,debut-1)Fin//可以初始化为0，先递归再输出[妙！]affiche_inv(vecteur&lt;entier&gt; w,int debut)Début si(debut &lt; taille(w)) alors affiche_inv(w,debut-1) écrire(w[debut]+'') fin_siFin String的palidrome 123456789101112Algorithm palindrome booléen &lt;- palindrome(string s,int decal) Début si(decal &lt; (taille(s)-1)/2) si(s[decal] != s[taille(s)-1-decal]) retourner FAUX sinon palindrome(s,decal+1) sinon retourner VRAIFin –&gt;用stack来实现 Reine et pions(八皇后！) 题有点怪 先写题 On considère un échiquier de huit cases sur huit comportant huit pions et une reine. Les positions des pions et de la reine sont données dans un fichier sous un format que vous devez définir(selon la structure de données que vous choisissez). La reine peut se déplacer sur les lignes(diagonales; verticale et horizontale) sur lesquelles elle se trouve. On souhaite savoir combien de pions sont en prise(i.e. pouvant êrte pris par la reine). Si deux pions ou plus sont sur la même ligne(diagonale, verticale , horizontale), seul le premier est en prise. 123456789101112131415161718192021DFSint res[9]void dfs(int step){ int i,j; if(step &gt; 8) { for(i=0;i&lt;8;i++) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0; } //尝试每一种可能 for(int i = 0 ; i &lt; 8; i++) { 继续下一步 dfs(step + 1); } return ; } CM2 Gestion de la mémoire//内存管理 Possible de stocker un lien vers une case mémoire Utile pour : ​ Structures de données (listes chainées, arbres) ​ Passage de paramètres：传递参数 ​ Allocation de mémoire：配置、地址分配 像是在讲指针的样子 1234567891011utilisation 'lien' :ExempleLienEntiervariables lien entier lienEnt//声明一个lien entier entDébut lienEnt ← lien(ent) contenu(lienEnt) ← 5 reçoit la valeur 5//接受 afficher(ent)Fin 关于lien和contenu lien:创造或声明链接 contenu：访问链接的内容 Structures de données composées Stockage de plusieurs données dans une seule structure pour：Structurer les données，Faciliter les traitements Données de même type : listes et arbres//树和表 Données de type quelconque : enregistrements(记录登记) Enregistrements 应该是结构体 123456789101112131415161718types article : Enregistrement entier : référence réel : prix chaine de caractère : libellé entier : quantité Fin enregistrementvectArticles : tableau d’articlevariablesarticle artCour // article courantentier valeurStockartCour.prix &lt;-- lire ()artCour.libellé &lt;-- lire ()artCour.quantité &lt;-- lire ()valeurStock &lt;-- artCour.prix * artCour.quantitéécrire (&quot;La valeur du stock de &quot;, artCour.libellé, &quot; est de : &quot;,valeurStock, &quot; euros&quot;) Structures linéaires Listes Définition Ensemble d’éléments de même type liés par une relation de séquentialité 注意一下名字： prédécesseur， successeur 一些关于表的基本操作:插入、删除、测试表是否为空、测表长 Tableaux表 Accès direct à un élément à l’aide de son indice(下标) 目标算法: Somme(求和), Tris(排序), Présence d’élément(?) Exemple de définition de types composés tabEnt : Tableau d’entiers matReels : Tableau de dimension 2 de réels tab4DEnt : tableau d’entiers de dimension 4 123456789101112131415161718192021222324252627282930//检查是否正序variables tabEnt tab entier n booléen trie{n, tab} &lt;- lire ()trie &lt;- VRAIpour i &lt;- 0 à n-2 faire si ( tab[i] &gt; tab[i+1] ) alors trie FAUX fin sifin poursi ( non trie ) alors écrire (&quot;le tableau n’est pas trié&quot;)fin si//一般函数variables vectArticles tabArt//?结构体的vector？ réel valStock entier nDébut{n, tabArt} &lt;-- lire (&quot;data.txt&quot;)valStock &lt;-- 0pour i 0 à n-1 faire valStock valStock + tabArt[i].prix * tabArt[i].quantitéfin pourécrire (&quot;La valeur du stock des &quot;, n, &quot; articles est de : &quot;,valStock, &quot; euros&quot;)Fin 所以说就是表的元素可以是结构体的意思？ Liste chainée链表 单向 successeur 链表的定义(值与指向下一元素的指针)： 1234567891011121314151617type elementEntier : Enregistrement entier valeur, lien elementEntier suivant, // lien vers l’élément suivant Fin enregistrementvariables elementEntier elementUn, elementDeux, ..., elementSix... elementUn.valeur 12 elementUn.suivant lien(elementDeux) elementDeux.valeur 99 elementDeux.suivant lien(elementTrois) ... elementCinq.suivant lien(elementSix) elementSix.valeur 16 elementSix.suivant VIDE 双向 要同时定义前置和后置指针 Calcul de la longueur d’une liste（递归） 1234567891011fonction : longueur calculLongueur(lienDébutListe)paramètres : lien elementEntier lienDébutListerésultats : entier longueurDébut si ( lienDébutListe est VIDE ) alors longueur 0 sinon longueur 1 + calculLongueur(lienD´ebutListe-&gt;suivant) fin si retourner longueurFin Recherche d’un élément dans une liste（递归） 12345678910111213141516fonction : présence chercherElement(lienDébutListe, val) paramètres : lien élémentEntier lienDébutListe, entier val résultats : booléen présenceDébut si ( lienDébutListe est VIDE ) alors//链表为空退出 présence FAUX sinon si ( lienDébutListe-&gt;valeur = val ) alors présence VRAI sinon présence chercherElement(lienDébutListe-&gt;suivant, val) fin_si fin_si retourner présenceFin 就是链表本质就是结构体+数组吗？ Liste chainée和tableau时间复杂度的比较 查找，添加/删除头(位) Piles 存储结构讲表与链表，然后栈、队列是特殊的线性表（？） LIFO:栈，先入后出 基本操作： ajoute(push),delete(pop),Test de pile vide File d’attente FIFO：队列，先入先出 Structures arborescentes ​ Extension du concept de liste avec plusieurs successeurs pour un élément(一个节点后面可以接多个节点) 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/09/ALGPR-2/"},{"title":"ALGPR-4","text":"序 关于算法的第四周 TD Listes chainées En utilisant une structure de liste chainée dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: afficher les éléments de liste(打印) ajouter un éléments à la fin de la liste(增) rechercher une valeur avec renvoi du nombre de valeurs présentes dans la liste(查) 1234567891011types elementSimplementChiane: Enregistrement type valeur, lien elementSimplementChiane suivant Fin_Enregistrementtypes elementEntier: Enregistrement type valeur lien elementSimplementChiane suivant Fin_Enregistrement Afficher 12345678910111213141516Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementafficherElement(Lien ElementEntier début)paramètre: Lien sur ElementEntierresultat: videDébut si(début non vide) alors écrire(début -&gt; valeur)//也可以写成contenu(début).valeur afficherElement(début -&gt; suivant)//contenu(début).suivant finsiFin Ajouter 1234567891011121314151617Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementajoutFin(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors contenu(début).suivant &lt;- ajoutFin(contenu(début).suivant,val) sinon contenu(début).valeur &lt;- val; contenu(début).suivant &lt;- NULL; finsi renvoyer débutFin Rechercher 12345678910111213141516171819Type ElementEntier: enregistrement Entier valeur Lien ElementEntier suivant Fin_EnregistrementrechercheNbVal(Lien ElementEntier début, Entier val)Début si(début n'est pas vide) alors si(contenu(début).valeur = val) nb &lt;- nb+1 finsi nb &lt;- nb+rechercheNbVal(contenu(début).suivant,val) sinon nb&lt;-0 finsi renvoyer débutFin Liste doublement chainées En utilisant une structure de liste doublement chainées dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: ajouter un éléments à la bonne place dans une liste triée, supprimer un élément dont la valeur est donnée en paramètre. 123456Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement Ajouter 123456789101112131415161718192021222324252627282930Types ElementEntierDbl: enregistrement Entier valeur Lien ElementEntierDbl suivant Lien ElementEntierDbl précrédent Fin_Enregistrement ajoutTrié(Lien ElementEntier début, Entier val)Variable: Lien ElementEntierDbl tmpDébut si(début n'est pas vide) alors si(val &lt; contenu(début).valeur) tmp &lt;- noveau() contenu(tmp).valeur &lt;- val //insère contenu(tmp).suivant &lt;- début contenu(tmp).précrédent &lt;- contenu(début).précrédent contenu(début).précrédent &lt;- tmp début &lt;- tmp sinon contenu(début).suivant &lt;- ajoutTrié(contenu(début).suivant,val) finsi sinon début &lt;- noveau() contenu(début).valeur &lt;- val finsi renvoyer débutFin Arbres binaires 12345Type NoeudArbreBinaire: Enregistrement type valeur, lien NoeudArbreBinaire fg, lien NoeudArbreBinaire fd,Fin_enregistrement Fonction parcoursPréfixe 123456789Début afficher(racine -&gt; valeur) si racine -&gt; fg non vide alors parcoursPréfixe(racine-&gt;fg) fin_si si racine -&gt; fd non vide alors parcoursPréfixe(racine-&gt;fd) fin_siFin Recherche 12345678910111213141516171819202122Booleen &lt;- existe(lien NoeudEntier noeud, Entier val)Début si(noeud n'est pas vide) alors renvoyer FAUX sinon si(noeud.valeur = val) alors renvoyer VRAI sinon renvoyer existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val)//注意这里一定是ou fin_si fin_siFin另一种写法Début si(noeud is not vide) alors renvoyer FAUX sinon renvoyer (noeud.valeur = val) OU existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val) fin_siFin Supprime[] 1234567891011121314lien NoeudEntier &lt;- supprimeFeuille(lien NoeudEntier, Entier val)efface()、nouveau()Début si(noeud is not vide) alors si(noeud.fg = vide ET noeud.fd = vide ET noeud.valeur = val) efface(noeud) sinon noeud.fg &lt;- supprimeFeuille(noeud.fg , val) noeud.fd &lt;- supprimeFeuille(noeud.fd , val) fin_si fin_si renvoyer noeudFin Ajouter Haute 123456789101112Entier &lt;- hauteur(lien NoeudEntier noeud)Début variable: entier g,d=0//放这里吗？？？？是的 si(noeud.fg is not vide) alors g &lt;- hauteur(noeud.fg) finsi si(noeud.fd is not vide) alors d &lt;- hauteur(noeud.fd) finsi h &lt;- 1+ max(g,d) renvoyer hFin ajouter dans la branche la plus courte d’un arbre une valeur passée en paramètre(在树的最短分支上添加一个参数中传递的值) 12345678910111213141516//[用树高来判断存在问题]---&gt;树的最小深度问题lien NoeudEntier &lt;- ajoutHtMin(lien NoeudEntier noeud, Entier val)Début si(noeud is not vide) alors si(hauteur(noeud-&gt;fg) &lt; hauteur(noeud-&gt;fd)) noeud.fg &lt;- ajoutHtMin(noeud-&gt;fg, val) sinon noeud.fd &lt;- ajoutHtMin(noeud-&gt;fd, val) sinon nouveau.valeur &lt;- val nouveau.fg &lt;- NULL nouveau.fd &lt;- NULL noeud &lt;- nouveau() finsi renvoyer noeudFin Arbres binaires de recherche(ABR): enracinement Définition : Un ABR est un arbre dont les valeurs des noeuds appartiennent à un ensemble totalement ordonné et les conditions équivalentes suivantes sont vérifiées: ​ La liste des valeurs en ordre infixe est croissante ​ Pour tout noeud x de valeur v, les valeurs des noeuds de la branche gauche de x sont inférieures ou égales à v et les valeurs des noeuds de la branche droite de x sont surpérieures ou égales à v (左节点要小于根节点，右节点要大于根结点) 二叉查找树的查找会更快 Verification constituer 用parcoursInfixe()创建//中序 inferieur, superieur(), abr()//都是布尔型函数 1234567891011121314151617181920specification: fonction: super &lt;- superieur(racine , x) parametres: lien NoeudArbreBinaire racine, Entier x resultat: booleenDebutvariables locales booleen b &lt;- (x &gt;= racine-&gt;valeur) choix selon (racine-&gt;fg != NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fg , x) et superieur(racine-&gt;fd , x) et b (racine-&gt;fg != NULL et racine-&gt;fd = NULL): renvoyer superieur(racine-&gt;fg , x) et b (racine-&gt;fg = NULL et racine-&gt;fd != NULL): renvoyer superieur(racine-&gt;fd , x) et b (racine-&gt;fg = NULL et racine-&gt;fd = NULL): renvoyer b fin_choix_selonFin CM 真后悔，没去 待补 看了一眼，大概c++的语法。好耶！","link":"/2022/02/28/ALGPR-4/"},{"title":"Ekya","text":"序 戴老师给的第二篇论文 读论文 DNN 深度神经网络，隐含层大于两层的神经网络 跑项目 项目地址：https://github.com/edge-video-services/ekya 结语 武运昌隆！","link":"/2022/08/01/Ekya/"},{"title":"ANG","text":"序 From BBC 6 Minute English.(https://www.bbc.co.uk/learningenglish/english/features/6-minute-english ) Welcome to the ‘metaverse’ Links：https://www.bbc.co.uk/learningenglish/english/features/6-minute-english_2022/ep-220106 1.5 minutes的introduction The topic I chose to talk about is &lt;&lt;Welcome to the ‘metaverse’&gt;&gt;. So to begin with, what is metavers? According to the video, metaverse means a virtual-reality space in which users can interact with a computer-generated environment and other users. Recently, Facebook announced that it was hiring ten thousand new workers to develop VR for the ‘metaverse’, according to Mark Zuckerberg, the Facebook boss,&quot; in the future we’ll all spend much of our time living and working in the ‘metaverse’ &quot;. But people hold different opinions about it. Some supporters think it can make a great difference to our living world. They believe that with the technology of metaverse, everything that we do on our phone today can be done in 3-D. But there are also some negative opinions. For example,some people called VR ‘ vomity reality ’,because wearing the headset of VR makes them feel sick, maybe because it’s so unwieldy . From my perspective, I hold a supportive attitude towards this new technology as it seems so cool which can make our world more convenient . 2 new keywords VR: virtual-reality,a hypothetical three-dimensional visual world created by a computer; user wears special goggles and fiber optic gloves etc., and can enter and move about in this world and interact with objects as if inside it unwieldy: difficult to move or carry because it’s so heavy, large or strangely shaped 结语 所以元宇宙就是VR? VR OU AR ? 看了一些科普，就是有比较像头号玩家那种世界（或许赛博朋克的那种？。感觉就是，元宇宙感觉是个画大饼的不太实的概念（ Body language online Links: https://www.bbc.co.uk/learningenglish/english/features/6-minute-english/ep-211209 Introduction The topic I chose to talk about is ‘Body language online’. As we know, body language is important when we communicate with others. By using some hand gestures and facial expressions, we can make the conversation more natural. But during the Covid pandemic, the communication tend to move online to be video meetings by using software like Zoom and Skype. So, in that case, how has body language changed in the world of online video meetings? Firstly, eye contact. In face-to-face meetings, we immediately see someone’s reaction to what we’ve said through eye contact, but using a web camera to make eye contact is almost impossible in online meetings and this often creates a kind of ‘distance’ effect.–&gt; ? Secondly, pause. It was completely normal to have a one-minute pause in a room with one another because we knew when we’re thinking but if we don’t hear someone speak on video, we may ask them if there are some Internet problems.–&gt; Slow down. Last but not the least, smile or laughing. Erica , a communications expert from the conversation, points out that laughing often happens in unison, so it is much less likely that we laugh and smile on camera. Laughing is often done in unison where we can quickly pick up the energy of someone smiling or laughing and feed off of that and laugh together. When it comes to screen delays, the fact that it’s not natural to see our own camera – being distracted by that – we are much less likely to laugh and smile. --&gt;Water cooler effect. That’s all. New words Water cooler effect: it’s an American expression to describe informal conversations between people at work.–&gt; Talk someting informal out of the topic. In Unison: it means happening together and at the same time Pandemic: 流行病 noun: a widespread outbreak of an infectious disease and many people are infected at the same time adjective: existing everywhere","link":"/2022/02/06/ANG-01/"},{"title":"CCUBE_Chapitre1","text":"序 CCUBE: C3{C^3}C3 est capteurs, contrôle, commande Chapitre_0:Préface et Objectifs Préface Objectifs et moyens 教学目标： — échantillonner un signal 信号采样; — en faire une analyse de Fourier 傅里叶分析; — modéliser un système physique continu par le langage des fonctions de transfert 用transfert函数给系统建模; — modéliser un système physique continu par le langage de l’espace d’état 用l’’espace d’état给系统建模; — lier les phénomènes physiques aux paramètres de ces représentations (temps de réponse, stabilité) ; — interfacer le temps continu et le temps discret(离散) ; — simuler(模拟) ces représentations à l’aide de logiciels adaptés. TP 使用Matlab的Simulink完成： 1.la reconstruction d’une partition à partir de l’enregistrement audio-phonique ; 2.le pilotage en simulation d’une navette spatiale, version très simplifiée d’un contrat avec l’agence spatiale 前置数学知识 — les nombres complexes 复数; — la dérivation et l’intégration d’une fonction d’une variable réelle（？） à valeur réelle（？） 积分求导; — les suites de nombres réels ou complexes ; on n’a pas à craindre les quelques calculs élémentaires de séries ; — le calcul matriciel 矩阵 ; — les valeurs et vecteurs propres, la diagonalisation d’une matrice carrée特征值； —LTI linéaire temporellement invariant线性时间不变 Chapitre1:Concepts et outils fondamentaux 结语 总有地上的菜鸡，敢于直面大佬的开源","link":"/2022/02/04/CCUBE-01/"},{"title":"INDUR_CM1","text":"INDUR - Informatique durable_CM1 一些问题和介绍 Quels mots/concepts vous évoque[唤起] l’idée d’une informatique durable(ou responsable)? ​ Energie: Conception logicielle–&gt;cycle de vie d’un logiciel analyse de complecité–&gt;metro compatilite utilisation a finalité de DD matériel–&gt;ordinateurs de []/centre de données Energie social ​ Ethique Quelques problèmes d’intérêt? design et informatique: le doomscrolling https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0257728在讲寻找与 COVID 相关的新闻可能会破坏积极情绪这些 informatique verte Une obligation sociétale https://www.legifrance.gouv.fr/codes/id/LEGIARTI000044330813/2022-09-01/ 讲说工程培训包括与数字服务的生态设计和数字清醒相关的模块。 Analyse d’impact relative a la protection des données(AIPD)? -obligatoire pour les traitements susceptibles[高风险] d’engendrer des risques élevés -Composé de 3 parties : Description détaillée du traitement mis en œuvre Évaluation juridique de la nécessité et de la proportionnalité concernant les principes et droits fondamentaux Étude technique des risques sur la sécurité des données (confidentialité[保密性], intégrité[完整性] et disponibilité[可用性]) et leurs impacts potentiels sur la vie privée -英语的：DPIA/PIA Plan du cours Plan du cours informatique verte(9月) Identifier les principes de l’informatique verte et les leviers[杠杆?] associés Enjeux[问题] et impacts directs et indirects Consommation énergétique matérielle et logicielle Sobriété[清醒] numérique -MOOC: impacts environnementaux du numérique Règlementation et éthique(10月) Cadre juridique en matière[材料，物质] de traitement automatique de données Ethique et responsabilité 11月7号早上考试!!! Objectifs du cours -Savoir construire une analyse éthique et responsable des traitements automatiques de l’information (identification de l’impact de ces traitements, des biais[偏差] possibles, etc.) -Savoir mettre en oeuvre un diagnostic de la consommation énergétique des applications informatiques Développer une pensée rationnelle[理性], basée sur la littérature scientifique 小组讨论 课后作业/之后的安排 MOOC(https://lms.fun-mooc.fr/courses/course-v1:inria+41025+session01/info)看完然后选主题写报告 就是说是让咋搁教室去上MOOC的意思？","link":"/2022/09/06/INDUR_CM1/"},{"title":"HASK_入门学习","text":"HASK_入门学习 B站：https://www.bilibili.com/video/BV16F411j7Zq?p=8&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 不推荐，听不懂T^T P1 简单算术运算 cmd+ghci进入环境，可以直接使用命令行进行简单的数学计算 Haskell的自定义函数 结构 函数名+输出参数+等号+表达式（可以调用函数/别的或者自己） 运行 文件以.hs结尾保存 cmd进入桌面：cd Desktop ghci :l + 文件名 输入函数名和参数，回车即可运行。 P2 列表 定义 用中括号定义，只能包含单一元素类型(但可以嵌套：列表元素是列表) 字符串，用双引号定义，其实是字符列表 常用操作 拼接 ++ [1,2,3]++[4,5] --&gt; [1,2,3,4,5] “hello”++“haskell”–&gt;“hellohaskell” 单个元素的拼接可以使用冒号 6：[3,4,5] --&gt; [6,3,4,5] 2:[] --&gt;[2] 2:3:4:[]–&gt;[2,3,4] 获取元素 !! “haskell world” !! 1 --&gt;‘a’ 比较 可以直接用 &gt;(如果相等则比较下一个位置),&lt;,== 列表乘 常用函数 let lst = [1,2,3,4] head,last,tail（第一个元素之后的元素）,init（最后一个函数之前的元素）,length,null,reverse take+n+列表：获取前n个元素//0返回空 drop+n+列表：删除前n个元素 4+‘elem’+列表：判断4是否在列表中 minimum,maximum,sum,product(累乘) Range 直接… cycle表示无限循环，take+cycle组合使用 take的是长度 take 5(repeat ‘a’) 等价于 replicate 5 ‘a’ 也可以用列表的形式实现 [2*x|x&lt;-[1…10]] [x|x&lt;[1…100], x mod13 == 0] 例题 注释：单行–，多行{-多行注释-} |表示对a进行说明，a&lt;-str表示a取自字符串str（想成在遍历） _&lt;-str表示取自字符串str,都把它搞成1 x &lt;- xs,odd x表示只获取xs中的奇数 元组 ()表示，可以包含多种元素，不同长度的元组是不同的数据类型 1[(1,2),(8,9,10),(4,5)]会报错 函数：fst返回第一个元素，snd返回第二个元素，但只用于长度为2的元组（？？？？？？） ZIP函数 接收两个列表进行元素配对压缩为新列表，新列表的元素为元组 [1..]['A',''B,'C']```-->[(1,'A'),(2,'B'),(3,'C')]12345678## 例题10以内可组成直角三角形的三条边的组合```haskellfun = [(a,b,c)|a&lt;-[1..10],b&lt;-[1..10],c&lt;-[1..10],a^2+b^2 == c^2]--&gt;fun = [(a,b,c)|a&lt;-[1..b],b&lt;-[1..c],c&lt;-[1..10],a^2+b^2 == c^2]--可以避免重复 P3：类型、类型变量、类型类 TYPE 使用:t查看 类型变量 比如说head啊fst啊这些函数返回值（的类型）是不一定的，所以head和fst函数就是类型变量 类型类 没懂啊啊啊啊啊啊啊啊啊啊 P4 模式匹配 输入5之外都是“holiday&quot; 阶乘 不写：：那排能运行吗？–&gt;不能 P5 |：管道，单竖线，感觉有点像if where let 有点像where case switch吧 听不懂了不听了","link":"/2022/09/01/HASK/"},{"title":"MATHS-TP1","text":"序 MATHS_TP1: Initiation Matlab – Equation de la chaleur 1D Initiation 注释：% 显示：disp、fprintf vecteur: x = [x1,x2……,xn] %空格或者逗号都可以；vecteur colonne 冒号：5：-1：1 %表示5到1以-1为间隔的vecteur linspace：是Matlab中的均分计算指令，用于产生x1,x2之间的N点行线性的矢量。其中x1、x2、N分别为起始值、终止值、元素个数。若默认N，默认点数为100","link":"/2022/02/22/MATH-TP1/"},{"title":"INDUR_MOOC","text":"MOOC 课上要求看的MOOC Partie1: Introduction: Les impacts environnementaux du numérique Partie2: Des équipements non renouvelables Des services numériques très matériels Partie1: Introduction: Les impacts environnementaux du numérique Introduction Le numérique et l’environnement: le numérique nous offre une formidable capacité de collecter, stocker et traiter ces données. Et cela nous aide à comprendre notre impact sur l’environnement. Alors, que sait-on de l’impact environnemental de l’homme sur le climat ? Et que nous disent ces indicateurs sur l’impact environnemental du numérique ? Ensuite, nous vous proposons de vous familiariser avec des outils mathématiques et informatiques essentiels pour comprendre et analyser les indicateurs. 数字技术与环境：数字技术帮助收集数据，有助于我们更好的了解环境。那么，我们对人类对气候的环境影响了解多少？这些指标告诉我们数字技术对环境的影响是什么？要学会使用计算机工具对这些指标进行分析。 Que pensez-vous du numérique ? 1.A l’heure où les problèmes environnementaux sont pointés du doigt, quel est l’impact du numérique sur l’environnement ? Là aussi, les avis divergent également : pour certains, le numérique est LA solution, pour d’autres, il ne ferait qu’aggraver le problème. Et vous qu’en pensez-vous ? -我觉得数字化对环境还是好的。数据的分析可以更直观发现问题并且提出有效的措施。 2.Indiquez quelques mots que vous associez spontanément[自发的] aux impacts environnementaux du numérique. Numérique et prise de conscience[意识] écologique[生态] : petite histoire 建模等计算方式更好的模拟和预测环境，并给出更好的解决方法 IPCC悖论：数字化越成功，发现的问题就越多？观察的越多， 环境足迹 数字化没有成功转型，只是在叠加[使用电子设备的同时也没有减少对树木的砍伐，石油的使用] Fiche concept: 概念表 数字不虚拟，有物理现实：光纤电缆 终端、云计算与数据中心[关于网络的另一端]–&gt;数据中心对环境的影响：2015 年，数字占全球温室气体排放量的 4%，而航空占 2.5%。在这 4% 中，有 25% 与数据中心相关联。数据中心的用电量约占全球用电量的 3%。 建模、数值模拟与环境 Quels indicateurs[指标] pour évaluer l’empreinte[足迹] numérique ? L’effet de serre[温室效应] provoque le réchauffement[变暖] de la plantet–&gt;OUI，没有的话地球在15°左右 Les activités humaines produisent-elles des gaz a effet de serre?–&gt;OUI Afin de comparer les effets sur le réchauffement global des différents gaz a effet de serre, les scientifiques ont choisi un gaz de référence. Lequel?–&gt;CO2 A ce jour, quel est approximativement le réchauffement global généré par les activités humaines depuis la révolution industrielle[1850-1900]?–&gt;+1°C，每10年+0.2°C Si ces émissions continuent a la vitesse actuelle, quand atteindrons-nous un réchauffement de +1.5°C depuis le début de la révolution industrielle?–&gt;2030到2052 Quelle est la consommation électrique mondiale liée aux usages numériques?–&gt;10%,每年增加6%，每12年翻一番 Fiche concept: Indicateur: est la traduction chiffrée d’un phénomène ou d’un concept. Indicateurs environnementaux: Les indicateurs peuvent être classés en fonction de l’enjeu écologique auquel ils correspondent. Par exemple le ministère de l’écologie a sélectionné 22 indicateurs essentiels pour suivre 4 enjeux écologiques majeurs : le changement climatique, la perte de biodiversité, la raréfaction des ressources et la multiplication des risques sanitaires environnementaux 生态部选择了 22 项基本指标来监测 4 大生态挑战：气候变化、生物多样性丧失、资源稀缺和环境健康风险倍增 Deux indicateurs environnementaux simples: Émissions de gaz à effet de serre et Empreinte en eau Un exemple d’indicateur environnemental synthétique : l’Empreinte Écologique (EE) 以国家为单位计算，生产+进口-出口 数字设备： L’empreinte environnementale du numérique mondial[数字环境足迹]：2019全球340亿台设备, 2.23亿吨。法国：6.31亿台设备，700万吨，数字消费占法国电力的8.3% Eco-avertis : Lire et questionner les indicateurs Êtes-vous victime du biais exponentiel[指数偏差]? Quel lien peut-on faire entre performance environnementale et usage d’Internet ? 横坐标：互联网使用人口，纵坐标：碳足迹 La sobriété numérique[数字清醒] La sobriété consiste à faire décroître voire disparaître des usages, des valeurs ou des comportements. Elle ne nécessite pas le développement de nouvelles techniques ou technologies. Elle se rapporte au suffisant relativement aux besoins et aux enjeux d’équilibre écologique et d’équité. On pourrait parler de « faire moins avec moins ». 减少甚至消除用途、价值观或行为。它不需要开发新技术或新技术。它涉及与生态平衡和公平的需求和问题有关的充分条件。我们可以谈论“事半功倍”。 Conclusion 全球变暖，环境衡量指标，数字行业的增长极其负面影响 Partie2: Des équipements non renouvelables 数字化的背后的设备是不可再生的 Pour démarrer : Combien possédez-vous d’équipements connectés ? L’empreinte environnementale des équipements numériques Vie et mort d’un smartphone：手机制造需要贵金属，开采和制造手机会污染水土流失污染环境，废弃手机不可回收再次造成污染 Cycle de vie d’un smartphone 对环境污染的排序：Production &gt; Usage[电力消耗] &gt; Transport &gt; Traitement de fin de vie Fiche concept ACV: analyse de cycle de vie, est une méthode d’évaluation quantifiée des impacts environnementaux d’un produit (qui peut être un bien ou un service). 具有多标准和多步骤的特点： Multicritère : différentes catégories d’impacts environnementaux sont étudiées (potentiel de réchauffement climatique, épuisement des ressources abiotiques, création d’ozone photochimique, pollution de l’eau, de l’air, des sols, toxicité humaine, perte de biodiversité…). Ces impacts relèvent de différentes échelles spatiales (du local au global) et temporelles (du court terme au long terme). Multi-étapes : les différentes phases du cycle de vie sont prises en compte (extraction des matières premières, fabrication, transport, usage, fin de vie). 分下面4个主要步骤进行： Objectifs et champ de l’étude：研究的目标和研究结果的用途 Inventaire du cycle de vie：核心，分解特定功能单元生命周期中涉及的生产、转换或者消费阶段。 Évaluation des impacts environnementaux Interprétation et mise en forme des résultats Pourrons-nous continuer longtemps à fabriquer des équipements informatiques ? Mais fabriquer toujours plus se heurte aux limites de notre planète：不可再生资源，无限可回收的不现实[热力学第二定律和技术限制] –&gt; si le numérique pèse sur l’épuisement des ressources ou si finalement 数字化会让资源枯竭吗 一些问题： -Combien de smartphones ont été vendus dans le monde en 2019?–&gt;1.4 milliard d’unités. -Combien y a-t-il d’éléments différents dans un smartphone?–&gt;plus de 50 -Ou t -Pour quelles raisons utilise-t-on l’or[黄金] dans un smartphone?–&gt;Conductibilité, Ne rouille[生锈] pas -Ou trouve-t-on du tantale dans un smartphone?–&gt;Dans les condensateurs[电容器]. -Pour quelles raisons utilise-t-on du tantale dans un smartphone?–&gt;Il est extrement résistant et il permet la miniaturisation -Ou trouve-t-on de l’indium dans un smartphone?–&gt;Dans le film transparent[透明膜] qui recouvre l’écran. Fiche concept：DEEE Quels métaux dans les smartphones ? 稀土金属，集成电路需要半导体[硅] DEEE：废物，废弃的电气和电子设备，它们包括来自使用电源插座、电池或蓄电池的设备的所有废物，以及它们的所有组件和与之相关的消耗品。 Depuis 2018 en France, les EEE sont classés en 7 catégories d’équipements (échanges thermiques, écrans, lampes, gros électroménager, petit électroménager, informatique) avec un objectif de traçage et de suivi. 法国将 EEE 分为 7 类设备（换热器、屏幕、灯具、大型家用电器、小型家用电器、IT）。 DEEE的处理：La prise en charge des équipements collectés mène à plusieurs voies possibles : la préparation à la réutilisation (environ 2% en France en 2019) ; le recyclage (environ 75%) ; la valorisation énergétique (environ 10%) ; l’élimination c’est-à-dire mise en décharge et enfouissement, ou incinération sans récupération d’énergie (environ 14%). 准备再利用（2019 年在法国约为 2%）；回收（约 75%）；能量回收（约 10%）；处置，即填埋和填埋，或没有能量回收的焚烧（约 14%）。 实际上，只有 75% 的收集到的 WEEE 被注入到真正的 WEEE 回收系统中（这个数字根据设备的类型而变化很大）。考虑到法国的回收率（50%），这最终仅代表 WEEE 产生量的 38%（充其量）。回收的6个阶段：拆解，碎成小块，磁铁对铁元素进行电磁分离，光学分选分离电子卡，涡流分离有色金属，浮选或光学分离塑料。 限制：回收率低，回收的过程耗费能量，危害环境 Éco-consommateur : Recycler n’est pas gagner ! [未完] Partie3: Des services numériques très matériels 除了数字设备对环境的影响外，数字服务对环境也会造成影响 数字服务：services numériques ，包括nos applications, logiciels de messagerie, interface de streaming Quelle est la part du numérique qui a le plus d’impact environnemental ? Communication numérique: Le déploiement d’internet et des réseaux télécoms est à l’origine de nouveaux modes de communication. La communication virtuelle est l’un des services les plus répandus. En quelques clics, nous pouvons faire passer des messages quasi instantanément à l’autre bout du monde. 数字通信：互联网和电信网络的部署导致了新的通信模式。虚拟通信是最广泛的服务之一。只需点击几下，我们就可以几乎立即向世界的另一端发送信息。 petite sondage： -Combien de mails recevez-vous en moyenne par jour?–&gt;Une personne reçoit en moyenne 39 mails par jour, avant d’arriver dans votre boîte mail, le mail parcourt en moyenne 1500km -Mais nous sommes loin d’être seuls sur la planète. Selon vous, combien de mails transitent par minute dans le monde?–&gt;190 millions Toujours plus d’outils de communication: Dans les années 90, le SMS était limité à 160 caractères et le mail était envoyé uniquement depuis un ordinateur. 30 ans après, nos modes de communication ont bien changé. Nous avons multiplié nos outils et nous sommes passés de quelques caractères écrits à des centaines de photos et de vidéos envoyées quasi instantanément depuis nos mobiles. Alors, tout cela est-il virtuel? Cela n’q t’il pas d’impacts? Pas si simple… 越来越多的通信工具：在20世纪90年代，短信被限制在160个字符以内，电子邮件只能从电脑上发送。30年后，我们的沟通方式已经改变。我们的工具成倍增加，从几个书面字符到几百张照片和视频，几乎瞬间从我们的手机上发送。那么，这一切都是虚拟的吗？它没有影响吗？没有那么简单… 看到这里也并没有对标题[对环境影响最大的数字化部分是什么]做出回答嘛 Les services numériques sont-ils virtuels ? 应用程序：在云服务器无法自己运行，背后一个完整的生态系统，包括一系列基础设施建设[电话，电缆，无线网络，手机信号塔，数据中心] 数字服务背后的一切：硬件；网络：海底电缆，光纤，路由器；数据中心：机器外处理，消耗电力，发热，发电机，备用电池； 数据越多，基础设施越多，基础设施越多，数据越多。 自动播放。占据。 Le voyage d’un mail Ce n’est pas magique, c’est technologique! L’envoi d’un mail nécessite une infrastructure[基础设施] complexe qui dépend des terminaux utilisés, des services de messagerie employés aussi bien par l’émetteur[发射器] que par le récepteur. Ici le schéma technologique est relativement simple. Mais si Bob avait mis en copie une dizaine d’amis, c’est comme si 10 messages étaient partis individuellement : chaque message va transiter par son propre serveur de réception, vers un récepteur différent. De quoi augmenter rapidement la complexité du schéma ! Idem pour les pièces jointes qui seront stockées autant de fois que nécessaire ! Bref, même si tout cela se produit en seulement quelques secondes ! Ce n’est pas magique ! Fiche concept: Qu’est-ce qu’un service numérique? Le service numérique désigne l’ensemble des ressources humaines, logicielles et matérielles nécessaire à la mise à disposition d’un service. 数字服务指定提供服务所需的所有人力、软件和物质资源。例如，提供电子邮件服务、在 Youtube 上观看视频、高性能计算的实现、加密货币金融交易的实现、网页的显示……行业标准ITU L. 1410将数字服务引入为使用数字设备和/或电信网络为一个或多个用户提供价值。 Ainsi, le service numérique est constitué d’un ensemble de logiciels, matériels, réseaux et infrastructures, et d’autres services numériques opérés par des acteurs. 因此，数字服务由一组软件、硬件、网络和基础设施以及由各种参与者（人力资源）（出版商、设计师、架构师、网络和服务运营商、互联网接入供应商、用户、 ETC）。这种通过数字服务进行的衔接使得满足一个或多个需求成为可能。 数字服务不是软件，由一组人力、材料和软件资源组成. **Le cycle de vie d’un service numérique: **设计–&gt;生产–&gt;部署–&gt;使用–&gt;维护–&gt;报废 **Les acteurs engagés dans le déploiement d’un service numérique: ** 用户，服务操作者，开发，架构，主机，网络运营商 Comment et pourquoi accumule-t-on autant de données ? 数据的堆积：人类产生的 90% 的数据将在过去 2 年中产生，90% 的存储数据将无用。例如，假设每辆自动驾驶汽车每天为大约 1 小时 30 天的流量收集 4TB 的数据（即使只有一部分通过网络）。世界上有数百亿个连接对象也在捕获和传输数据, 传输和存储所有这些信息对环境的影响并非微不足道。数据增长需要处理、格式化、集中和共享，这既耗时又耗资源。 以照片为例：分享照片被上传至云端，但云端处理需要存储成本。 Quelle est l’empreinte environnementale d’un service numérique ? Dans cette activité, nous vous proposons d’analyser l’empreinte environnementale d’une navigation web et de matérialiser l’impact des différentes fonctionnalités proposées : lecture d’article, de vidéo, de présentation interactive. Pour effectuer cette activité, nous avons choisi l’outil Carbonalyser qui permet de visualiser la consommation électrique et les émissions de gaz à effet de serre associées à votre navigation internet. Il en existe d’autres. Attention les hypothèses et données de base ne permettent pas de se baser sur cet outil pour mesurer finement les émissions deg eq C02 liées à votre navigation. Le résultat n’est donc pas à prendre comme une mesure. Par contre, cet outil vous permettra d’évaluer la différence relative d’impacts de sites web différents. Vous allez pour cela installer une extension sur votre navigateur, puis nous vous guiderons pour naviguer dans le web avant d’analyser les résultats de Carbonalyser. Cette application ne fonctionne que sur Firefox. 用火狐浏览器的拓展工具Carbonalyser分析浏览网页不同功能(文章，视频，交互)时的电力消耗和温室气体排放的比较。 问的一些问题： -Dans l’article Comment marche internet à quoi est comparé le navigateur[浏览器]？–&gt;voiture **Comment marche internet: **Internet 和 Web是不一样的。Internet相当于公路网，Web相当于商店。 -Dans la [vidéo][https://www.youtube.com/watch?v=GqD6AiaRo3U&amp;list=PLWvGMqXvyJAPvxp2IPUAbKmr_ULtR8Nbh&amp;index=4] comment accède-t-on au site www.ilovepigeon.com ?–&gt;un moteur de recherche. 网站的知识: web: 信息的集合，由数10亿个衔接文件组成。Le web c’est un réseau d’informations Internet: C’est le réseau informatique qui permet de les transporter. Site: C’est un ensemble de pages contenant de l’information. 也叫site web. 文档储存在Web服务器上，客户端和服务器通过 Web 进行通信，根据 HTTP 协议","link":"/2022/09/16/INDUR_MOOC/"},{"title":"PFONC_CM1","text":"PFONC_CM1 Introduction 基于函数的编程，接近数学声明式编程（programmation déclarative） 属性:transparence référentielle：参考透明,immutabilité：不变性 ​ transparence référentielle:并行，没有指针，全局变量或者输入输出 ​ immutabilité：被操纵对象的值永远不能改变 Constructions de base 复合函数 12345square x = x*xinc x = x+1f x = inc(square x)f x = (inc.square) x 条件式 if-then-else 123f n = if n == 0 then 1 else if n == -1 then 2 else 3 然后不等于是 /= gardée(|+ otherwise) 123456caculate' a b c | b == '+' = Just (a + c)--不太知道这里的just是啥 | b == '-' = Just (a - c) | b == '*' = Just (a * c) | b == '/' &amp;&amp; c == 0 = Nothing | b == '/' = Just (a / c) | otherwise = Nothing case-of 123f n = case n of 0 -&gt; 1 _ -&gt; n * f (n-1)--下划线_表示任意 递归: récursivité Une fonction récursive possède（有） : • un (ou plusieurs) cas général récursif • un (ou plusieurs) cas de base non récursif L’évaluation d’une fonction récursive se fait sur le modèle d’une pile[堆栈] Fonction récursive terminale 定义：Pour une fonction f définie en utilisant une fonction g, l’évaluation de g est dite terminale (tail évaluation/call) si elle fournit directement la valeur de f sans opération supplémentaire. 对于一个用函数g定义的函数f，如果g直接提供了f的值而没有任何额外的操作，那么g的évaluation被称为terminale 如果一个递归函数的所有递归的évaluation都是terminale的，那么他就是Fonction récursive terminale 例 123456f' 0 r = rf' n r = f' (n-1) (r*n)f n = f' n 1main = print(f 3) Exercices EX1: PUISSANCE 1.Écrire une fonction récursive qui calcule la puissance nen^ene d’un nombre 12puissance x 0 = 1puissance x n = x * puissance x (n-1) Utiliser le fait que x2n=(x2)nx^{2n}=(x^2)^nx2n=(x2)n pour améliorer la fonction. 12puissance' x 0 = 1puissance' x n = if even n then puissance' (x*x) (div n 2) else x * puissance' (x*x) (div n 2)--even应该是在说n是偶数，odd奇数 3.Quelles sont les complexités temporelles des deux versions ? 方法1是关于n的线性，方法2是关于log2nlog_2nlog2​n 的。 EX2: Fibonacci Écrire une fonction récursive terminale qui calcule le terme d’indice n de la suite de Fibonacci 12345678fibonacci 1 = 1fibonacci 2 = 1fibonacci n = fibonacci(n-1) + fibonacci(n-2)--terminalefibonacci' 0 _ n2 = n2--不是很懂这里fibonacci' n n1 n2 = fibonacci'(n-1) (n1+n2) n1fib n = fibonacci' n 1 0 EX3:La hauteur palindromique 1234567r' 0 m = mr' x m = r' (div x 10) (10*m + mod x 10)r x = r' x 0--判断回文数字:n == r(n)hpal n = if n == r n then 0 else 1 + hpal (n + r n)--太妙了太妙了太妙了","link":"/2022/09/06/PFONC_CM1/"},{"title":"PFONC_CM2&amp;3","text":"PFONC_CM2&amp;3 CHAP2:Types, 介绍haskell中的类型变量. Types de base entiers: Integer/Int Réels virgule flottante: Double ou Float Booléens: Bool (valeurs True et False) Caractères Char Chaîne de caractères: String (alias[别名] pour [Char]–Char类型的列表) Types algébriques[代数] 由基本类型构建 Types sommes : énumerations[枚举] 12data Bool = True | Falsedata Animal = Canard | Vache | Chat Types produits : tuples 12data AnimalMesure = Paire Animal Integer--Paire:值构造子(Value Constructor)和类型名(AnimalMesure)不同data Entiers3 = Entiers3 Integer Integer Integer Paire, True, False, Canard, etc. sont des constructeurs de données 都是值构造子，值构造可以与类型名同名，后面可以跟几个类型表示它包含值的类型 Ils peuvent avoir n’importe quel nom, y compris le même que le nom du type défini.Comme pour Entiers3 ; [可以同名] Les noms de types et de constructeurs commencent par une majuscule[大写字母] en Haskell.然后普通函数必须小写字母开头 Types algébriques: sommes de produits 12345678data PossibleReel = Rien | Valeur Doubleinversion :: Double -&gt;PossibleReelinversion 0 = Rieninversion x = Valeur (1/x)--Rien et Valeur sont implicitement[隐式地] définies avec ce type:--Rien:: PossibleReel--Valeur::Double -&gt;PossibleReel 这里注意一个问题，inversion的调用实现这里，直接调用 inversion n 报错 No instance for (Show PossibleReel) arising from a use of ‘print’，然后得在声明数据类型时加上deriving Show，具体原因不是很清楚哈哈哈哈 Plus de pattern-matching On peut utiliser les constructeurs pour faire du pattern-matching : 1234567opposePR :: PossibleReel -&gt;PossibleReelopposePR Rien = RienopposePR (Valeur x) = Valeur (-x)-- ou bien avec let ... inopposePR z = if z == Rien then Rien else let (Valeur x)=z in Valeur (-x) EXERCICE 1.Écrire une fonction et qui réalise le et logique entre deux Bool 12et True True = Trueet _ _ = False 2.Proposer la définition d’un type Point représentant un point du plan 1data Point = Point Double Double deriving Show 3.Écrire une fonction distance qui donne la distance entre deux Point 1234findDistance :: Point,Point -&gt; DoublefindDistance (Point x1 y1) (Point x2 y2)= sqrt ((x1-x2)^2+(x1-x2)^2)--调用：findDistance (Point 2 3) (Point 4 5) 4.Proposer la définition d’un type Figure qui est： ​ • soit un unique Point ; ​ • soit un cercle défini par son rayon &gt; 0 et son centre ; ​ • soit un carré défini par deux sommets opposés. 12data Vecteur = Vecteur Double Doubledata Figure = FigP Point |Cercle Point Double |Carre Point Vecteur 5.Écrire une fonction perimetre qui donne le périmètre[周长] d’une Figure. 1234perimetre (FigP _) = 0perimetre (Cercle _ r) = 2 * pi * rnorme (Vecteur x y)= findDistance (Point 0 0) (Point x y)perimetre (Carre _ (Vecteur x y)) = 4 * norme v --咋能这么算呢 Types paramétrés:参数化类型 Le type PossibleReel existe, sous la forme d’un type paramétré, en Haskell : 123--对于所有的类型来说都有：data Maybe a = Nothing | Just a--Maybe est un constructeur de type 一些(仍然不太懂的)理解： 类型构造子可以取类型作参数，产生新的类型 所以给 Car 类型加类型参数貌似并没有什么必要。通常我们都是 都是在一个类型中包含的类型并不影响它的行为时才引入类型参数 12345data Either a b = Left a | Right bsafeTwice ::Int-&gt;Either Int IntsafeTwice n = if n &gt; (maxBound::Int) `div` 2 then Left n else Right (2*n)--报错了QAQ,加deriving Show也不行 Types en Haskell type et newtype -type définit un type synonyme[同义] d’un autre：type String = [Char] -newtype est similaire à data mais ne fonctionne que pour un seul constructeur de données avec au plus une variable et fournit dans ce cas une petite optimisation (Synonymes mais crée un type distinct). 但只适用于最多只有一个变量的单一数据构造函数 Tuples Un tuple est un type produit, Haskell propose une syntaxe[语法] spécifique (et classique) pour les tuples: 12345678910-- fst et snd pour les couplesmaxi ::(Integer,Integer)-&gt;Integermaxi x = let a = fst x, b = snd x in if a &gt; b then a else b-- pattern matchingmaxi '::(Integer,Integer)-&gt;Integermaxi ' (a,b) = if a &gt; b then a else b-- pas que pour les couplesror::(Char,Char,Char)-&gt;(Char,Char,Char)ror (a,b,c) = (c,a,b) Enregistrements Un enregistrement est un type produit avec accesseurs intégrés [内置的访问器？] (en lecture bien sûr) 构造方法 123456789data Canard = Coin { nom::String , enverg::Double }info::Canard -&gt;Stringinfo c = &quot;Oh le beau canard &quot; ++ (nom c) ++&quot; d'envergure &quot; ++ show (enverg c) ++ &quot;m &quot;main = let c1 = Coin &quot;Coincoin&quot; 0.8 c2 = Coin { nom=&quot;Grocoin&quot;, enverg =0.8 } c3 = c2 { enverg = 1 } in print (info c1 ++ info c3) Listes -Le type liste est natif à Haskell, la liste vide est [] -Le constructeur « élément plus liste donne liste » est noté : --追加的冒号 -Pour tout type a le type « liste de a » est noté [a] ; -Accès à l’élément i (commençant à 0) : xs!!i.–获取索引 Listes en compréhension Les listes en compréhension (list comprehension) sont une facilité syntaxique pour créer des listes EXEMPLE 12345-- les nombres pairs inférieurs à n (on peut faire mieux...)evens n = [x+1 | x&lt; -[1..(n-2)], odd x]-- les produits de nombres impairs à trois chiffresproducts3 = [m*n | m &lt;- [101 ,103..999] ,n &lt;- [101 ,103..999]] EXERCICE Construire la liste des triplets pythagoriciens (a, b, c), c.-à-d. tels que a^2 + b^2 = c^2 , dont la somme des composantes vaut 1000 et tels que a &lt; b &lt; c. 1triplets = [(a,b,c) | a &lt;- [1..333],b&lt;-[a..666],c&lt;-[b..1000],a*a + b*b = c*c, a+b+c == 1000] Écrire une fonction reverse qui inverse une liste 123reverse' :: String -&gt; Stringreverse' [] = []reverse' (x:xs) = reverse' xs ++ [x] --列表的拼接是++，[x]表示转为列表 Écrire une fonction delete qui efface la première occurrence d’un élément dans une liste 12delete' x []=[]delete' x (y:xs) = if x == y then xs else y: delete' x xs--记住这里的y： Écrire une fonction maximum qui trouve le maximum dans une liste d’entiers 123456maxi :: Liste -&gt; Integermaxi [] = error &quot;list vide&quot;maxi [x] = x --这行很重要！maxi (x:xs) = if x &gt; maxi xs then x else maxi xs--或者写成maxi (x:xs)= max x (maxi xs) Écrire une fonction trimax qui réalise le tri par extraction du maximum dans une liste d’entiers 1234567trimax :: Liste -&gt; Listetrimax [] = []trimax [x] = [x]trimax xs = maxi xs : trimax (delete' (maxi xs) xs)--或者写成trimax xs = let y = maxi xs in y : trimax(suppr y xs) Types algébriques récursifs 12-- arithmétique de Peanodata Nat = Zero | Succ Nat EXERCICE Écrire une fonction addition qui réalise l’addition de deux Nat. 12345678data Nat = Zero | Succ Nat deriving Showeval :: Nat -&gt; Integereval Zero = 0eval (Succ n) = 1 + eval naddition Zero n = naddditon (Succ n1) n2 = addition n1 (Succ n2) Arbres EXERCICE Écrire un type Liste représentant une liste d’entiers 1data Liste = Vide | Cons Integer Liste deriving Show Écrire une fonction sum qui fait la somme des éléments d’une liste d’entiers 123somme :: Liste -&gt; Integersomme Vide = 0somme (Cons x xs) = x + somme xs Écrire un type ArbreBinaire représentant un arbre binaire d’entiers 1data Arbre = Vide | Cons Integer Arbre Arbre deriving Show Écrire une fonction hauteur qui calcule la hauteur d’un arbre binaire d’entiers. 123hauteur :: Arbre -&gt; Integerhauteur Vide = 0hauteur (Cons _ gauche droit) = 1 + max (hauteur gauche) (hauteur droit) Types génériques On peut définir les fonctions de façon générique : 123-- pour tout type afsquare ::(a-&gt;a)-&gt;(a-&gt;a)fsquare f = f.f Et des types algébriques de façon générique (paramétrée) : pour tout type a, le type [a] est une liste de a et Maybe a est la possibilité d’un a ; 代数类型以通用（参数化）的方式：对于任何类型的a，[a]是一个a的列表，Maybe a是一个a的可能性。 Et des fonctions génériques sur des types algébriques génériques : 12345678-- pour tout type ahead::[a]-&gt;ahead [] = error (&quot;head: Empty list&quot;) -- fct. partielle!head (x:xs) = x-- dans Data.MaybelistToMaybe::[a]-&gt;Maybe alistToMaybe [] = NothinglistToMaybe (x:xs) = Just x [没太看懂这啥呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜] 问题 参数化类型 Types génériques 正方形面积","link":"/2022/09/16/PFONC_CM2&3/"},{"title":"MVDNet","text":"序 记录第一次看论文与第一次独立运行深度学习代码~ 读论文 脉络梳理于XMind中 CNN概述 对图像进行识别 鲁棒性和抗干扰性都很强 卷积 卷积核/特征提取器：将图像拆分成对应的特点，查看被识别图像有无对应的卷积核来确认是否为目标物体。 卷积运算：用卷积核对原图像素（矩阵）进行扫描（点乘和），形成的新矩阵就叫特征图。特诊图的一些值(如行列式的值这种)能够反映与卷积核的相似度。比如： 池化 池化/下采样：多个卷积核(特征)会导致计算量增大，为解决这个问题提出的概念，本质是缩小特征图。池化方式有：最大池化（选择被扫描区域内的最大值）和平均池化（取被扫描区域内的平均值） 比如刚刚那个： 跑项目 不太顺利 项目地址：https://github.com/qiank10/MVDNet 环境配置 anaconda+linux+python3.7+cuda11.0+pytorch1.7 Pytorch 创建环境：conda create -n MVDNet python=3.7 激活/进入：conda activate MVDNet pytorch下载 1.查看cuda版本信息：nvcc --version或者nvidia-smi； 2.注意这里不能根据官网https://pytorch.org/get-started/locally/ 入口直接选择下载（如果正好是cuda10.2这种应该是ok的），不然后续不能配合cuda使用。 正确操作应该是到这里https://download.pytorch.org/whl/torch_stable.html 去找对应的下载进行安装(pip install就可以) 参数理解：cu110–&gt;cuda 11.0，torch版本自选，cp37–&gt;python3.7，后面就是win/linux了 检查 python–&gt;import torch–&gt;torch.cuda.is_available() Detectron2 Pycocotools 挺好装的而且没啥幺蛾子 数据准备 下载数据集：https://oxford-robotics-institute.github.io/radar-robotcar-dataset/， 用学校邮箱注册 可恨！等了一个月才回复，然后还在垃圾邮箱里面找不到了=_= 最后下载免费的数据集来后续操作的 在这里疯狂报错，主要是缺包和语法更新两个问题 报错no module named scipy或者cv，装scipy和opencv库 12pip install scipypip install opencv-python 报错 AttributeError: ‘scipy.spatial.transform.rotation.Rotation’ object has no attribute ‘as_dcm’：要把所有的as_dcm改成as_matrix 训练 报错import，需要到detectron2执行 1python setup.py build develop 报错“No such file or directory: ‘data/RobotCar/object/radar/1547122770869274.jpg’”：没解决 结语 武运昌隆","link":"/2022/05/20/MVDNet/"},{"title":"PFONC_CM4&amp;5","text":"PFONC_CM4&amp;5 CHAP4 : Fonctions d’ordre supérieur -Les fonctions sont des objets de première classe : elles se manipulent comme les types de base：函数像基本类型那样被传递[参数和返回值] -Notion de fonction d’ordre supérieur : ensembles de fonctions dans le domaine ou le codomaine：域或共域中的函数[?] Curryfication Haskell 的所有函数都只有一个参数, 所有多个参数的函数都是 Curried functions，下面以max函数为例进行说明 1max x y = if x &gt; y then x else y 他的类型说明是：max::Integer -&gt;Integer -&gt;Integer，但按照我们一般的理解，它应该长这样：max::(Integer,Integer)-&gt;Integer -Pour tout x, (max x) est une fonction d’un entier qui donne un entier Haskell 的所有函数都只有一个参数 -Donc max est aussi une fonction d’un entier qui donne « une fonction d’un entier qui donne un entier » max函数的参数是(一个返回值为int的函数)–&gt;max :: Integer-&gt;(Integer -&gt;Integer) --哎这里为什么不是 max :: (Integer-&gt;Integer) -&gt;Integer Et comme -&gt; est associatif à droite :max :: Integer-&gt;Integer -&gt;Integer Toute fonction de plusieurs variables peut être transformée en une fonction d’une seule variable, pour tous types a,b,c, on peut définir deux fonctions, les fonctions sont « curryfiées » (curried) par défaut en Haskell 1234curry::((a,b)-&gt;c)-&gt;(a-&gt;(b-&gt;c))uncurry::(a-&gt;(b-&gt;c))-&gt;((a,b)-&gt;c)-- et on pourrait définir des versions pour tous-- les tuples de types possibles EXERCICE Quel est le type de map ? 12map _ [] = []map f (x:xs) = (f x):(map f xs) map :: (a-&gt;b)-&gt;list-&gt;list map :: (a-&gt;b) -&gt; [a] -&gt;[b] Écrire une fonction flip, avec son type, qui à partir d’une fonction d’arité 2, donne la même fonction avec les variables inversées. Par exemple : main = print (flip (-) 1 3) --2(pas -2) 123filp :: (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)--为什么不是((a-&gt;b)-&gt;c-&gt;d) -&gt;((a-&gt;b)-&gt;d-&gt;c) --为什么f不是(a-&gt;b)，为什么不是交换b和cfilp f x y = f y xmain = print (flip (-) 1 3) ​ 以及这个神奇的错误 Application de fonction($) L’application de fonction est une fonction. Elle est notée ($) en Haskell : 12($)::(a-&gt;b)-&gt;a-&gt;b($) f x = f x 函数调用符，空格的函数调用符是左结合，而 $ 则是右结合，用于减少代码中括号的数目 Elle est de faible priorité et associative à droite : 123main = print (square (inc 2))-- ou un peu plus concismain = print $ square $ inc 2 Elle sert pour définir certaines fonctions d’ordre supérieur : 将数据作为函数使用：映射一个函数调用符到一组函数组成的 List 12-- valeurs en 0 des fonctions f, g et hmap ($ 0) [f,g,h] Fonctions anonymes (Fonctions λ) On peut définir des fonctions anonymes, appelées fonctions λ : P. ex. λx.(x + 1) ou λx.(λy.(x + y)) En Haskell : 123456inc x = x+1map inc [1,2,3]-- ou simplementmap (\\x -&gt; x+1) [1,2,3]-- plusieurs variables:add = (\\x y -&gt; x+y) 编写 lambda: \\ ，+用空格分隔的参数，±&gt; 后面的函数体。通常用括号将其括起，要不然它就会占据整个右边部分。 Fermetures (Closures): 闭包 On quantifie implicitement[隐式地量化了] x et y quand on écrit : 1f x y = x + y -- ∀x, ∀y La variable y est dite libre dans : 1f' x = x + y -- ∀x--不能这样子 On ne peut pas évaluer f’ x sans une valeur pour y. D’ailleurs, toute seule, ce n’est pas une déclaration correcte Une fermeture est une fonction avec variables libres plus une valeur pour ces variables libres : 12-- Pour tout y, g y est une fermeture，x是自由变量g y = (\\x -&gt; x + y) 那么怎么传参和调用呢？ Récursion sur les listes map -Plutôt que de faire de la récursivité explicite, on utilise plutôt, autant que possible, des fonctions de plus haut niveau [与其说是显式递归，不如说是尽可能地使用了更高层次的函数] -On a déjà vu map qui permet d’appliquer une fonction à chaque élément d’une liste : 123map::(a-&gt;b)-&gt;[a]-&gt;[b]map _ [] = []map f (x:xs) = (f x):(map f xs) EXERCICE: En utilisant map, écrire une fonction an qui donne la liste de toutes les anagrammes d’un mot[找所有字母组合]. On pourra utiliser aussi : concat::[[a]]-&gt;[a] ,delete::Eq a =&gt;a-&gt;[a]-&gt;[a] 12345import Data.List (delete,nub)-- anagrammesan :: String -&gt; [String]an &quot;&quot; = [&quot;&quot;]an xs = concat $ map (\\x -&gt; map (x:) $ an $ delete x xs ) $ nub xs--nub拿来去重复的 filter filter permet de ne garder que les éléments d’une liste qui satisfont un certain prédicat : 1234filter::(a-&gt;Bool)-&gt;[a]-&gt;[a]filter _ [] = []filter f (x:xs) = if f x then x:(filter f xs) else filter f xs EXERCICE Écrire une fonction premiers qui donne la liste des entiers premiers inférieurs à n. On pourra ne pas chercher à optimiser et : écrire une fonction diviseurs donnant une liste de diviseurs de n utiliser la syntaxe [x…y] pour la liste des entiers compris entre x et y ; et rem::Integer-&gt;Integer-&gt;Integer donnant le reste la division entière ; et null::[a]-&gt;Bool indiquant si une liste est vide ; ou length::[a]-&gt;Int donnant la taille d’une liste. 12345premiers n listes = filter (&lt;n) listes--找除数diviseurs n = filter ((==0).(rem n)) [1..n]--rem与mod差不多，但.的用法原则是什么？--找质数premiers' n = filter ((==2).length.diviseurs) [2..n-1] folds foldl et foldr permettent de réduire une liste à une valeur en appliquant une fonction d’arité 2 récursivement à tous les éléments : foldl réduit de la gauche vers la droite : 它从 List 的左端开始折叠，用初始值和 List 的头部调用这二元函数，得一新的累加值，并用新的累加值与 List 的下一个元素调用二元函数 123456789foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldl f x [] = xfoldl f x (y:ys) = foldl f (f x y) ysfoldl f z [x1, x2, ..., xn] == f (...(f (f z x1) x2)...) xn-- ou en notation infixefoldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2)...) `f` xn foldr réduit de la droite vers la gauche : 右折叠 foldr 的行为与左折叠相似，只是累加值是从 List 的右边开始 123456789foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;bfoldr f x [] = xfoldr f x (y:ys) = f y (foldr f x ys)foldr f z [x1, x2, ..., xn] == f x1 (f x2 (...(f xn z)...))-- ou en notation infixefoldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` (...(xn `f` z)...)) 右折叠可以处理无限长度的数据结构，而左折叠不可以。将 无限 List 从中断开执行左折叠是可以的，不过若是向右，就永远到不了头 foldl1,foldr1::(a-&gt;a-&gt;a)-&gt;[a]-&gt;a sont des versions sans élément de départ pour les listes non vides [没有起始元素的非空列表]; 无需明确提供初始值。他们假定 List 的首个 (或末尾) 元素作为起始值，并从旁边的元素开始折叠 以sum函数说明 1234suml::[Integer]-&gt;Integersuml xs = foldl (+) 0 xssumr::[Integer]-&gt;Integersumr xs = foldr (+) 0 xs EXERCICE: Écrire les fonctions suivantes (et tester à la main sur quelques exemples) : sum::[Integer]-&gt;Integer qui donne la somme des éléments d’une liste ; 上面 maximum::[Integer]-&gt;Integer qui donne le maximum des éléments d’une liste ; 123maxi'::[Integer]-&gt;Integermaxi' [] = error &quot;list: vide&quot;maxi' xs = foldl1 max xs and::[Bool]-&gt;Bool qui indique si tous les éléments sont vrais ; 12345and'::[Bool]-&gt;Booland' = foldr (&amp;&amp;) Trueor' :: [Bool] -&gt; Boolor' = foldr (||) False any::(a-&gt;Bool)-&gt;[a]-&gt;Bool qui indique si au moins un élément de la liste satisfait un prédicat donné ; 12any'::(a-&gt;Bool)-&gt;[a]-&gt;Boolany' f = or'.(map f) concat::[[a]]-&gt;[a] qui concatène une liste de listes. 12concat' :: [[a]] -&gt; [a]concat' = foldl (++) [] 问题集 Curryfication的max和例题的fild 闭包函数的调用和有什么用 P41的map全排列 上面的3,4,5怎么都不加列表参数，看不懂啊啊啊啊啊","link":"/2022/09/16/PFONC_CM4&5/"},{"title":"PRO20","text":"序 趁着可能对P2E有点用处的东风，把上学期一个很有意思的softskill给整理了。 中间 就是一个教怎么组织项目的课，具体实例是建养鸡场，选址、选鸡蛋品种（bio或者非bio）、然后风险评估啥的。以下是一些有趣的概念的大略整理。 Définitions Project: Un ensemble de tâches coordonnées accomplies par des personnes utilisant des moyens dans le but de répondre au besoin du client avec la qualité demandée en temps et coûts maitrisés Gestion de projet: La Gestion de projet s’assure du déroulement opérationnel prévu dans la planification. Elle reporte à la fonction de pilotage de projet sur l’avancement, elle sollicite des prises de décisions et remonte des alertes Management de projet: Direction + Gestion = Management Cadrage(框架) du Project L’identité du client Les objectifs du projet 目标应该满足的原则：S(Spécifique)M(Mesurable)A(Atteignable)R(Réaliste)T(Temporel) Les délais à respecter Les limites du budget à investir L’utilité du projet La rentabilité escomptée du projet Décomposer le projet WBS WBS : Work Breakdown Structure. Décomposition hiérarchique, axée sur les livrables, du travail que l’équipe de projet doit exécuter pour atteindre les objectifs du projet et produire les livrables souhaités. 做法： Spécifier les objectifs du projet Identifier spécifiquement les produits, services ou résultats Identifier les travaux Subdiviser les éléments jusqu’au niveau qui permet la planification et le contrôle PBS Product Breakdown Structure 注：当时好像是上课没咋讲这个，后来是按照网上(ZHIHU)的文章说，WBS是以项目结果为导向的工作过程的结构分解，PBS是项目交付结果本身为对象进行的层级结构分解来做的。具体到这道题，就是，WBS包含整个项目管理，PBS只是按照养鸡场本身按照地基、外部建筑、内部建筑、服务设施这样子分级。 Diagramme de Gantt C’est un outil que peut aider à définir un planning réaliste. 貌似就是一个项目的时间的进程表，找出要做的事情，然后分析发生的先后或者并行关系，搞成条状表就行了。 Exemple(红色表示关键事件) : PERT C’est un outil souvent utilisée pour la gestion de projets importants et à long terme. PERT = Program Evaluation and Review Technic (ou CPM: Critical Path Method) 就是把上面那个Gantt图给这样子表示，然后往里面写时间就行，然后选时间最大的那条线（不是我说，这好像算法里面的那个啥图 Exemple: Les risques Principaux risques incluent Risques financiers, Risques marchés, Risques technologiques, Risques liés à l’équipe. Pour gestion des risques, on peut utiliser le table comme ça, 就是两部分：严重程度+发生概率 对，记得当时有个文化shock还蛮有趣的小点就是，当时有个风险是员工absent，然后写应对措施，我说搞时刻表，然后其他人：推迟上班的时间或者改变工作环境。 结语 其实这个项目还有超级多的东西，当时TD课第一节课搞WBS、PBS和GANTT的图，第二节课搞投资和收益计算，第三节课是风险评估，参与程度递减，到最后一节课就除了汇报叭叭两句就完全没太参与进去，不知道在干嘛了T^T 反正最后结论就是要养bio的鸡，唔。","link":"/2022/02/07/PRO20/"},{"title":"PYTHON_CM1","text":"PYTHON_CM1 Lucas Lestandi Introdution -mutiplateforme, langage interprété（解释） et interractif -python robuste,la lisibilité et la maintenance, paquet pour la distribution sur d’autres machines y compris des dépendances Plan 1.python:安装环境啥的–&gt;2hCM+4hTP 2.数据结构：OPP,code robuste(architecture,introspection,exceptions)–&gt;2hCM+6hTP 3.avec modules:os,sys,subprocess,numpy,scipy,matplotlib,扩展包（conda或者pip） 4.看到个C++ CM1 conda: python环境，anaconda划分python环境，miniconda IDE：vscode jupyter：mixe code, markdown et cellules “raw” 数据类型：complex表示复数 1234567891011121314import sysall_paths = sys.pathfor path in all_paths: print(path)def a(string): longueur=() try: assert(type(string) is str) longueur=len(string) except Exception as err: print(f&quot;Unexpected {err=},{type(err)=}&quot;) return longueurprint(a(all_paths[0]) assert: 断言, 用于判断一个表达式，在表达式条件为false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在Linux 系统下运行，可以先判断当前系统是否符合条件。 try…except结构：捕捉异常，更一般加else 函数 12def 函数名(参数):#这里的参数*arg就是表示随意取几个 函数体#不写的话加上pass占位","link":"/2022/09/06/PYTHON_0/"},{"title":"SSTEM_DS","text":"SSTEM期末自救 TD TD1 Question: Après avoir défini les différentes parties prenantes du Système, identifiez les différentes utilisations et modélisez les sous forme d’un diagramme des cas d’utilisation Diagramme des cas d’utilisation 的 étape: Finalité,Missions,Objectifs(套话) Finalité: Assurer le fonctionnement des systèmes d’information de réseau ferroviaire. Missions:具体任务，得在问题中找，可能用到的词：définir,assurer,informer Objectifs: Pendre des dispositions raisonnable pour tous les trains grace à la coopération mutuelle entre [……] Les parties prenantes 找实体，可以画个方框图 comme ca： Les cas d’utilisation 画小人图 一些值得注意的点：方框+标题，拓展的include和extend(都是虚箭头画的) include: Celles qui sont incluses dans une action existante —&gt;obligatoirement,一定被执行 ​ 1.任务与子任务 ​ 2.小人的任务与任务间 extend: Celles qui étendent une action existante–&gt;éventuellement,可能被执行 Les interfaces 随缘 TD2 Question: 1.Identifier les parties prenantes et leur rôle dans ce processus 关键是区分ACTEUR OU COLLABORATEUR–&gt;看是否有开启或者终止活动 然后在行为中找出触发事件(Délencheur)和终止事件(Final) 可能用到的一些词：envoyer,refuse,annulation,verifier 2. Modéliser ce processus en BPMN 表示判断：sinon,valide 表示发信：envoyer,demande 表示收信：recevoir 终止和起始：都是空心圆但终止的要粗一点 TD3 Question: 1.Concevoir le diagramme Entités-Associations de ce système. ​ 画ER图等价于画MCD: Modèle Conceptuel des Données(概念模型) ER(MCD):主体+关系+实体与关系的比 objet &lt;=&gt;entité Propriété &lt;=&gt;attribut，属性，列 没有外键 lien &lt;=&gt;association 记得加比例，关于比例–&gt;est le lien entre l’entité et l’association 是minimum+maximum minimum:0:peut ne pas apparaître ​ 1:doit apparaître maximum:1:ne peut pas apparaître plus d’une fois ​ n:peut apparaître plusieurs fois 一些典型的关系及其比例：être: chefdegare和être是1:1，être和personne是0:1 ​ detype: salle和detype是1:1,detype和typedesalle是0:n TD3的2到5题是对ER的评价和补充，暂时不想展开看（TO BE ADDED） TD4 Question: Cet exercice s’appuie sur la modélisation de gestion de réseau ferroviaire mis en place lors des TDs précédents. Il a pour but de pratiquer SQL à travers l’écriture d’un certain nombre de requêtes. Le MCD utilisé est joint ci-dessous. 1.À partir du MCD, mettre en oeuvre le modèle physique de la base de données (MPD) 逻辑模型MLD: Modèle logiques与物理模型MPD: Modèle physiques：物理模型有数据类型 MPD:含实体的外键+箭头+数据类型 实体 标出主键（PK）与外键（FK） 箭头 箭头指向：从表指向主表的外键所在的位置 从表：以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询. 箭头：从表外键➡️主表 数据类型 integer/float character varying(256/128) date/datetime/timestamp 2.查询 基本语句： 1234SELECT (DISTINCT) 列名 FROM 表名 NATURAL JOIN 表名WHERE: 1.UPPER(Nom) LIKE '%TER%' 2.EXTRACT(YEAR/MONTH/DOW/HOUR/MINUTES FROM 表名)=…… TD5 1.表的创建 1234567891011121314CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY/NOT NULL/或其他 --联合主键 CONSTRAINT 约束名 PRIMARY KEY(列名1,列名2) --外键约束 CONSTRAINT 约束名 FOREIGN KEY(外键名) REFERENCES 表名(外键名) ON DELETE NO ACTION ON UPDATE CASCADE) 2.表的增删改 INSERT 12INSERT INTO 表名 VALUES ('','','')--若插入的列为空，写NULL DELETE 12345678910DELETE FROM 表名WHERE --where里面写查询--EXMPLEWHERE trajet_id in (SELECT trajet_id FROM arret WHERE EXTRACT(YEAR FROM arret_horaireprevu) = 2016 AND EXTRACT(MONTH FROM arret_horaireprevu) = 2 AND EXTRACT(YEAR FROM arret_horaireprevu) &lt; 9) UPDATE 123UPDATE 表名SET 列名WHERE …… TP TP1 查询工作SELECT 1.UNION SELECT: Donner la/les fonction(s) de Yvon Manac’h 123456789101112SELECT 'Mecanicien' FROM Mecanicien NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Agent' FROM Agent NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'Conducteur' FROM Conducteur NATURAL JOIN Personne WHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' UNION SELECT 'ChefDeGare' FROM ChefDeGare NATURAL JOIN PersonneWHERE UPPER(Personne_Nom) = 'MANAC''H' AND UPPER(Personne_Prenom) = 'YVON' 2.嵌套查询:Donner les horaires en gare de Nantes, pour les trains qui relient Nantes à Lyon pour la journée de demain. En pratique, on regardera quels trajets s’arrêtent à Nantes et Lyon. Attention, les gares de Lyon ne s’appellent pas ‘Gare de Lyon’ mais comporte Lyon dans leur nom. 12345678910111213141516SELECT DISTINCT train_id,trajet_id,arret_horaireprevuFROM train NATURAL JOIN trajet NATURAL JOIN arretWHERE trajet_id IN( SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%NANTES%' INTERSECT SELECT DISTINCT trajet_id FROM train NATURAL JOIN trajet NATURAL JOIN arret WHERE arret_horaireprevu BETWEEN '2021-12-21 00:00:00' AND '2021-12-21 23:59:59' AND UPPER(gare_abrege) LIKE '%LYON%')ORDER BY arret_horaireprevu--关于intersect:取交集--&gt;并集：union,差集：except TP2 继续写select(聚集函数) 1.Combien y a-t-il de conducteurs dans la base ? 12SELECT COUNT(*) --COUNT(*)拿来统计列FROM conducteur 2.De combien de gare chaque chef de gare est-il responsable? 12SELECT personne_nom,personne_prenom,personne_id,count(*) FROM gare NATURAL JOIN chefdegare NATURAL JOIN personne GROUP BY personne_nom,personne_prenom,personne_id ORDER BY count 注意点：GROUP BY上写除函数之外的所有的select,聚集函数后可以直接命名，comme ca 3.MAX、AVG TP3 SELECT + 导出PDF Générez un document, nommé rapport05.pdf, avec la liste des 5 propriétaires possédant les plus grandes superficies, triés en ordre décroissant des sommes de superficie de terrain qu’ils possèdent. On utilisera pour cela la fonction ST_AREA（算面积使用） 1234SELECT personne_nom,SUM(ST_AREA(parcelle_geometry)) AS area,COUNT(parcelle_id)FROM culture NATURAL JOIN parcelle NATURAL JOIN appartient NATURAL JOIN personneGROUP BY personne_nomORDER BY area DESC PROJECT TD6&amp;7 et TP 4&amp;5","link":"/2022/01/27/SSTEM-DS/"},{"title":"PYTHON_入门学习","text":"PYTHON_入门学习 b站搜python出来的第一个：https://www.bilibili.com/video/BV1wD4y1o7AS?p=25&amp;spm_id_from=pageDriver&amp;vd_source=ec0ffac623909fb11a02d9651bce5ea8 一般推荐，有点拖，但是一节很短看起来不累 CHAP_0 编码 bit byte: 8 bit kb: 1024 byte mb : 1024kb ASCII码，GB2312(中文)，Unicode,UTF-8 变量 有一些保留字keyword不能用作变量名，list啊class啊这些 定义和实际组成 一些常见的数据类型:int,float,bool,str 获取数据类型: type(变量名) 类型转换:str(age) 可以用单引号’age‘实现 注释 多行注释：三引号 中文注释：#coding:gbk input() 将输入内容存储到变量，注意一般存储的是str类型的 print 数字不加引号 字符串加单双引号三引号都行，三引号可以在代码里面换行 可以输出含有运算符的表达式：print(3+5)，print(‘我叫’+name)。注意：1.浮点数，以及一个奇怪的解决方法 2.一定是同类型才能相加 输出到文件： 123fp = open('D:/text.txt','a+')#a+表示如果文件不存在就创建，存在就在文件内容里面追加print('输出内容1',file=fp)fp.close() \\n:换行,print(‘hello\\nworld’) \\t:空格 r:输出原字符,print(r’\\n’) 运算符 算术运算符：+,-,*,/(是有小数的),//(整除),%,**(幂运算) 赋值运算符：=，支持+=这种，支持解包赋值：a,b,c=20,‘nana’,5.5-----&gt;交换就可以这样子写a,b = b,a，支持链式赋值，链式赋值指向的存储地址一致 比较运算符：&gt;,&lt;,!=,==,结果是bool类型 布尔运算符：and(与 &amp;&amp;),or(或 ||),not(非 !)； ​ in,not in 可以用于字符匹配 位运算：$按位与，|按位或，&lt;&lt;左移（2倍），&gt;&gt;右移（1/2） 运算符的优先级： pycharm 打断点+shift和f9就是调试模式 CHAP_1 程序的组织结构：顺序，选择，循环 空列表:[],list() 空元组:(),tuple() 空字典:{},dict() 空集合:set() 选择结构 12345678a = int(input('please input a: '))if a &gt; -10 and a &lt; 5: a += 1elif a &gt; 5 : a -= 1else : a = 0print(a) 和C++区别不大，注意elif、冒号和缩进，空的话写pass 简写的那种写法: x if 判断条件 else y 1print(str(a)+'大于'+str(b) if a &gt; b else str(a)+'小于等于'+str(b)) 循环结构 range() 用于创建一个整数序列,在循环中很重要 创建方式 123r = range(10)#0到9r = range(1,10)#1到9r = range(1,10,2)#1到9，步长为2 创建的是迭代器(?)，打印的话转成list,可以使用in和not in 12if 9 not in r: print('wa') while 例：1到100的偶数和 123456a = 0count = 0while a &lt; 101: a += 2 count += aprint(a) for-in for 自定义变量 in 可迭代对象: ​ 循环体 自定义变量: 当它不被使用时可以使用 _ 可迭代对象: 字符串，range() 例：1到100的偶数和 1234count = 0for item in range(0,101,2): count += itemprint(count) break 和 continue break直接退出循环，continue就是不管后面的直接执行下一次循环（好像也可以用pass？）都是本层循环，和c++蛮像的 else 就是说循环体后面可以接着写else，表示在没有break时执行else 123456789for item in range(3): pwd = input() if pwd = '888': print('wa') break else: print('non')else: print('冻结') 嵌套循环 例：打印99乘法表 1234for i in range(1,10): for j in range(1,i+1): print(j*i,end='\\t')#特别注意这里表示不换行打印 print() CHAP_2: list,dict,tuple,set,str 列表 存储多个元素，相当于数组，但可以存不同类型的元素 创建：直接使用中括号，或者调用内置函数list() 12lst = ['hello',98,'world']lst2 = list(['hello',98,'world'])#?有点感觉没太必要的样子 或者列表生成式 lst=[i for i in range(1,10)] 获取元素 index()函数，返回元素在list的索引，相同的返回第一个出现的地方 12lst.index('hello')lst.index('hello',1,4) 单个元素：取某个元素就是lst[0]这样子，lst[-1]表示最后一个，就是负的话就从右开始 多个元素：切片 1234567lst3=lst[1:6]#默认步长为1lst3=lst[1:6:2]lst3=lst[:6:2]#默认从0开lst3=lst[1::2]#默认到最后#step为负表示倒着取lst3=lst[::-1]lst3=lst[7:2:-1] 增删改查 查：in 和 not in，遍历直接循环就行，list是可迭代变量, for item in lst这样子就可以 增： 1234567lst = [10,20,30]lst.append(100)lst2 = ['hello','world']lst.extend(lst2)lst.insert(1,90)#切片lst[1:]=lst2#就是把位置1以后的全换成lst2了，但感觉是修改 删： 1234567lst=[10,20,30,30,40]lst.remove(30)lst.pop(-2)#默认是最后一个lst.clear()lst.del()#切片lst[1:3]=[]#感觉也是修改 改：直接索引或者切片改 排序：sort()函数或者sorted() 123lst=[70,20,50,30,40]lst.sort(reverse=ture)#默认升序，这样是降序lst_ = sorted(lst)#不改变原列表 字典 是一个可变(值可以增删改这样子)的无序序列，以键值对的形式存储，使用花括号定义 类比C++的哈希(那个map 注意：键值不能重复，不可变 创建：花括号直接定义，内置函数dict() 12scores = {'张三':98,'王五':45,'李四':78}student = dict(name='jack',age=20)#多个咋整嘞，不管 **zip()**函数把两个列表组合成字典： 123items = ['A','B','C']prices=[9,6.2,3.1]d = {item:price for item,price in zip(items,prices)} 获取元素 获取value：[]、get() 123scores['张三']#没有的话会报错scores.get('张三')#没有的话输出nonescores.get('张三',56)#没有的话输出56 获取视图： 123keys = scores.keys()#列表values = scores.values()#列表items = scores.items()#列表,但元素是元组 增删改查 查：查的是key，in 与 not in，比如 if ‘张三’ in scores : print(scores[‘张三’]),遍历也是直接循环就行：for item in sorce 删: del scores[‘张三’]，清空scores.clear() 添加: 增加键值对，scores[‘张一’]=97 修改：scores[‘张三’]=96 集合 没有value的字典–&gt;意味着集合中的元素不能重复，无序可变，也是用{}或者set()来定义 12345s = {5,6,3,'yu'}s = set(range(6))s = set([5,6,3,'yu'])#列表转集合s = set((5,6,3,'yu'))#元祖转集合s = set('yu')#字符串转集合 生成式：s = {i for i in range(6)}和列表一样，改个花括号就是，不过出来时无序的 增删改查 查：in 与 not in,遍历也是直接循环就行：for item in s 增：add:加一个和update:加很多 1234s = {5,6,3,'yu'}s.add(80)#无序的，不知道在哪儿s.update(80,'ll')s.update(lst) 删：remove，discard,pop,clear 123s.remove(5)#没有的话会报错s.discard(4)#没有的话不会报错s.pop()#随机删 数据操作 判断：相等：==或者!=，子集关系: issubset()和issuperset(),有没有交集isdisjoint() 取交集：s1.intersection(s2) 或者 s1 &amp; s2 取并集：s1.union(s2) 或者 s1 | s2 取差集：s1.difference(s2) 或者 s1 - s2 取对称差集(就是s1和s2的全集减交集)：s1.symmetric_difference(s2) 或者 s1 ^ s2 注s1和s2都是不发生变化的 元组 是不可变序列（没有增删改操作），使用小括号定义 不可变可以保证安全性 创建：(),tuple() 没有生成式哟 1234t = 'python','world',98t = ('python',)#一个元素记得加逗号t = ('python','world',98,[7,8])t = tuple(('python','world',98)) 其实不是指元组就不能改了，简单理解是数据类型不能改，就是指向的地址不能改，但地址里面的value是可以改的，比如说t[4]是列表，它的那些增删改啊也是能用的 获取元素 直接使用索引：t[0]这样子就可以 查 in 与 not in, 遍历也是一样循环for item in t: 4种数据结构的小结 CHAP_3: 字符串 不可变序列，可以使用单引号、双引号、三引号进行定义 查找子串 12345s = 'hello,hello's.index('lo')#3s.rindex('lo')#9s.find('lo')#没有不会报错s.rfind('lo') 大小写转换 12345s.upper()s.lower()s.swapcase()#小写转大写，大写转小写s.capitalize()#变成第一个字符大写，其余小写s.title()#变成每个单词的第一个字符大写，其余小写 对齐 12s = 'hello,python's.center(20,'*')#结果***hello,python*** split() 123456s = 'hello,python's.split()#默认分割符为空格，返回列表['hello',',','python']s.split(sep=',')s.split(,maxsplit=1)#可以指定最大劈分次数s.rsplit()#从右侧开始劈分 判断 123456s.isspace()#空白字符s.isalpha()#是不是由字母组成s.isnumeric()#是不是由数字组成s.isalnum()#是不是由数字+字母组成s.isdecimal()#十进制数字s.isidentifier()#合法标识符：字母数字下划线 replace() 123s = 'hello,python,python,python's.replace('python','java')s.replace('python','java',2) join:可以把列表、元祖连成字符串 1234lst=['hello','python']'*'.join(lst)#输出字符串：hello*python#也可以连字符串，不过比较怪--&gt;+'*'.join('python')#输出是p*y*t*h*o*n 比较：直接用算术运算符的＞&lt;这些 切片：和列表类似，s1 = s[:6:2]#开始切到6（不包含6），步长为2（负数表示从后往前） 占位符 {}做占位符或者% 12345name = 'A'age = 20print('我是%s，今年%d岁' % (name,age))#可以指定精度宽度啥的%7d,%.3fprint('我是{0}，今年{1}岁'.format(name,age))print(f'我是{name}，今年{age}岁') CHAP_4: 函数 创建和调用 123def calc(a,b): return (a*a-b*b)print(calc(10,20)) 注意冒号和空格 参数 参数的默认值：def fun(a,b=10):#表示说可以传1个参数，传两个就该啥啥 参数传递 python中的参数传递有两种方式:位置实参和关键字实参 1234#位置实参calc(10,20)#关键字实参calc(b=10,a=20) 注意 不可变对象(int，字符串，元组)在函数体的修改不会影响实参的值，可变对象（列表，字典，集合）会影响 123456789101112def fun(a,b): print(a) print(b) a=10 b.append(10) print(a) print(b)a = 11b = [7,8,9]fun(a,b)#a不会变，b会print(a)print(b) 个数可变的参数 位置参数：*,结果是元组 关键字参数：**，结果是字典 12345678def fun(*args): print(args)fun(10)fun(10,20,30)def fun(**args) print(args)fun(a=10,b=20,c=30) 注意：可变的参数只能有1个，但可变的位置参数和可变的关键字参数能一起存在 函数支持参数时，调用能用*这样子搞 返回值 多个时以元组形式返回 例题：斐波那契数列 12345678910def fabo(i): if i &lt;= 0: return elif i == 1 or i == 2:#注意or，写成|愣了好久 return 1 else: return fabo(i-1)+fabo(i-2)print(fabo(6)) CHAP_5: 类与对象 面向过程与面向对象 类与对象 类 类：多个类似事物组成的群体的总称 类的组成：属性，实例方法，静态方法和类方法【类里面的函数叫做方法】 类属性：直接定义在类里面（类方法外）的变量，被类的所有对象共享，可以使用类名直接访问 初始化方法（注意是两个下划线）:相当于构造函数，self理解为this指针 实例方法：类里面的函数 静态方法：用@staticmethod进行修饰，使用类名直接访问的方法（Student.cm()） 类方法：用@classmethod进行修饰，使用类名直接访问的方法 对象 类的实例化就是对象的创建 stu1 = Student(‘张三’，20) 其实stu1由3部分组成，name，age和类指针（指向了Student类） 动态绑定 直接使用对象名添加属性并赋值，也可以给他添加方法 123456def show() print('')stu1.gender = '男'stu1.show = showstu1.show() 好任性啊感觉 封装、继承与多态 封装 私有属性没有专有修饰符，在前面打两个下划线表示私有属性 123456789class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def show(self): print(self.name,self.__age)stu1 = Student('张三'，20)stu1.show()print(stu1.__age)#就不行 硬要使用也是可以的，用dir(stu1)去读然后有个啥就可以用了，不过说不推荐 继承 python支持多继承，如果一个类没有继承任何类，则默认继承object类 子类的构造函数(init)必须调用父类的构造函数：super().init_（） 123456class HaoStudent(Student): def __init__(self,name,age,score): super().__init__(name,age) self.score=scorestu2 = HaoStudent('张一',20,98)stu2.show() 方法重写：调用+重写–&gt;super().xxx()，然后后面加就成 OBJECT类：所有类的父类 多态 没懂 特殊属性与特殊方法 123456789101112class Student def __init__(self,name,age): self.name=name self.__age=age#可以在类里面使用但不能在外面使用 def __len__(self): return len(self.name) def __add__(self,other): return self.name+other.namestu1 = Student('张二'，20)stu2 = Student('张四'，20)print(len(stu1))print(stu1.__add__(stu2)) new那个不太懂，不太想懂 赋值、浅拷贝、深拷贝 赋值：只是形成两个变量，实际还是指向同一个对象 浅拷贝：包含的子对象内容不拷贝，源对象与拷贝对象引用同一个子对象 12345678910111213141516171819202122232425262728class CPU: passclass Disk: passclass Computer: def __init__(self,cpu,disk): self.cpu = cpu self.disk = disk#赋值--&gt;内存地址是一致的cpu1 = CPU()cpu2 = cpu1print(id(cpu1))print(id(cpu2))#浅拷贝--&gt;computer不一样但cpu和disk是一样的disk = Disk()computer = Computer(cpu1,disk)import copycomputer2 = copy.copy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer2),id(computer2.cpu),id(computer2.disk))#深拷贝--&gt;computer,cpu,disk都不一样computer3 = copy.deepcopy(computer)print(id(computer),id(computer.cpu),id(computer.disk))print(id(computer3),id(computer3.cpu),id(computer3.disk)) 深拷贝：递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同 CHAP_6: 文件，模块化编程 文件 1234567891011121314151617181920file = open('a.txt','r')#只读file.read()#读所有file.read(3)#读3个file.readline()#读一行file.readlines()#读所有行到列表file.seek(2)#从第几位开始读，默认0file.tell()#返回文件当前指针位置file.close()file2 = open('b.txt','w')#只写，如果文件不存在则创建，覆盖写,追加写是afile2.write('python')file2.flush()#缓冲file2.writelines('python')#不加换行符写file2.close()file3 = open('a.png','rb')#二进制读,可以读图片file4 = open('b.png','wb')#二进制写file4.write(file3.read())file3.close()file4.close() with：上下文管理器，不用写close() 12with open('a.txt','r') as file: file.read() 也可以用在类上 12with A() as file: file.__init__('5',5) OS模块：操作系统和文件系统模块 1234567import os#可以执行exeos.startfile('d:\\\\qq.exe')os.mkdir('newdir')#创建目录#os.pathimport os.path()os.path.abspath()#返回绝对路径 模块化编程 一个.py的文件就是一个模块，导入模块 12import mathfrom math import pi#注意一下顺序哟 自定义模块报错时：在目录文件右键：mark directory–&gt;sources root 主程序：就是这下面的内容只有在运行这个py文件时才运行，调用时不运行 12if __name__ = '__main__': print()","link":"/2022/08/31/PYTHON/"},{"title":"SSTEM01","text":"概要 介绍SysML和其简单应用,对TD1的内容进行简单的总结与归纳。 定义 SysML: un outil pour modéliser les Systèmes But: Analyse et description des systèmes( Besoin, Description de sous-systèmes, Chîne d’information) But pour cet TD: Analyse externe d’un systèmes Etape（以exemples进行更好说明） 0.Exemples Analyse externe d’un radio-réveil. 1.Identification de la finalité des missions et objectifs du système ​ finalité: Qu’est-ce qu’apporte le Système?à quoi sert-il? ​ missions: Comment le Système contribue-t-il à la finalité. Sur quels principes reposent la mise en oeuvre de la finalité? ​ objectifs: Comment le Système met-il en oeuvre ses missions? Exemples: ​ finalité: réveiller une personne endormie ​ missions: réveiller l’utilisateur à l’aide d’un signal sonore (bip ou radio choisie) à une heure prédéfinie. Diffuser le signal sonore émit par une station radio. ​ objectifs: Émettre un son suffisamment fort pour le réveil (ex: &gt; 90db). 2.Identification de interacteurs ou parties prenantes du système Faire une liste des parties prenantes: les éléments qui sont relies au Systèmes (systèmes physiques, personnes…) via une action sur ce système. Note: Les éléments interne du Système ne font pas partie des ‘parties prenantes’ Exemples: Faire un diagramme de bloc Le système est placé au centre du schéma. Il est relié aux parties prenantes. Sur le lien, on peut faire figurer la nature du lien 3.Les cas d’utilisation Le cycle de vie du Système peut comporter: conception, implémentation, implémentation, utilisation, démantèlement, recyclage. ​ Règles de dessin Les parties prenantes qui utilisent ou ont une action sur le Système seront représentées comme des acteurs, un petit bonhomme Le Système est représenté comme un bloc Dans le bloc figurent les actions(fonctionnalités) que peuvent faire les acteurs. Elles sont représentées par une ellipse. Dans le bloc, on doit dessiner les actions importantes et les liaisons entre les actions. 2 types: extend, include(obligatoirement). 4.Les interfaces Certaines des parties prenantes alimentent/sont alimentées par le Système. Pour chacune d’elle, on peut définir le/les flux(matière-énergie-information) qui sont échangés. ​ Règles de dessin Le système est un bloc au centre du schéma. Les flux entrants et sortants du système sont indiqués par des boites de connexion sur le bord du bloc central. Les flux sont également décrits par des boites sur le coté du diagramme. TD TD1小结：用学长的拼拼凑凑的搞上去的，但自己的第一次思考并没有把finalité,missions,objectif给找好。在理解上存在偏差。希望之后能够有所改进 单词 Outil:工具 Radio-réveil:收音机闹钟 Sert:服务、帮助 Apporte：带来，提供 Mise:安装 oeuvre:工作 Diffuser:扩散、传播 Schéma:图解、提纲 Figurer:画出、代表 conception, implémentation, implémentation, utilisation, démantèlement, recyclage：设计，实施，实施，使用，拆卸，回收。 Flux:流动 Obligatoirement：必须的 结语 来法国后的第一篇博客真的太多想说了的。（虽然在国内也没写几篇 首先就是上这节课的那天下午是流体的期末，所以对课上很多内容都不知道，包括TD1的实例，也有其他许多待修正的部分。 其次就是很多地方都是照搬的PPT，没有起到一个很好的总结和思考。 这篇博客完成的也是磕磕绊绊，对法语键盘的不熟悉（比如打不出oe和^i)和法语的不熟悉。 最后的最后，希望自己坚持下去，做好记录，出现越来越少不认识的单词和行文中越来越少的中文。 就祝自己能以此为新开始，用Blog的形式见证我在南特这两年的跌跌撞撞的成长。","link":"/2021/12/06/SSTEM01/"},{"title":"algorithm-绪论","text":"算法_第一章__绪论 1.算法的五大特征 输入、输出、确定性、有穷性、可行性 2.算法的描述方法 自然语言描述 流程描述 伪代码描述 3.算法的重要问题 排序、查找、字符串匹配、图问题、组合问题、几何问题、数值问题 4.算法基本的数据结构 线性结构、数结构、图结构、集合 5.算法设计的方法策略 蛮力法、递归与分治、动态规划、贪心算法、回溯与分治","link":"/2021/12/06/algorithm01/"},{"title":"Voyage-Italie","text":"行程 马耳他⟶\\longrightarrow⟶罗马⟶\\longrightarrow⟶米兰 马耳他 好看！ 看到海就真的超级开心 能在这个岛上过暑假的小孩应该很幸福吧 但就是住的好远（晕车真的难顶 体验了壁炉和烤鸡 还有偷偷摘下来的仙人掌的果 整体风格蛮中东的 但又特别电影 穷途末路的英雄的流浪故事 碰到的司机大叔也人超级好 希望这两年间能再去一次 带着夏企和橘子汽水 想念夏天 罗马 西班牙台阶⟶\\longrightarrow⟶总统府（？maybe）⟶\\longrightarrow⟶圣天使堡⟶\\longrightarrow⟶梵蒂冈⟶\\longrightarrow⟶万神庙⟶\\longrightarrow⟶斗兽场⟶\\longrightarrow⟶什么祭坛 DAY1 西班牙台阶，总统府和一个喷泉(and 张女士) 夕阳好看！ 龙虾意面好吃！ 冰淇淋好吃！ DAY2 圣天使堡+法院+梵蒂冈+万神庙 夕阳好看！ 在梵蒂冈被骗了10欧QAQ 但暴走了两次不亏！（Cappella Sistina 看到了前前前手机壁纸，开心 DAY3 斗兽场+祭坛 中餐好吃！ 臭鸟拉屎（猖狂到当地老太太会打伞的程度，可恶 米兰 个人不官方的宣布 米兰就是旅游荒漠 只就去了大教堂，然后有猥琐的偷偷喂鸽子 但是！ 米兰火锅！好好吃！店名：“巴倒辣”。人生建议：不能点中辣不能点中辣不能点中辣！（上次被辣成瓜娃子还是在重庆的时候了 结语 虽然没去佛罗伦萨和威尼斯，但得歇一段时间不看人文类风光啦~ 意大利再见 ε≡٩(๑&gt;₃&lt;)۶","link":"/2022/02/01/Voyage-Italie/"},{"title":"序言","text":"序 太晚了，明天写。 截断测试 图片测试： 数学公式测试 T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) 公式测试2 T(n)=∑iCopi∗Ci(n)T(n)=\\sum_i C_{opi} * C_i(n) T(n)=i∑​Copi​∗Ci​(n) Flags： 侧边栏多级分类 FLUID整理 Pro20整理 SSTEM一周一记","link":"/2021/12/05/hello-world/"},{"title":"排序算法(一)","text":"排序算法 浅学排序[基于对大一数据结构的整理] 3种T(n)=O(n2)T(n) = O(n^2)T(n)=O(n2)的基本排序 选择排序 找最大/最小与头或尾交换 123456789101112131415161718192021222324void SelSort(int R[],int n){ for(i=0;i&lt;=n-2;i++) { m = i; for(j=i;j&lt;n;j++)//找最值 { if(R[j]&lt;R[m]) m = j; } if(m != i) swap(R[i],R[m]) }}//递归实现void SelSort(int R[],int n,int i){ if(i &gt; n-2) return ; m = i; for(j=i;j&lt;n;j++)//找最值 if(R[j]&lt;R[m]) m = j; if(m != i) swap(R[i],R[m]) SelSort(R,n,i+1)} 插入排序 1.教案版 算法描述： 排第i个时用j去找位置，找到位置后插入并使别的元素移动。每次循环完前i个数按升序排列 算法实现 12345678910111213void InsertSort(ElemTp R[],int n){ for(int i = 1 ; i &lt; n;i++) { j = 0; while(j&lt;i &amp;&amp; R[j].valeur &lt;= R[i].valeur) j++; //把R[i]插入到位置R[j]左边 //这里用的是vector的insert函数，有后移操作，复杂度为O(n) R.insert(R.begin()+j,R[i]); R.erase(R.begin()+i+1); }} 时间复杂度为O(n^2) 2.网上看到的 //从后往前，查找的时候就进行后移操作 12345678910111213void insertion_sort(int arr[],int len){ for(int i=1;i&lt;len;i++) { int key=arr[i]; int j=i-1; while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; }} 冒泡排序 每次循环进行两两比较和交换，第i次循环结束，第i大（小）的数排序完成。 算法实现 123456789101112131415161718192021void bubble_sort(int arr[], int len){ for(int i=0;i&lt;len;i++) { int flag=0； for(int j=0;j&lt;k;j++) { if(arr[j]&gt;arr[j+1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = 1； pos = j; } } k = pos; if(!flag) return; }} 时间复杂度为O(n^2) 冒泡排序的优化： 加入flag判断当前是否已经排序完成。 加入记录上次循环发生交换的最后位置pos,说明后(或者前)pos个是已经排好了，下次循环只需比到k即可 希尔排序 将待排序列分割成子序列[序号相同的是一个子序列]，对子序列进行插入排序，当增量为1时，排序完成。 例子： 一般来讲增量序列的size是3或者4//循环次数 代码实现： 1.赵宏宇版 1234567891011121314151617void shell_sort(vector&lt;int&gt; arr[],vector&lt;int&gt; d[])//d里面存增量序列{ for(int i=0;i&lt;d.size;i++) { for(int j=0;j&lt;d[i];j++) { //进行插入排序,从后边查边移,真难看，(bushi for(int k = j+d[i];k&lt;arr.size;k+=d[i]) { int temp = arr[k]; for(int t = k-d[i]; t&gt;=j &amp;&amp; arr[t]&gt;arr[j];t-=d[i]) arr[t+d[i]] = arr[t]; arr[t+d[i]]=temp; } } }} 2.网络版 排两次，增量序列为(4,1) 123456789101112131415161718192021222324252627template&lt;typename T&gt;void shell_sort(T array[], int length) { int h = 1; //[就是说，length为2和3是直接插入排就行了] while (h &lt; length / 3) { h = 3 * h + 1;//增量序列为(4,1) } //增量序列为1是排序完成 while (h &gt;= 1) { //插入排序，对array[0,h] for (int i = h; i &lt; length; i++) { for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) { swap(array[j], array[j - h]); } } //减小增量序列 h = h / 3; }} 时间复杂度分析 增量为2时，T(n)=O(n1.5)T(n) = O(n^{1.5})T(n)=O(n1.5) n在某个特定范围内，T(n)=O(n1.3)T(n) = O(n^{1.3})T(n)=O(n1.3) n趋于无穷时，T(n)=O(n(log2n)2)T(n) = O(n(log_2n)^2)T(n)=O(n(log2​n)2) 快排 找支点，比支点小的放左边，比支点大的放右边。对放左边，放右边的子序列执行同样的操作。直到不能拆分出子序列为止 比支点小的放左边，比支点大的放右边的实现：一个i从头到尾，一个j从尾到头，j遍历到小于支点的位置停下，然后i遍历到大于支点的位置停下，交换。然后重复先j然后i，直到i=j,将基准数与i交换 12345678910111213141516171819void quicksort(int left,int right){ int i,j,t,temp; if(left&gt;right) return; //排序完成 temp = a[left]//支点 i = left; j = right; while(i != j) { while(a[j] &gt;= temp &amp;&amp; i &lt; j) j-- while(a[i] &gt;= temp &amp;&amp; i &lt; j) i++ if(i&lt;j) swap(a[i],a[j]) } //支点归位 swap(a[left],a[i]) //递归 quicksort(left,i-1) quicksort(i+1,right)} 时间复杂度为O(nlogn)O(nlogn)O(nlogn) 堆排序 什么是堆 n个元素组成的序列{R0,R1,...,Rn−1}\\{R_0,R_1,...,R_{n-1}\\}{R0​,R1​,...,Rn−1​}时,但满足Ri.K&gt;=R2i+1.K and Ri.K&gt;=R2i+2R_i.K &gt;= R_{2i+1}.K \\ and\\ R_i.K &gt;= R_{2i+2}Ri​.K&gt;=R2i+1​.K and Ri​.K&gt;=R2i+2​时该序列就是堆[或者同时小于] 存储结构是一维数组，逻辑结构是完全二叉树[插入顺序必须为从上到下从左到右] 大根堆就是每个父节点都比子节点要大，小根堆同理 下标为i的节点的父节点：(i-1)/2,子节点2i+1和2i+2 堆性质的维护 12345678910111213141516void heapify(int arr[], int len, int i){ int largest = i; int lson = i * 2 + 1; int rson = i * 2 + 2; if (lson &lt; len &amp;&amp; arr[largest] &lt; arr[lson]) largest = lson; if (rson &lt; len &amp;&amp; arr[largest] &lt; arr[rson]) largest = rson; if (largest != i) { swap(&amp;arr[largest], &amp;arr[i]); heapify(arr, len, largest);//递归维护剩余位置，注意这里的largest是交换后的那个位置 }} 算法 基本思想：建堆。堆顶与最后一个元素交换，它就是最大了的，然后维护剩余元素的性质。然后循环。 1234567891011121314void heap_sort(int arr[], int len){ int i; // 建堆 for (i = len / 2 - 1; i &gt;= 0; i--) heapify(arr, len, i); // 排序 for (i = len - 1; i &gt; 0; i--) { swap(&amp;arr[i], &amp;arr[0]);//堆顶与最后一个元素交换 heapify(arr, i, 0);//维护剩余元素 }} 时间复杂度是O(nlogn)O(nlogn)O(nlogn) 归并排序 二分到子序列只有一个元素位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 合并void merge(int arr[], int tempArr[], int left, int mid, int right){ int l_pos = left; // 标记左半区第一个未排序的元素 int r_pos = mid + 1;// 标记右半区第一个未排序的元素 int pos = left;// 临时数组元素的下标 //合并 while (l_pos &lt;= mid &amp;&amp; r_pos &lt;= right) { if (arr[l_pos] &lt; arr[r_pos])// 左半区第一个剩余元素更小 tempArr[pos++] = arr[l_pos++]; else // 右半区第一个剩余元素更小 tempArr[pos++] = arr[r_pos++]; } // 合并左半区剩余的元素 while (l_pos &lt;= mid) tempArr[pos++] = arr[l_pos++]; // 合并右半区剩余的元素 while (r_pos &lt;= right) tempArr[pos++] = arr[r_pos++]; // 把临时数组中合并后的元素复制回原来的数组 while (left &lt;= right) { arr[left] = tempArr[left]; left++; }}// 归并排序void msort(int arr[], int tempArr[], int left, int right){ if (left &lt; right)//只有一个元素不需要划分 { //找中间点进行划分 int mid = (left + right) / 2; msort(arr, tempArr, left, mid); msort(arr, tempArr, mid + 1, right); //合并已经排序的部分 merge(arr, tempArr, left, mid, right); }}// 归并排序入口void merge_sort(int arr[], int n){ // 分配一个辅助数组 int tempArr[n]; // 调用实际的归并排序 msort(arr, tempArr, 0, n - 1);} 时间复杂度是O(nlogn)O(nlogn)O(nlogn) 基数排序 下次一定","link":"/2022/05/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/"},{"title":"Voyage-Paris","text":"行程 铁塔⟶\\longrightarrow⟶迪士尼⟶\\longrightarrow⟶卢浮宫⟶\\longrightarrow⟶奥赛⟶\\longrightarrow⟶先贤祠 Day 1 下午到的 铁塔上看的夕阳 超好看！ 顺便打卡盗梦空间的桥 Day 2 迪士尼好玩的 未来的日子永远爱跳跳虎 Day 3 卢浮宫真的好大就是说 法国斥巨资修建这座宫殿或许比里面的展品还要了不起。 雕塑真的好厉害。 伊斯兰教的艺术印象蛮深。 然后镇馆三宝打卡成功：维纳斯、蒙娜丽莎、胜利女神 画的话，宗教类、宫廷很多。一开始很震撼，看多了，嗯，装不下。 Day 4 奥赛博物馆的话就是好看的画 梵高好看 莫奈也好好看 还有个点彩画派 很喜欢的画买了明信片但忘记画家了T^T 出来时的公园，好看到分不清是不是在画中 （或许还记得出来一家商店里面的9000欧的衣服？ Day 5 先贤祠 外面比里面好看 只记得里面的钟摆了 看到了一群穿正装的未来大佬们 听说隔壁是很法国很厉害的大学 站在那里真的会有 一种学术的 很厉害的感觉 听说建筑仿的是意大利的万神庙 那就正好 下一站 意大利！ 最后 巴黎再会~","link":"/2021/12/08/Voyage-Paris/"},{"title":"戛纳动机信","text":"Cannes!!! 开头 Je suis une étudiante en double diplôme à l’Ecole Centrale de Nantes, en vue d’obtenir un diplôme d’ingénieur. Je suis très intéressé par le projet “Trois jours à Cannes” et j’aimerais partager avec vous ma principale motivation. 喜欢电影 J’ai 22 ans et je viens d’une petite ville de Chengdu, une province centrale de Chine. Influencé par mes parents, j’aime regarder des films depuis que je suis enfant. Je suis particulièrement reconnaissant aux films de m’avoir fait découvrir un monde après l’autre pendant mon enfance. Je me souviens du choc que j’ai ressenti en regardant Harry Potter pour la première fois quand j’étais enfant, et je n’ai pas pu me calmer longtemps après. Jouer au Quidditch avec Ron dans mes rêves, m’allonger sur le balcon en attendant ma lettre d’acceptation à Poudlard, lutter pour trouver le quai 9 et 3/4 en prenant le train. Je me souviens aussi d’avoir regardé Les Chroniques de Narnia et d’avoir joué à cache-cache avec mes amis pour ensuite me cacher dans l’armoire, désireuse de s’embarquer dans une aventure où il faut aussi faire preuve de courage. Il n’est pas exagéré de dire que les films ont construit mon enfance. 我今年22岁，来自中国中部省份成都的一个小镇。受父母影响，我从小便喜欢看电影。我特别感谢电影给我童年带我走进了一个又一个的世界。我记得我小时候第一次看哈利波特时的震撼，看完以后久久不能平静。在梦里和罗恩打魁地奇，趴在阳台等霍格沃兹的录取通知书，在乘坐火车时努力的寻找9又3/4站台。我也记得我看完纳尼亚传奇后，从此和朋友玩捉迷藏只躲在衣柜，渴望也能开启一段关于勇气的冒险。毫不夸张的讲，电影构建了我的童年。 Lorsque je suis entré dans l’enseignement secondaire, les films n’étaient jamais absents non plus. Je me souviens d’un cours de musique où le professeur de musique nous a montré un extrait de Les choristes, et depuis lors, les films français, ou plutôt la France, ont commencé à entrer dans mon univers. Après avoir regardé Le fabuleux destin d’Amélie Poulain, j’ai été captivé par la romance créée par le film et en même temps déterminé à faire l’expérience du pays et de la culture française par moi-même pendant mes années d’université. Mais je dois admettre que lorsque j’étais jeune, j’étais immature et j’avais une vision unilatérale du monde, mais ces films sur différents sujets m’ont énormément aidé à construire un système de pensée selon lequel le monde est divers, la beauté est diverse et la vie est diverse, et ces films ont façonné ma tolérance. 升入中学后，电影也从未缺席。还记得那时一节音乐课，音乐老师给我们放了放牛班的春天选段，自此法国电影或者说法国开始进入我的世界。在看完天使爱美丽后，我被电影创造出的浪漫所深深吸引，同时坚定了自己要在大学期间亲历这片土地和法国文化。但我不得不承认，年轻时我的思想并不成熟，看世界的角度也很片面，但这些不同题材的电影给我带来了巨大的帮助，让我建立了一个世界是多元的、美是多元的、生活是多元的思维体系，这些电影塑造了我的宽容。 Le célèbre réalisateur français, Abel Gance a dit : “Ce n’est pas l’image qui fait le film, c’est l’âme de l’image”. Je me rappelle encore comment je me suis sentie chez moi cet après-midi de 2020, lorsque j’ai fini de regarder Le grand bleu de Luc Paul Maurice Besson. La scène où Jean-marc regarde tendrement son amant puis se retourne et se jette dans les bras de la mer est gravée dans mon esprit. Peut-être que les gens viennent au monde avec un but, la vie n’est 1/2 qu’un processus, et suivre son cœur au maximum est aussi une façon de vivre. Jean-marc est né seul et ne pouvait pas combler sa solitude dans la foule, préférant se plonger dans l’obscurité de la mer pour profiter d’un moment de paix. 法国著名导演阿贝尔-甘斯说：“拍摄电影的不是影像，而是影像的灵魂”。我仍然记得2020年的那个下午，当我看完吕克-保罗-莫里斯-贝松的《Le grand bleu》时，我在家里的感觉。让-马克温柔地看着他的爱人，然后转身投入大海的怀抱，这一幕深深地刻在我的脑海里。也许人们来到这个世界上是有目的的，生活是1/2个过程，充分跟随自己的心也是一种生活方式。让-马克生来孤独，在人群中无法填补他的孤独，他宁愿将自己沉浸在黑暗的大海中，享受片刻的宁静。 想来戛纳 J’ai travaillé dur et j’ai pu poursuivre mes études en France comme je le souhaitais, les mots ne peuvent décrire mon excitation lorsque j’ai appris que j’aurais peut-être l’occasion d’aller au Festival du film de Cannes et de voir les meilleurs films du monde entier dans cette belle ville du sud, par une belle journée de mai. Le Festival de Cannes est pour moi un sanctuaire pour le pèlerinage des fidèles, un trésor si beau et si désirable pour les gourmands qui le cherchent tant. Mais aussi comme un bon ami, si familier, qui m’a rencontré dans mes rêves à travers d’innombrables films. C’est peut-être notre seule chance de nous rencontrer dans cette vie. Je pense que je n’oublierai jamais cette rencontre avec le Festival de Cannes et que ce sera l’une des expériences les plus importantes de ma vie. C’est pourquoi je demande au comité de me donner la possibilité de réaliser mon rêve de raconter mon histoire d’été à Cannes. Je vous en serais très reconnaissant. 现在我通过努力，如愿在法国开启我的学习生活，当我得知我可能有机会去参加戛纳电影节，在这个美丽的南方城市看到来自世界各地的最佳影片时，我的兴奋之情难以言表。戛纳电影节对我来说是一个供信徒朝圣的圣地，是一个如此美丽、如此令人向往的宝藏，让那些追求它的饕餮之徒欲罢不能。但也像一个好朋友，如此熟悉，通过无数的电影在梦中与我相遇。这可能是我们今生唯一的见面机会。我想我永远不会忘记这次与戛纳电影节的会面，这将是我人生中最重要的经历之一。这就是为什么我请求委员会给我机会实现我的梦想，在戛纳讲述我的夏季故事。我将非常感激。 结尾 Veuillez agréer, Mesdames, Messieurs, l’expression de ma considération distinguée. Li NI","link":"/2022/05/20/%E6%88%9B%E7%BA%B3%E5%8A%A8%E6%9C%BA%E4%BF%A1-1/"},{"title":"PYTHON_CM2","text":"PYTOHN_CM2 是老师的ipynb文件啦 Structuration et types de données Contenu Variables, références et gestion de la mémoire Programmation fonctionnelle Programmation orientée objet (OOP) : les classes Conseils généraux pour la programmation Rappel : les types de base en python int (entier) float (flottant) str (chaîne de caractères) bool (booléen) list (liste) tuple (tuple) complex (complexe) Variables, références et gestion de la mémoire Variables et affectation En python tout est objet ⟹\\Longrightarrow⟹ la variable v peut changer de type. Definition: Une variable est un identificateur associé à une valeur. En Python, c’est une référence d’objet. 123456v=1print(f&quot;{v=},{type(v)}&quot;)v=&quot;bonjour&quot;print(f&quot;{v=},{type(v)}&quot;)def v(param) : return Noneprint(f&quot;{v=},\\t{v(1)=},\\t{type(v)}&quot;) Sytème d’affectation des variables immutables[可变的和不可变的 不可更改的变量的分配系统] 12345678a=1b=2c=3print(f&quot;{a=}, {b=}, {c=}&quot;)c=bprint(f&quot;{a=}, {b=}, {c=}&quot;)a='z'print(f&quot;{a=}, {b=}, {c=}&quot;) Mutables et non-mutables Les variables simples vue jusqu’ici sont dites non-mutable i.e. on ne modifie jamais le contenu d’une case mémoire on affecte la variable à une nouvelle case Il existe des objets dits mutables, dont le contenu est directement modifié. Par exemple les listes ma_liste=[1,&quot;chaine&quot;] Les listes, mutable par excellence 123L=[1,2,3]L2=L #on crée une nouvelle référenceprint(L==L2)--&gt;True ⚠️ Toute modification par l’un des “pointeurs” entraine une modification de la liste pointée. 任何一个 &quot;指针 &quot;的修改都会导致对被指向的列表的修改。 123L2[2]=10print(L==L2, id(L)==id(L2))#True Trueprint(L) 12L2=4 #on change l'affectation de la variableprint(L==L2)#Flase 123456#Si on veut créer une copie de la liste et pas un pointeur#Copie simpleLcopie=L[:]print(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L))#Flase 123456# Par le module copie import copyLcopie=copy.copy(L) #shallowprint(id(L))print(id(Lcopie))print(&quot;Les deux variables ont la même addresse mémoire ?&quot;,id(Lcopie)==id(L)) Les dictionnaires : “listes” clé/valeur 12valeur=10dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]} 1dictionnaire[&quot;clé&quot;] 1234dic2=copy.copy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire) ⚠️ La “shallow” copy n’a créé de copie que pour le niveau supérieur. Pour tout copier, on utilise copy.deepcopy() 深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。递归拷贝对象中包含的子对象，源对象与拷贝对象所有的子对象也不相同。 12345678dictionnaire={&quot;clé&quot;:valeur,&quot;recursif&quot;:[1,2,3]}dic2=copy.deepcopy(dictionnaire)dic2[&quot;recursif&quot;][1]=50dic2[&quot;complex&quot;]=1+2j #on enrichi le dictionnaireprint(dictionnaire)#on utilise l'opérateur ** pour &quot;unpack&quot; un dictionnaire, très utile pour en concaténer deux#**操作符用于解压一个字典，这对于连接两个字典非常有用new_dic={**dictionnaire,**{&quot;var&quot;:1.2}} Le tuple, une liste non-mutable 1234# exemple de tuplevecteur=(1,0,0)print(f&quot;{vecteur=}, {type(vecteur)=}&quot;)vecteur[1]=2#会报错，因为不能被修改 L’opération précédente est illégale puisque le tuple n’est pas modifiable après sa création. Il faut réallouer la variable par un nouveau tuple contenant la valeur souhaitée. 123vecteur=(vecteur[0],vecteur[1],2)#que l'on peut remplacer par l'opération suivantevecteur=(*vecteur[:1],2) Quelques autres types qui peuvent etre utile set est une collection itérable non ordonnée d’éléments hachables uniques 集合，无序 module collections collections是Python内建的一个集合模块，提供了许多有用的集合类和方法。可以把它理解为一个容器，里面提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。 defaultdic du propose des dictionnaires avec valeur par défaut：当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值，可以是list、set、str等，用法 12from collections import defaultdictdict1 = defaultdict(int) counter bien pratique pour des dictionnaires de dénombrement: 作用是计算出字符串或者列表等中不同元素出现的个数，返回值可以理解为一个字典 deque pour des listes à accés rapide des extrémités (file,tas ):可以实现双端队列 module heapq pour des opérations efficaces sur les tas：实现堆栈 Plus d’infos dans Programmation Python Avancée, X. Olive Gestion de la mémoire Contrairement aux langages plus bas niveau, python gère “automatiquement” la mémoire. Il l’alloue et la libère tout seul. 自动管理内存：自己分配和释放内存 Garbage collector si une donnée en mémoire n’est plus référencée, le garbage collector gc de Python la supprime automatiquement (car son nombre de références tombe à zéro) 12345import sysdonnee=[1,2,3]print(sys.getrefcount(donnee)) # le texte lui meme plus le passage à getrefcountmaliste=donneeprint(sys.getrefcount(donnee)) la fonction del permet de supprimer une référence, pas son contenu. 1del(donnee) Le contenu est nettoyé par le garbage collector automatiquement. On peut néanmoins accéder au gc ainsi 123import gcgc.collect() # fait le ménagegc.get_threshold() # un second mécanisme &quot;générationel&quot; traite les récursions, avec les propriétés suivantes Evaluation de l’usage mémoire Pour des programmes complexes ou traitant de grandes données, on peut suivre l’usage mémoire par profiler Il existe une multitude de solution, la plupart vont aller chercher activement l’usage mémoire à interval regulier (ou lors des allocations) pour obtenir une bonne estimation de l’usage mémoire. Ici, on peut installer l’outil memory_profiler qui s’intègre facilement à jupyter. 1234!mamba install -c conda-forge memory_profiler -y%load_ext memory_profiler# que l'on appelle ensuite ainsi%memit [i for i in range(100000)] Il existe une version ligne par ligne %mprun qui ne fonctionne que pour les fonctions définies dans des fichiers externe. (cf TP) Programmation fonctionelle Fonctions On défini une fonction de la façon suivante: 12345def fonc(x, y=0, *args, **kwargs): &quot;&quot;&quot;Un docstring est fortement recommandé ---docstring?&quot;&quot;&quot; x*y return # même si on ne renvoie rien! Que l’on appèlerai ainsi: 1234567fonc(10,20)#oufonc(10,y=20)#ou, avec les arguments surnuméraires en supposant args et kwargs bien définisargs=[]kwargs={}fonc(10,args, kwargs) Les arguments d'une fonction peuvent etres passés nommés ou non. S'ils ne le sont pas l'ordre est important. Détails sur le passage des arguments 1234def fonc(x, y=0, *args, **kwargs): #actions return &gt;&gt;&gt; fonc(10,args, kwargs) Le passage se fait par assignation et pas par références en soi. C'est à dire, qu'un nouvel alias est créé, pointant vers la case mémoire concernée. Deux cas de figure suivant que l'objet est: immutable : toute modification dans le corps de la fonction entraine une nouvelle assignation/allocation. mutable : toute modification dans le corps de la fonction entraine une modification de l'objet pointé. Donc de l'objet dans l'espace global. ??????? ⚠️ Ne pas utiliser des mutables en valeur par défaut. Leur durée de vie dépasse l’appel de la fonction! 1234567def ajout_liste(L=[],elem=&quot;elem&quot;): #une liste inutile qui ajoute un élément à une liste L.append(elem) print(L)ajout_liste(elem=1)ajout_liste(elem=2) #quel résultat est attendu? Les fonctions sont des objets/variables comme les autres! Mais on peut les appeler (callable). ➡️ On peut passer une fonction comme argument 函数和其他的对象/变量一样！但它们可以被调用（可调用）。➡️ 可以将一个函数作为参数传入 12def fonc2(fonc): return 2*(fonc(100)) On dispose même des fonctions anonymes lambda function qui sont définies à la volée, tant qu’elles sont mono-instruction. 1fonc2(lambda x: x+1) En pratique on les utilisera seulement si l’instruction est très simple et facile à comprendre. Sinon on déclare une nouvelle fonction! 在实践中，只有在指令非常简单和容易理解的情况下才应使用它们。否则，将声明一个新的函数. Type hinting python&gt;=3.5 12def hello_name(name: str) -&gt; str: return(f&quot;Hello {name}&quot;) Portée[范围] des variables Variables locales, variables globales Les variables définies (ou passées) à la fonctions sont locales i.e. accessibles uniquement depuis la fonction et détruites ensuite. Les variables définies à l’extérieur d’une fonction sont des variables globales. Leur contenu est « visible » de l’intérieur d’une fonction, mais la fonction ne peut pas le modifier. 在一个函数之外定义的变量是全局变量。它们的内容在一个函数中是 “可见的”，但函数不能改变它们。 12345x = &quot;global&quot;def foo(): x = x * 2 #会报错，改成1也不行 print(x)foo() On peut aussi utiliser (rarement) le mot clé global pour s’assurer que l’on modifie une variable globale du programme. 123456789x = &quot;global &quot;def foo(): global x # Essayer avec et sans! y = &quot;local&quot; x = x * 2#字符串也有乘法的 print(x) print(y)foo() Le cas nonlocal pour les fonctions imbriqués 123456789def outer(): x = &quot;local&quot; def inner(): nonlocal x x = &quot;nonlocal&quot; print(&quot;inner:&quot;, x) inner() print(&quot;outer:&quot;, x)outer() Paradigme[范式] : La programmation fonctionnelle Un petit peu de théorie de la programmation La programmation impérative 命令式编程 est le paradigme le plus répendu. On découpe le programme en une séquence d'instructions à exécuter. C'est une description de l'algo à exécuter pour résoudre le problème. 🚀 Offre un bon controle de la performmance. La programmation déclarative声明式编程 considère le programme par une description du problème. Le moteur du language met en oeuve l'algo permettant la résolution. C'est un paradigme de programmation sans effet de bord c.à.d. sans état interne permanent. Exemple : Latex, CSS. ✔️ Formel donc permet de prouver que les résultats sont corrects. La programmation fonctionnelle est une variante de programmation déclarative. La programmation est vue comme l'évaluation de fonctions mathématiques sans effet de bord. ☞ Langages fonctionnels : Haskell, Scala, OCaml Par exemple: 12L=[1,3,7,10,-1]L.sort(),L 12L=[1,3,7,10,-1]sorted(L),L La méthode .sort est impérative[命令]. Elle modifie l’input avec une série d’instructions. La fonction sorted suit un modèle fonctionnel, sans effet de bord. Deux appels successifs ne changent pas le résultat. Un programme utile aura toujours des effets de bords, il interragit avec le monde extérieur. Python n’est pas un langage fonctionnel. Cependant, les recommandations de la programmation fonctionnelle: limiter les effets de bord et états internes limiter les mutables programmation qui caractérise la solution plutot que la procédure permettent un style modulaire et donc compsable. En pratique cela facilite aussi le teste et les débugs et certaines accélérations (jit, parallèlisme, GPU). Les bibliothèques pandas et altair ont une approche très fonctionnelle. numpy beaucoup moins comme on le verra. Fonctions pures et d’ordre supérieur Une fonction pure est une fonction dont le résultat dépend uniquement de ses arguments, donc sans effets de bord. En programmation foncitonnelle on utilise que des fonctions pures Une fonction d'ordre supérieur est une fonction qui prend en argument une fonction ou renvoie une fonction. Exercice: Ecrire une fonction pure fibonacci(et récursive) qui calcule le n-ème terme de la suite de Fibonacci. Rappel $f_0=1,f_1=1$ et $\\forall n >1, \\quad f_n=f_{n-1}+f_{n-2}$. 1234def fibonacci(n:int)-&gt;int: if n in [0,1]: return 1 return(fibonacci(n-1)+fibonacci(n-2)) Exercice: Ecrire une fonction d'ordre supérieur n_premiers qui renvoie une fonction qui calcule les n permiers termes de la suite de Fibonacci. 1234from typing import Listdef n_premiers(func: &quot;int -&gt; int&quot;, n: int) -&gt; List[int]:#注意这里参数的是函数 return [func(i) for i in range(n)]print(n_premiers(fibonacci,10)) Exercice: Ecrire une fonction d'ordre supérieur premiers qui renvoie une fonction qui calcule les n permiers termes d'une suite et l'appliquer Fibonacci. 12345#关于这里声明的理解，输出是函数，然后输出的函数式int做输入，list做输出def premiers(func: &quot;int -&gt; int&quot;) -&gt; &quot;int -&gt; List[int]&quot;: def n_premiers_func(n: int) -&gt; List[int]: return n_premiers(func,n) return n_premiers_func 12n_premiers_fibonacci=premiers(fibonacci)n_premiers_fibonacci(10) Deux mots sur les décorateurs Un décorateur de fonction (d’ordre supérieur) est un outil qui permet de marquer une fonction afin d’en modifier le comportement. Il est marqué par le @décorateur avant une fonction. 12345678910111213141516171819from time import timedef timer(func:&quot;fonction&quot;)-&gt;&quot;fonction&quot;: name=func.__name__ def timed_func(*args): t1=time() arg_str=', '.join(repr(arg) for arg in args) resultat=func(*args) elapsed=time()-t1 print(f&quot;{name}({arg_str}) elapsed time [{elapsed:0.8f}s]&quot;) return resultat return timed_func@timerdef factorielle(n: int)-&gt;int: res=1 for i in range(1,n): res*=i return resprint(factorielle(20)) Attention aux fonctions réccursives, l’appel sera affiché à chaque fois! 123456@timerdef factorielle_rec(n: int)-&gt;int: if n in [0,1]: return 1 return n*factorielle_rec(n-1)print(factorielle_rec(20)) Itérateurs et générateurs En programmation fonctionelle, la récursion joue souvent le role d’itérateur à la place des boucles for. Si on voit l’itération comme une structure générique qui fourni un service, alors les structures itérables fournissent des élément un à un sans avoir à les charger intégralement en mémoire. On peut: les parcourir avec un for construire des structures en les consommant les manipuler par compréhension les déballer 12type(range(10))#rangelist(range(10)) Retour sur l’écriture en compréhension On peut utiliser les listes en compréhension pour créer des nouvelles structures et améliorer (un peu) la performance. 1234567%%timeit L=[2*x**3 for x in range(1000000)]#等价于%%timeit #可以用于计时L=[]for x in range(1000000): L.append(2*x**3) Créer ses propres itérateurs avec le mot clé yield Une fonction qui contient le mot-clé yield renvoie un générateur. Lorsqu’une fonction rencontre yield: elle renvoie la valeur courante attend la prochaine itération dans la boucle reprend le programme la ou il s’était arrété La suite de Syracuse est définie ainsi: Pour tout entier nnn, l’entier suivant est défini par new n={n2si n est pair3n+1if n sinon. \\mathrm{new} \\; n = \\begin{cases} \\frac{n}{2} &amp;\\text{si } n \\; \\text{est pair} \\\\[4px] 3n+1 &amp; \\text{if } n \\text{ sinon}.\\end{cases}newn={2n​3n+1​si nest pairif n sinon.​ Exercice: Ecrire un générateur de al suite de Syracuse grâce au mot-clé yield. Y ajouter une fonction qui calcule la longueur jusqu'à atteindre 1 length et celle qui donne la hauteur max max 123456&gt;&gt;&gt; def syracuse(n: int)-&gt;&quot;generator&quot;:&gt;&gt;&gt; ...&gt;&gt;&gt; yield n&gt;&gt;&gt;&gt;&gt;&gt; list(syracuse(10))[10, 5, 16, 8, 4, 2, 1] 123456789101112131415def syracuse(n: int)-&gt;&quot;generator&quot;: yield n #première itération, renvoie simplement l'input (pas de récursion ici) while n!=1: # le programme s'interrompt lorsque n=1, comme prévu if n%2==0: n=n//2 else: n=3*n+1 yield n # renvoie la nouvelle valeur de n à chaque passagelist(syracuse(10)) #[10,5,16,8,4,2,1]def length(iterable): return sum(1 for _ in iterable)length(syracuse(27))#122# trick&quot;-&gt;&quot;.join(str(i) for i in syracuse(27)) Pour aller plus loin : le module itertools permet des manipulations poussées des itérateurs la fonction next renvoie la première valeur du générateur les coroutines consomment des éléments à chaque appel Des “built-ins” et functool map map(func, sequence) applique une fonction à tous les éléments d’une séquence avec évaluation paresseuse (lazy). 12map(fibonacci,[1,10,20])list(map(fibonacci,[1,10,20])) filter filter(func,x) fonctionne de la même façon et renvoie les éléments de x pour lesquels func renvoie vrai. 123def paire(n:int)-&gt;bool: return(n%2==0)list(filter(paire,[1,10,11])) reduce reduce(func,x) applique de façon cummulative [累积] la fonction func aux éléments de x. 12345from functools import reducefrom operator import addreduce(add,[1,10,100])#sum fait le meme travail...sum([1,10,100]) Dans le meme esprit on a : any et all pour les opérations booléennes Programmation orientée objet Python est un langage fondamentalement orienté objet (OOP), les classes, instances et méthodes étant omniprésentes. A reprendre au tableau Quelques notions à avoir en tete avant de commencer : encapsulation: l’objet embarque toutes ses propriétés (varibales, méthodes) dans un espace de nommage 封装 interface: on part du service rendu qui est présenté à l’utilisateur pour concevoir la machinerie interne 接口 factorisation [结构化]: on mutualisera au maximum les portions de code similaires grace aux concepts d’héritage[继承] et de composition[组合] Les classes On va suivre l’excellente présentation du livre de Xavier Olive, “Programmation python avancée” qui utilise les “Boids” Un Boid (bird-oid) est une représentation simplifiée proposée par Craig Reynolds pour modéliser le comportement d’oiseaux avec les regles suivantes : de séparation pour préserver une distance minimum entre les individus de cohésion pour que les boids volent en groupe d’alignement pour qu’ils volent dans la meme direction [博伊德（鸟类）是克雷格-雷诺兹提出的一种简化表示法，用于模拟鸟类的行为，其规则如下。 隔离*以保持个人之间的最小距离 凝聚力*，从而使boids成群结队地飞行 对齐*，使它们飞向同一方向] Création d’une classe 123import numpy as npclass Boid: pass 12b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1 Attention: Il n'y a pas de notion d'attributs publics et privés en python[没有私有或者公有的概念] ! On utilisera des attribus pseudo privés notés par _x Une méthode est une “fonction” définie dans le corps de la classe et qui vie dans son espace de nommage. 1234567class Boid: def module_vitesse(self): return np.sqrt(self.v_x**2+self.v_y**2) b=Boid()b.x, b.y, b.v_x, b.v_y= 0,0, 1, 1b.module_vitesse() La méthode réservée __init__ est le constructeur de la classe. Il est appelé chaque fois que cette classe est instanciée. 123456789101112class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y 123b=Boid((0,0),(1,2))b.avance()b __repr__(self) -&gt; str définie une représentation de l’objet qui est renvoyée par l’interpréteur __str__(self) -&gt; str est l’affichage renvoyé par print(). Renvoie __repr__ si non défini 1234567891011121314class Boid: def __init__(self, position: tuple, vitesse: tuple)-&gt; None: self.x, self.y=position self.v_x, self.v_y=vitesse def module_vitesse(self)-&gt;float: return np.sqrt(self.v_x**2+self.v_y**2) def avance(self) -&gt; None: self.x += self.v_x self.y += self.v_y def __repr__(self)-&gt;str: return f&quot;Boid({self.x,self.y}, {self.v_x,self.v_y})&quot; 123b=Boid((0,0),(1,2))b.avance()b On peut choisir de programmer des méthodes qui modifient ou non l'état interne. De même, on peut choisir des méthodes qui renvoient ou non un résultat. Arguments par défaut. On veut pouvoir initialiser automatiquement nos instances (avec un peu de hasard). C’est l’idée programmatique de factory. Une variable de classe est une variable qui est liée à la classe et non à l’instance. 1234567891011121314151617181920212223242526class Boid: taille = 300 # dimension du domaine des positions count = 0 def __init__(self, position=None, vitesse=None) -&gt; None: self.x = ( position if position is not None else np.random.uniform(-Boid.taille, Boid.taille, 2) ) self.dx = vitesse if vitesse is not None else np.random.uniform(-5, 5, 2) Boid.count +=1 def __repr__(self) -&gt; str: return f&quot;Boid({self.x.round(2)}, {self.dx.round(2)}, parmi {Boid.count})&quot; def vitesse(self)-&gt; float: return np.linalg.norm(self.dx) def avance(self) -&gt; &quot;Boid&quot;: return Boid(self.x+self.dx, self.dx) def __del__(self): #on implémente un destructeur pour s'assurer que count est mis à jours correctement Boid.count-=1 print('__del__ was called') 123b=Boid()c=b.avance()b, c 123b=0del(b)c=None 1Boid.count ☣️ Nous n'avons pas de contrôle direct sur le garbage collector. Le comportement est plus reproductible sur un appel python type python file.py Décorer ses objets A défaut d’attributs privés, on peut imposer certains comportements: @property définit un raccourcis qui s’utilise comme une variable. (utile de l’ustiliser avec _var_name pour “protéger” une variable. @var_name.setter pour pouvoir modifier la valeur de la variable On défini une propriété vitesse de la façon suivante 1234567@propertydef vitesse(self) -&gt; float: return np.linalg.norm(self.dx)@vitesse.setterdef vitesse(self, value: float) -&gt; None: self.dx = self.dx * value / self.vitesse De même il est parfois utile de définir une nouvelle façon d’initialiser une instance de notre classe. Le décorateur @classmethod le permet: 123@classmethoddef polaire(cls, r, theta, v, direction): return cls(r*np.array([np.cos(theta),np.sin(theta)]),v*np.array([np.cos(direction),np.sin(direction)])) Enfin, on peut souhaiter encapsuler une “fonction” dans une classe par exemple pour controler sa visibilité. On utilisera le décorateur @staticmethod lors de la déclaration de la fonction. 123@staticmethoddef scene(n:int) -&gt; &quot;list[Boid]&quot;: return [Boid() for _ in range(n)] Exercice : Make'em fly Avec le squellette de classe fourni dans boid_partial.py, faire voler la nuée. Appel pour exécuter le script et tracer la figure. La classe animation est déjà écrite. 1234567891011fig, ax = plt.subplots(figsize=(7, 7))simulation = Simulation(n=100, ax=ax)anim = animation.FuncAnimation( fig, simulation.iteration, frames=range(0, 200), interval=150, blit=True, repeat=True,)anim.save(&quot;boids.mp4&quot;) On pourra aussi jouer avec les variables de classes qui modifient le rapport de force entre les composantes qui dirigent le vol. 1234sep_coef=10align_coef=8cohere_coef= 100centripete_coef= 200 Héritage et composition Une classe fille peut hériter des propriétés (et méthodes) d’une classe mère. Ceci permet de factoriser efficacement le code. Attention, dans bien des cas, une relation de composition est plus judicieuse. Dans ce cas, un des attribus de la classe est un objet d’une autre classe. 123456789101112131415161718192021222324# exemple d'héritage: class Personne: def __init__(self, nom, prenom, age): self.nom=nom self.prenom=prenom self.age=age def __repr__(self): return f&quot;{self.nom} {self.prenom} ({self.age}ans)&quot; def gen_ID(self): return (self.nom+self.prenom[0]).lower() def anniversaire(self): self.age+=1 print(&quot;Joyeux anniversaire&quot;) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; 123eleve=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)print(eleve.anniversaire())print(super(eleve).name) 123456789101112131415161718192021#Exemple de compositionclass Bulletin: def __init__(self, date, notes :&quot;ndarray&quot;): self.date=date self.notes=notes def moyenne(self): return np.average(notes) class Eleve(Personne): #La classe Eleve herite de toutes les proprietes de Personne def __init__(self, nom, prenom, age): super().__init__(nom, prenom, age) self.student_ID=&quot;S&quot;+self.gen_ID() self.bulletins=[] def __repr__(self): return super().__repr__()+f&quot; {self.student_ID}&quot; def meilleure_note(self): return np.array([B.notes for B in self.bulletins]).max() 1234jean=Eleve(&quot;Dupont&quot;, &quot;Jean&quot;, 10)jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,2,1])))jean.bulletins.append(Bulletin(&quot;2021&quot;,np.array([10,11,20,1])))jean.meilleure_note() Quelques conseils de structuration Bien comprendre le problème et le cahier des charges analyser le problème quels sont les objectifs quel structure générale est nécessaire exécutable script API quelles sont les classes/variables de haut niveau choisir le bon environnement de travail Ebauche écrire un petit code test n’est pas interdit créer les grandes structures et fonctions en premier, quitte à les laisser vide mais commentées &quot;simple is beautiful&quot; -&gt; zen of python Dev / Test si possible écrire les tests / appels API en premier -&gt; contraint le dev dans la bonne direction test driven programming? s’assurer du bon fonctionnement des briques élémentaires au fur et à mesure Rappel : développer c'est environs 90% de débuggage => Il faut absolument écrire du code lisible!! Vers un code en production : Optimisation et parallèlisme Optimisation ne pas chercher à optimiser dès le départ mais avoir en tête un ensemble de pratiques favorables utiliser des outils de profiling Améliorer son code python / algo Utiliser (mieux) des libraries Chercher des améliorations techniques (JIT, langages compilés) Parallèlisation python n’est pas très propice au // un bon code séquentiel est un prérequis absolu dans quelques cas, on pourra avoir un gain de performance pour les tableaux : calcul GPU","link":"/2022/09/16/PYTHON_CM2/"},{"title":"遗传算法","text":"遗传算法 帮ZZ做SRTP学的一些东西 1.简介 一些生物学常识 基因型、表现型 进化：群体，个体，适应度(Fitness) 优化问题–&gt;优化问题模型 f(X)目标函数+约束条件 求最优化问题的方法：枚举，启发式算法（？），搜索 遗传算法中的基本过程 选择：按照个体适应度，按照一定的规则，从t代群体P（t）中选择优良个体遗传到P（t+1） 交叉 ：将P（t）内的各个个体随机搭配成对，以每一对个体，以某个概率交换 变异：对群体P（t）中的每一个个体，以某一概率改变某一个或者某一些值 流程 群体：可行解编码成基因的个体的一个集合 模拟遗传算法的简单实例 个体编码 初始群体的产生 选取起始搜索点的初始群体数据，需要选取群体规模，这里选4。个体则随机产生 适应度计算 这里直接以目标函数为适应度 第6列表示适应度概率，7进行选择，注意选择完成时，群体规模是保持不变的 ​ 9,10,11进行交叉的过程：配对的第2位进行交叉（等位基因） ​ 12,13进行变异 ​ 13产生子代群体，完成一次迭代。 最优解可由迭代次数决定 2.基本的遗传算法 遗传算法解决TSP问题 问题抽象 1.如何将答案编码成基因 旅行路线–&gt;一个数组 2.如何定义个体适应度 路程（目标函数）","link":"/2022/07/29/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"title":"那些细碎而美好的存在","text":"序 一个持续更新的日常记录 2022_2_1 我画画真好看，嘿嘿 以及，新的学期新的摸鱼 2022_2_2 -经过一天的讨论，滑雪假兜兜转转起起伏伏，最终成为了和学长一起的法国自驾游（开心期待 -希望快点长大到可以开着车向着随机方向选择随机地点随机停留的那天 -莫名其妙的去测了MBTI，第三次了吧，真的好神奇，还是INFJ，从高考填志愿到大一再到今天。 2022_2_3 安然给的国家爸爸发的大白兔，四舍五入我也收到大使馆的春节礼物啦 2022_2_4 很难不记录 2022_2_7 周六周末没有学习，可恶 看到一个好有意思的财神爷饭，周五做给大家吃，期待复刻，嘿嘿 2022_2_9 关于财神饭的复刻,成功! 2022_2_10 谷爱凌nb！！！！！以及抓摸鱼的zwl子 2022_2_11 摸了一个谷爱凌和意外好吃的番茄牛奶辣椒粥 2022_2_12 旅行途中遇到的可可爱爱的善意们 2022_2_21 春天来了 2022_3_4 可以做梦不补考吗(靓女流泪 2022_3_7 好好听 2022_8_8 突然更新 和学长们告别 和贺文城告别 不喜欢告别 2022_8_20 想记录遇见的可爱的人们的那些陌生的善意。 去罗卡角火车上疯狂葡萄牙语输出的阿姨 一直说着CHINA和FRIENDSHIP大概是巴基斯坦的里斯本纪念品店老板 巴塞罗那机场把叫住我们的爷爷奶奶 领着我们走到地铁站的伏林航空的空姐 去往圣家堂小路上因为给窗台上的猫猫打了招呼，抱起了第二只猫猫向我们挥手的叔叔 酷酷又温柔的音乐人房东的香香的洗衣液 热情良善家庭美满的司机师傅 我想记住这些 宇宙温暖，人间也值得 2022_8_22 千山茶客的女将星好好看！ 又哭又笑的看了一整个通宵 肖钰：“凉州城外，有一处峰台，名曰乘风。这些女子生前身不由己，笼鸟池鱼。葬在此处，愿她们来生自由乘风，啸傲湖山吧。” 宴宴：&quot;手中执剑之人，更应该明白剑锋所指何处，是对着身前的人，还是身后的弱者。 我绝不向弱者拔剑。 手中执剑之人，更应该明白剑锋所指何处，是对着身前的敌人，还是身后的弱者。&quot;故在生死间救下女俘虏，提着剑挡在她们面前。“……你若让那些女子也如我一般，见过凉州卫的雪，见过济阳城的水，见过大漠长月，见过江海山川，你说，她们还会不会甘心困在争风吃醋的宅院，还会不会沾沾自喜，麻木愚昧？……因为他们也知道，一旦女子们有了‘选择’的机会，是决计不肯成为后宅里一位伸手等着夫君喂养的花瓶的。那些优秀的女子，会成为将领，成为侠客，成为文士，成为幕僚，与他们争夺天下间的风采，而他们，未必能赢。” 如同背着大刀跨过洗墨江，劈开黑暗的周翡 我真的永远喜欢和敬佩这些女孩，也愿意相信贤昌馆少年郎们真的存在过。 2022_8_27 微博看到的句子 “为什么开学要庆祝” “庆祝有学上，有书读，有知识，有成长，有前途，有未来” 突然也就没有那么怕了 2022_8_29 救命好久好久好久没有这么撑过了","link":"/2022/02/01/%E7%BB%86%E7%A2%8E%E8%80%8C%E7%BE%8E%E5%A5%BD/"}],"tags":[{"name":"循环不变量","slug":"循环不变量","link":"/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"},{"name":"图灵机","slug":"图灵机","link":"/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"},{"name":"SAT","slug":"SAT","link":"/tags/SAT/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"ALGORITHM","slug":"ALGORITHM","link":"/tags/ALGORITHM/"},{"name":"全排列","slug":"全排列","link":"/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"指针与引用","slug":"指针与引用","link":"/tags/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"},{"name":"Récursivité","slug":"Recursivite","link":"/tags/Recursivite/"},{"name":"DNN","slug":"DNN","link":"/tags/DNN/"},{"name":"metaverse","slug":"metaverse","link":"/tags/metaverse/"},{"name":"BBC_6mintues","slug":"BBC-6mintues","link":"/tags/BBC-6mintues/"},{"name":"haskell","slug":"haskell","link":"/tags/haskell/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"palindromique","slug":"palindromique","link":"/tags/palindromique/"},{"name":"fibonacci","slug":"fibonacci","link":"/tags/fibonacci/"},{"name":"lidar","slug":"lidar","link":"/tags/lidar/"},{"name":"模型融合","slug":"模型融合","link":"/tags/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"Curryfication","slug":"Curryfication","link":"/tags/Curryfication/"},{"name":"lameda","slug":"lameda","link":"/tags/lameda/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"flod","slug":"flod","link":"/tags/flod/"},{"name":"SOFTSKILLS","slug":"SOFTSKILLS","link":"/tags/SOFTSKILLS/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"DS","slug":"DS","link":"/tags/DS/"},{"name":"SysML","slug":"SysML","link":"/tags/SysML/"},{"name":"算法基础","slug":"算法基础","link":"/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Paris","slug":"Paris","link":"/tags/Paris/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"生活区","slug":"生活区","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/"},{"name":"NANTE_EI2|1","slug":"NANTE-EI2-1","link":"/categories/NANTE-EI2-1/"},{"name":"杂谈","slug":"生活区/杂谈","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/%E6%9D%82%E8%B0%88/"},{"name":"SWJTU","slug":"SWJTU","link":"/categories/SWJTU/"},{"name":"ALGOA","slug":"NANTE-EI2-1/ALGOA","link":"/categories/NANTE-EI2-1/ALGOA/"},{"name":"ALGORITHM","slug":"SWJTU/ALGORITHM","link":"/categories/SWJTU/ALGORITHM/"},{"name":"NANTE_第一年","slug":"NANTE-第一年","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/"},{"name":"ALGORITHM","slug":"NANTE-第一年/ALGORITHM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ALGORITHM/"},{"name":"学习区","slug":"学习区","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/"},{"name":"ANG","slug":"NANTE-第一年/ANG","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/ANG/"},{"name":"CCUBE","slug":"NANTE-第一年/CCUBE","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/CCUBE/"},{"name":"INDUR","slug":"NANTE-EI2-1/INDUR","link":"/categories/NANTE-EI2-1/INDUR/"},{"name":"MATHS","slug":"NANTE-第一年/MATHS","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/MATHS/"},{"name":"PFONC","slug":"NANTE-EI2-1/PFONC","link":"/categories/NANTE-EI2-1/PFONC/"},{"name":"PRO20","slug":"NANTE-第一年/PRO20","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/PRO20/"},{"name":"PYTHON","slug":"NANTE-EI2-1/PYTHON","link":"/categories/NANTE-EI2-1/PYTHON/"},{"name":"SSTEM","slug":"NANTE-第一年/SSTEM","link":"/categories/NANTE-%E7%AC%AC%E4%B8%80%E5%B9%B4/SSTEM/"},{"name":"暑假的乱七八糟","slug":"学习区/暑假的乱七八糟","link":"/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/%E6%9A%91%E5%81%87%E7%9A%84%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"},{"name":"Voyage","slug":"生活区/Voyage","link":"/categories/%E7%94%9F%E6%B4%BB%E5%8C%BA/Voyage/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"个人详细介绍","link":"/about/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"}]}