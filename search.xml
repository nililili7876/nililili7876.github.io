<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ALGORITHM-Prem</title>
    <url>/2021/12/06/ALGORITHM-Prem/</url>
    <content><![CDATA[<h1 id="Prem"><a href="#Prem" class="headerlink" title="Prem"></a>Prem</h1><p>问题描述：全排列问题的两种递归实现</p>
<span id="more"></span>
<p>1.DFS(来自啊哈算法一书)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step , <span class="keyword">int</span> n ,<span class="keyword">int</span> book[] , <span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step == n )<span class="comment">//排到第n个数，排列完成</span></span><br><span class="line">	&#123;</span><br><span class="line">		print(a,n);</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//【返回之前一步，很重要】</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一步的操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!book[i])<span class="comment">//还没有排</span></span><br><span class="line">	&#123;</span><br><span class="line">		a[step] = i+<span class="number">1</span>;</span><br><span class="line">		book[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//开始排下一个了</span></span><br><span class="line">		dfs(step+<span class="number">1</span>,n,book,a);</span><br><span class="line">				book[i] = <span class="number">0</span>;<span class="comment">//排序完成，回收本次数【！！！】</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS：深度优先搜索，这里的DFS不单指图论，理解为一种递归的思想。下一步操作与当下操作是一样的,一直执行，直到符合条件。基本模型为：</p>
<p> void dfs(int step)<br> {<br>    判断边界(递归结束条件)return;<br>    尝试每一种可能<br>    for(int i = 0 ; i &lt; n ; i++)<br>     {<br>         继续下一步 dfs(step + 1);<br>      }<br>      return ;<br> }</p>
]]></content>
      <categories>
        <category>SWJTU</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>ALGORITHM</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGORITHM-期末</title>
    <url>/2021/12/06/ALGORITHM-%E6%9C%9F%E6%9C%AB/</url>
    <content><![CDATA[<h1 id="期末实验汇总"><a href="#期末实验汇总" class="headerlink" title="期末实验汇总"></a>期末实验汇总</h1><p>西南交通大学算法实验期末题型汇总</p>
<span id="more"></span>
<h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><h4 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h4><ol>
<li><p>找所有构成凸包的点</p>
<p>对由n个点构成的集合S中每两个点进行遍历，判断这两点是否能构成凸多边形的边。如果能，则将这两点的标志位flag置位1。具体判断方法为：集合S内的所有点都在这两个点构成边的同一侧。(一侧的判断由ax+by&gt;=c的点的个数为n-2或0完成)</p>
</li>
<li><p>（以凸包内一点）用的斜率反推角度进行逆时针排序</p>
<p>说明：本算法中因输入设置为当x==0&amp;&amp;y==0时停止输入，因此在选择计算凸包边界各点的斜率的原点时选用(0,0)。</p>
</li>
</ol>
<p>角度求解（由于atanx的范围为-π/2到π/2，但a的实际范围为-π到π，因此在求角度时要进行不同情况的判断计算）：</p>
<p>​      x = 0 ：y &gt; 0 时，a = π / 2；y &lt; 0 时，a = - π / 2 ; </p>
<p>​      a = atan(y / x) : 第一象限 x&gt;0,y&gt;0 :a = a;第二象限：x<0,y>0,a= a +π；第三象限：x<0,y<0,a= a +π；第四象限：x>0,y&lt;0,a= a +2π</p>
<p>排序:用algorithm库封装的sort函数用每个点的角度信息对点进行快排，输出并压入数组Q。</p>
<ol>
<li>计算凸包边长</li>
</ol>
<p>依次计算数组Q中相邻点的距离，即distance(p[i],p[i+1])，注意加上首尾即distance(p[0],p[n-1])求得周长。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point Q[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Point P[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;凸包的顺序输出为：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            Q[k] = P[i];</span><br><span class="line">            cout &lt;&lt;k&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; Q[k].x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Q[k].y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己定义的排序规则:按角度排</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Point&amp; p_1, <span class="keyword">const</span> Point&amp; p_2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p_1.a &lt; p_2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使其按逆时排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortP</span><span class="params">(Point P[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!P[i].x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(P[i].y &lt; <span class="number">0</span>) P[i].a = <span class="number">3.0</span>*PI / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">else</span> P[i].a = PI / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            P[i].a = <span class="built_in">atan</span>((<span class="keyword">double</span>)P[i].y / P[i].x); <span class="comment">//一象限不变</span></span><br><span class="line">            <span class="keyword">if</span> (!P[i].y) <span class="keyword">if</span> (P[i].x &lt; <span class="number">0</span>) P[i].a = PI;<span class="comment">//0和PI的判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (P[i].a * P[i].y  &lt; <span class="number">0</span>) P[i].a += PI;<span class="comment">//二、三象限加PI</span></span><br><span class="line">            <span class="keyword">else</span>  &#123;<span class="comment">//四象限加2*PI</span></span><br><span class="line">                <span class="keyword">if</span> (P[i].y &lt; <span class="number">0</span>)P[i].a += <span class="number">2</span> * PI;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(P , P+n , comp);<span class="comment">//按序排</span></span><br><span class="line">    <span class="built_in">print</span>(P, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查点在不在线一侧</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OneSide</span><span class="params">(Point P[], <span class="keyword">int</span> n ,<span class="keyword">int</span> a , <span class="keyword">int</span> b ,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign_1 = <span class="number">0</span>, sign_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a * P[k].x + b * P[k].y == c) &#123;</span><br><span class="line">            ++sign_1;</span><br><span class="line">            ++sign_2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a * P[k].x + b * P[k].y &gt; c) ++sign_1;</span><br><span class="line">        <span class="keyword">if</span> (a * P[k].x + b * P[k].y &lt; c) ++sign_2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign_1 == n || sign_2 == n)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvexHull</span><span class="params">(Point P[] ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = P[j].y - P[i].y;</span><br><span class="line">            <span class="keyword">int</span> b = P[i].x - P[j].x;</span><br><span class="line">            <span class="keyword">int</span> c = P[i].x * P[j].y - P[i].y * P[j].x;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OneSide</span>(P, n, a, b, c))&#123;</span><br><span class="line">                P[i].flag = <span class="number">1</span>;</span><br><span class="line">                P[j].flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sortP</span>(P, n);<span class="comment">//打印</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> Point&amp; p_1 , <span class="keyword">const</span> Point&amp; p_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p_1.x - p_2.x)* (p_1.x - p_2.x) + (p_1.y - p_2.y) * (p_1.y - p_2.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算凸包的边长</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">c_ConvexHull</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n<span class="number">-1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[i].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[i].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line">        sum += <span class="built_in">distance</span>(Q[i], Q[i + <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首尾</span></span><br><span class="line">    sum += <span class="built_in">distance</span>(Q[<span class="number">0</span>], Q[n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point P[M];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入点集：&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; !y)<span class="keyword">break</span>;</span><br><span class="line">         P[i].x = x;</span><br><span class="line">         P[i].y = y;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">ConvexHull</span>(P, i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;凸包周长是：&quot;</span> &lt;&lt; <span class="built_in">c_ConvexHull</span>(i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gramph算法"><a href="#Gramph算法" class="headerlink" title="Gramph算法"></a>Gramph算法</h3><h4 id="文字描述-1"><a href="#文字描述-1" class="headerlink" title="文字描述"></a>文字描述</h4><p>总体思路：先找到凸包上的一个点，然后从该点开始有方向的逐个寻找凸包上的点。</p>
<p>1.点集中纵坐标最小的点一定是凸包上的点，将其作为原点P0，重新求解点集S</p>
<p>2.计算点集中所有点相对于P0的幅角a，对其排序。a相同时，距离小的排在前面。P0、p1入栈。</p>
<p>3.连接P0和栈顶的点，得到直线L。看p1后面的点（即p2,计作当前点）是在直线L的右边还是左边。如果在直线的右边就执行步骤4；如果在直线的左边（上）就执行步骤5。</p>
<p>4.如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤3。</p>
<p>5.当前点是凸包上的点，把它压入栈，执行步骤6。</p>
<p>6.检查P2是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把P2后面那个点做当前点，返回步骤3。</p>
<p>最终栈中为凸包各点的按序存储</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[M];<span class="comment">//inout</span></span><br><span class="line">Point Q[M];<span class="comment">//output</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> Point&amp; p_1, <span class="keyword">const</span> Point&amp; p_2)</span><span class="comment">//距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p_2.x - p_1.x) * (p_2.x - p_1.x) + (p_2.y - p_1.y) * (p_2.y - p_1.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">(<span class="keyword">const</span> Point&amp; p_1, <span class="keyword">const</span> Point&amp; p_2, <span class="keyword">const</span> Point&amp; p_3)</span><span class="comment">//叉积公式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p_2.x - p_1.x) * (p_3.y - p_1.y) - (p_3.x - p_1.x) * (p_2.y - p_1.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; p_1, <span class="keyword">const</span> Point&amp; p_2)</span><span class="comment">//极角排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pp = <span class="built_in">x</span>(p_1, p_2, P[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (pp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">distance</span>(P[<span class="number">0</span>], p_1) &lt; <span class="built_in">distance</span>(P[<span class="number">0</span>], p_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graham</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//Graham算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i].y &lt; P[k].y || (P[i].y == P[k].y &amp;&amp; P[i].x &lt; P[k].x)) k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(P[<span class="number">0</span>], P[k]);</span><br><span class="line">    <span class="built_in">sort</span>(P + <span class="number">1</span>, P + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">2</span>;</span><br><span class="line">    Q[<span class="number">0</span>] = P[<span class="number">0</span>], Q[<span class="number">1</span>] = P[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//去共线</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">x</span>(Q[top - <span class="number">2</span>], Q[top - <span class="number">1</span>], P[i]) &lt;= <span class="number">0</span>) top--;  </span><br><span class="line">        Q[top++] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; Q[i].x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Q[i].y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        sum += <span class="built_in">distance</span>(Q[i], Q[i + <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    sum += <span class="built_in">distance</span>(Q[<span class="number">0</span>], Q[n - <span class="number">1</span>]);<span class="comment">//首尾</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入点集：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x&gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; !y)<span class="keyword">break</span>;</span><br><span class="line">        P[i].x = x;</span><br><span class="line">        P[i].y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">Graham</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;凸包是：&quot;</span> ;<span class="built_in">show</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;凸包周长是：&quot;</span>&lt;&lt; <span class="built_in">sum</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="文字描述-2"><a href="#文字描述-2" class="headerlink" title="文字描述"></a>文字描述</h4><p>无</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define PI 3.1415926</span><br><span class="line">#define M 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    double a = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Point P[M];//input</span><br><span class="line">Point Q[M];//output</span><br><span class="line">int book[M];//标记点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算三角形面积</span><br><span class="line">int area_t(Point p1, Point p2, Point pi)</span><br><span class="line">&#123;</span><br><span class="line">    return p1.x*p2.y + pi.x*p1.y + p2.x*pi.y - pi.x*p2.y - p2.x*p1.y - p1.x*pi.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//角度排</span><br><span class="line">int comp(const Point&amp; p_1, const Point&amp; p_2)</span><br><span class="line">&#123;</span><br><span class="line">    return p_1.a &lt; p_2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//横坐标</span><br><span class="line">bool cmp(const Point&amp; p1, const Point&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">    if(p1.x==p2.x) return p1.y&lt;p2.y;</span><br><span class="line">    return p1.x&lt;p2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Point P[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    cout &lt;&lt;&quot;relusts:&quot;;</span><br><span class="line">    for (int i = 0; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if (book[i])</span><br><span class="line">        &#123;</span><br><span class="line">            Q[k] = P[i];</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; Q[k].x &lt;&lt; &quot;,&quot; &lt;&lt; Q[k].y &lt;&lt; &quot;)&quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使其按逆时排列</span><br><span class="line">void mysort_P(Point *P, int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!P[i].x)</span><br><span class="line">        &#123;</span><br><span class="line">            if(P[i].y &lt; 0) P[i].a = 3.0*PI / 2.0;</span><br><span class="line">            else P[i].a = PI / 2.0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            P[i].a = atan((double)P[i].y / P[i].x); //一象限不变</span><br><span class="line">            if (!P[i].y) if (P[i].x &lt; 0) P[i].a = PI;//0和PI的判断</span><br><span class="line">                else if (P[i].a * P[i].y  &lt; 0) P[i].a += PI;//二、三象限加PI</span><br><span class="line">                else  &#123;//四象限加2*PI</span><br><span class="line">                    if (P[i].y &lt; 0)P[i].a += 2 * PI;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(P , P+n , comp);//按序排</span><br><span class="line">    print(P, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 递归求凸包</span><br><span class="line">// ps 是当前要求解的点的集合，ps保存这些点在points数组中的下标</span><br><span class="line">// mode 表示递归s1 s2，还是递归s3，s4，还是同时递归 s1，s2，s3，s4</span><br><span class="line">// mode = 3 递归 s1，s2，s3，s4，只有第一次调用会出现该情况</span><br><span class="line">// mode = 2 递归s3，s4</span><br><span class="line">// mode = 1 递归s1 s2</span><br><span class="line">void ConvexHull(vector&lt;int&gt; &amp;ps, int mode)</span><br><span class="line">&#123;</span><br><span class="line">    // 边界处理：少于两个点的集合一定是凸包上的点</span><br><span class="line">    if(ps.size()&lt;=2)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;ps.size(); i++) book[ps[i]]=1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最左右一定是凸包上的点， pa最左点，pb最右点</span><br><span class="line">    book[ps.front()]=1, book[ps.back()]=1;</span><br><span class="line">    Point pa=P[ps.front()], pb=P[ps.back()];</span><br><span class="line"></span><br><span class="line">    // 找距离 pa，pb组成的直线最远的点，imax是上方最远，imin是下方最远</span><br><span class="line">    int maxs=INT_MIN, mins=INT_MAX, imax=-1, imin=-1;</span><br><span class="line">    for(int i=1; i&lt;ps.size()-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int s = area_t(pa, pb, P[ps[i]]);</span><br><span class="line">        if(s&gt;maxs &amp;&amp; s&gt;=0) maxs=s, imax=ps[i];</span><br><span class="line">        if(s&lt;mins &amp;&amp; s&lt;=0) mins=s, imin=ps[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // pa,pb与imax，imin的连线，分割出下一趟递归的点集合 s1 s2 s3 s4</span><br><span class="line">    vector&lt;int&gt; s1, s2, s3, s4;</span><br><span class="line">    for(int i=0; i&lt;ps.size()-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(area_t(pa, P[imax], P[ps[i]]) &gt;= 0) s1.push_back(ps[i]);</span><br><span class="line">        if(area_t(pa, P[imin], P[ps[i]]) &lt;= 0) s3.push_back(ps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1; i&lt;ps.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(area_t(P[imax], pb, P[ps[i]]) &gt;= 0) s2.push_back(ps[i]);</span><br><span class="line">        if(area_t(P[imin], pb, P[ps[i]]) &lt;= 0) s4.push_back(ps[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(mode==3)</span><br><span class="line">        ConvexHull(s1, 1), ConvexHull(s2, 1), ConvexHull(s3, 2), ConvexHull(s4, 2);</span><br><span class="line">    else if(mode==1) ConvexHull(s1, 1), ConvexHull(s2, 1);</span><br><span class="line">    else if(mode==2) ConvexHull(s3, 2), ConvexHull(s4, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算凸包的面积</span><br><span class="line">double s_ConvexHull(int n)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for (int i = 1 ; i &lt; n-2 ; i++)</span><br><span class="line">        sum += fabs(area_t(Q[0],Q[i],Q[i+1]))/2;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, x, y;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; ps(n);</span><br><span class="line">    for(int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">        ps[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(P, P + n, cmp);</span><br><span class="line">    ConvexHull(ps, 3);</span><br><span class="line">    mysort_P(P, n);</span><br><span class="line">    cout&lt;&lt;&quot;ConvexHull&#x27;s area is:&quot;&lt;&lt;s_ConvexHull(n);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="蛮力法-1"><a href="#蛮力法-1" class="headerlink" title="蛮力法"></a>蛮力法</h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20</span></span><br><span class="line"><span class="keyword">int</span> max_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_a[M];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(max_a , max_a + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;获胜者所选取的商品编号为：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++) cout &lt;&lt; max_a[i]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;获胜者所能选取的商品的总重量和总的价格为：&quot;</span> &lt;&lt; max_weight&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;max_value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a[] ,<span class="keyword">int</span> n , <span class="keyword">int</span> m , <span class="keyword">int</span> object[M][<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; m)<span class="keyword">break</span>;</span><br><span class="line">        weight += object[a[i] - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        value += object[a[i] - <span class="number">1</span>][<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    k = i;</span><br><span class="line">    value = value - object[a[i - <span class="number">1</span>] - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    weight = weight - object[a[i - <span class="number">1</span>] - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_value)&#123;</span><br><span class="line">        max_value = value;</span><br><span class="line">        max_weight = weight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++) max_a[j] = a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prem</span><span class="params">(<span class="keyword">int</span> a[] , <span class="keyword">int</span> start , <span class="keyword">int</span> end , <span class="keyword">int</span> m, <span class="keyword">int</span> object[M][<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end)<span class="built_in">sum</span>(a,end+<span class="number">1</span>,m,object);<span class="comment">//递归结束条件</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[start], a[i]);<span class="comment">//全排列时start的后位依次做第一位</span></span><br><span class="line">			<span class="built_in">Prem</span>(a, start + <span class="number">1</span>, end , m , object);</span><br><span class="line">			<span class="built_in">swap</span>(a[start], a[i]);<span class="comment">//换回来才能保证下一次交换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> a[M];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入商场中商品的数量:&quot;</span>; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入小车能装载的最大装载量:&quot;</span>;cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> object[M][<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入每种商品的重量和价格:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) cin&gt;&gt;object[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Prem</span>(a,<span class="number">0</span>, n<span class="number">-1</span> , m , object);<span class="comment">//寻找各种可能结果</span></span><br><span class="line">    <span class="built_in">print</span>(k);<span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="TSP旅行商问题"><a href="#TSP旅行商问题" class="headerlink" title="TSP旅行商问题"></a>TSP旅行商问题</h2><h3 id="蛮力法-2"><a href="#蛮力法-2" class="headerlink" title="蛮力法"></a>蛮力法</h3><h4 id="文字描述-3"><a href="#文字描述-3" class="headerlink" title="文字描述"></a>文字描述</h4><p>无</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MIN = <span class="number">1000</span>;<span class="comment">//用于计算最短路径</span></span><br><span class="line"><span class="keyword">int</span> min_a[M];<span class="comment">//用于保存最短路径编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最短路径为：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)cout &lt;&lt; min_a[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这条路长：&quot;</span> &lt;&lt; MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a[] , <span class="keyword">int</span> d[M][M] ,<span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = d[m<span class="number">-1</span>][a[<span class="number">0</span>]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == n - <span class="number">1</span>) sum += d[a[i]<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> sum += d[a[i]<span class="number">-1</span>][a[i + <span class="number">1</span>]<span class="number">-1</span>];</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (sum &lt; MIN)&#123;</span><br><span class="line">		MIN = sum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) min_a[i] = a[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prem</span><span class="params">(<span class="keyword">int</span> a[] , <span class="keyword">int</span> d[M][M] , <span class="keyword">int</span> start , <span class="keyword">int</span> end , <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end)<span class="built_in">sum</span>(a,d,end+<span class="number">1</span>,m);<span class="comment">//递归结束条件</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[start], a[i]);<span class="comment">//全排列时start的后位依次做第一位</span></span><br><span class="line">			<span class="built_in">Prem</span>(a, d ,start + <span class="number">1</span>, end ,m);</span><br><span class="line">			<span class="built_in">swap</span>(a[start], a[i]);<span class="comment">//换回来才能保证下一次交换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> a[M],d[M][M];</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入待旅行的城市数量:&quot;</span>; cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入旅行者出发的城市编号:&quot;</span>;cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n<span class="number">-1</span> ;i++)&#123;</span><br><span class="line">		a[i] = i + <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; m<span class="number">-1</span>)a[i] = i+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入城市之间的距离：&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">			cin &gt;&gt; d[i][j];</span><br><span class="line"></span><br><span class="line">	min_a[<span class="number">0</span>] = m;min_a[n] = m;</span><br><span class="line">	<span class="built_in">Prem</span>(a, d, <span class="number">0</span> ,n<span class="number">-2</span> ,m);</span><br><span class="line">	<span class="built_in">print</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p>用邻接矩阵g来表示各城市间的距离，问题可抽象为:从结点s出发，令d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。</p>
<ol>
<li><p>当V为空集，那么d(i,V)表示直接从i回到s，此时d(i,V) = g[i][s]。 </p>
</li>
<li><p>如果V不为空，那么就是对子问题的最优求解，必须在V这个城市集合中，尝试每一个，并求出最优解。</p>
</li>
</ol>
<p>在求解d(i, V)时，必须在V中找出这样一个结点k，它满足(从i到k的距离 + 从k出发经过 V-(k)这个集合回到s)是V的所有结点中最小的。</p>
<p>可得出状态转移方程：d(i,V) = min(g[i][k] + d(k,V–(k)))，其中k代表遍历当前V集合中所有的城市。</p>
<p>综上，可得出动态规划方程：</p>
<p><img src="file:///C:/Users/NILI99~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p>
<p>其中s为起点。</p>
<p>用代码实现时，由于V的状态有很多种，因此考虑采用状态压缩的办法表示V，即用数的二进制状态来表示V，第i个二进制位为0就代表V中没有i，为1则代表有。例如(5)D = (101)B, 代表V中的城市有0和2，而没有1，(7)D = (111)B, 代表V中的城市有0、1、2。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10e7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//保存顶点i到状态s最后回到起始点的最小距离</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="comment">//核心函数，求出动态规划dp数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TSP</span><span class="params">(<span class="keyword">int</span> **a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化dp[i][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = a[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求解dp[i][j],先跟新列在更新行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">            <span class="comment">//如果集和j(或状态j)中包含结点i,则不符合条件退出</span></span><br><span class="line">            <span class="keyword">if</span> (((j &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (((j &gt;&gt; (k - <span class="number">1</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; a[i][k] + dp[k][j ^ (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = a[i][k] + dp[k][j ^ (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="keyword">int</span>** a,bestc;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>* [n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a[j][i] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i][i] = <span class="number">0</span>;</span><br><span class="line">    m = <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">TSP</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TSP: &quot;</span> &lt;&lt; dp[<span class="number">0</span>][m - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h2><h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[M];</span><br><span class="line"><span class="keyword">int</span> i,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;a[i++];</span><br><span class="line">    <span class="keyword">while</span>(a[i])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; * &quot;</span>&lt;&lt;a[i];</span><br><span class="line">        a[i++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; a[<span class="number">0</span>])<span class="comment">//递归退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">show</span>(m);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(y &lt;= x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%y))&#123;</span><br><span class="line">            a[b] = y;</span><br><span class="line">            <span class="built_in">fun</span>(x/y,b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="built_in">fun</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><h4 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n) ; i++)</span><br><span class="line">    &#123;    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">            cout&lt;&lt;a[i][j];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;    &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gray</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">//退出递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">pow</span>(<span class="number">2</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][n<span class="number">-1</span>] = <span class="number">0</span>;<span class="comment">//第一排为0</span></span><br><span class="line">        a[m-i<span class="number">-1</span>][n<span class="number">-1</span>] = <span class="number">1</span>; <span class="comment">//第二排为1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Gray</span>(n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格雷码拼接操作</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=m/<span class="number">2</span>; i&lt;m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>; j++)</span><br><span class="line">            a[i][j] = a[m-i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">Gray</span>(n);</span><br><span class="line">    <span class="built_in">show</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h2><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="文字描述-4"><a href="#文字描述-4" class="headerlink" title="文字描述"></a>文字描述</h5><p>采用自顶向下的思想进行递推。从初始的m x n矩阵开始，对矩阵进行求和，并与不同方向的m x (n-1)和(m-1) x n 矩阵进行递推和比较，在寻找过程中设置book数组保存访问状态和子矩阵的和，最终返回最大值。</p>
<p>阶段：当前子矩阵的左上角坐标为start_x, start_y</p>
<p>状态：当前子矩阵的size为m x n</p>
<p>阶段目标：book[a[start_x][ start_y],m,n]表示当前的值,为左上角坐标为start_x,start_y的m x n矩阵的最大的子矩阵和。</p>
<p>状态转移方程:book[a[start_x][ start_y],m,n] = max{ book[a[start_x][ start_y],m,n],book[a[start_x][ start_y],m-1,n],book[a[start_x+1][ start_y],m-1,n], book[a[start_x][ start_y],m,n-1],book[a[start_x][ start_y+1],m,n-1]}</p>
<h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row,col;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">&#125;book[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> start_x,<span class="keyword">int</span> start_y,<span class="keyword">int</span> m , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m||!n||start_x+m&gt;row||start_y+n&gt;col) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n == <span class="number">1</span> ) <span class="keyword">return</span> a[start_x][start_y];</span><br><span class="line">    <span class="keyword">if</span>(book[a[start_x][start_y]+<span class="number">10</span>*m+<span class="number">100</span>*n].flag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> book[a[start_x][start_y]+<span class="number">10</span>*m+<span class="number">100</span>*n].sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp_sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start_x ; i &lt; start_x+m ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start_y ; j &lt; start_y+n ; j++)</span><br><span class="line">            temp_sum += a[i][j];</span><br><span class="line"></span><br><span class="line">    book[a[start_x][start_y]+<span class="number">10</span>*m+<span class="number">100</span>*n].sum = temp_sum;</span><br><span class="line">    book[a[start_x][start_y]+<span class="number">10</span>*m+<span class="number">100</span>*n].flag=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(&#123;temp_sum,</span><br><span class="line">                <span class="built_in">fun</span>(start_x+<span class="number">1</span>,start_y,m<span class="number">-1</span>,n),</span><br><span class="line">                <span class="built_in">fun</span>(start_x,start_y,m<span class="number">-1</span>,n),</span><br><span class="line">                <span class="built_in">fun</span>(start_x,start_y,m,n<span class="number">-1</span>),</span><br><span class="line">                <span class="built_in">fun</span>(start_x,start_y+<span class="number">1</span>,m,n<span class="number">-1</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input row,col: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; row &gt;&gt; col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; j++)</span><br><span class="line">           cin&gt;&gt;a[i][j];</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;max:&quot;</span> &lt;&lt; <span class="built_in">fun</span>(<span class="number">0</span>, <span class="number">0</span>, row, col) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>动态规划</p>
<h3 id="文字描述-5"><a href="#文字描述-5" class="headerlink" title="文字描述"></a>文字描述</h3><p>先根据元素个数填充三角形，行数为求解T=n*(n+1)/2的向上取整结果。若不能构成完整的数字三角形，空位补0。</p>
<p>行数为 n的三角形路径之和的最大值，可看做行数为n-1的三角形路径之和的最大值加上顶层。先求出第n-1阶段(第n-1行上各点)到第n行的最大和，再依次求出第n-2阶段、第n-3阶段……第1阶段(起始点)各决策点至第n行的最佳路径。按照自底向上的思想编写代码。</p>
<p>阶段：当前所在塔的层数i</p>
<p>状态：当前所在某层的位置j</p>
<p>阶段目标：f[i,j]表示当前的值,为从第i阶段中的点j至第n行的最大的数字和。</p>
<p>状态转移方程：f[i][j]=f[i][j]+max(f[i+1][j],f[i+1][j+1])</p>
<p>​<br> 图示分析：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n=5</th>
<th>9+max(50,49)=59</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>n=4</td>
<td>12+max(38,34)=50</td>
<td>15+max(34,29)=49</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>n=3</td>
<td>10+max(21,28)=38</td>
<td>6+max(28,19)=34</td>
<td>8+max(19,21)=29</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n=2</td>
<td>2+max(19,7)=21</td>
<td>18+max(7,10)=28</td>
<td>9+max(10,4)=19</td>
<td>5+max(4,16)=21</td>
<td></td>
</tr>
<tr>
<td>n=1</td>
<td>19</td>
<td>7</td>
<td>10</td>
<td>4</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//动规矩阵，存放每次结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;<span class="comment">//T表示元素个数</span></span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//n表示层数</span></span><br><span class="line">    n = <span class="built_in">ceil</span>((<span class="built_in">sqrt</span>(<span class="number">1</span>+<span class="number">8</span>*T)<span class="number">-1</span>)/<span class="number">2.0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n: &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; dp[i][j];</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;T) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自底向上动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i][j] += <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dp is &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;max :  &quot;</span>&lt;&lt;dp[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>动态规划</p>
<h3 id="文字描述-6"><a href="#文字描述-6" class="headerlink" title="文字描述"></a>文字描述</h3><p>算法思想：</p>
<p>阶段：当前子序列长度为i</p>
<p>阶段目标：L[i]表示当前序列的最长递增子序列长少-1（L[i]初始值为0）</p>
<p>状态转移方程:if(a[i]&gt;a[j])then L[i]=max{L[j]}+1(j:1ài)，否则L[i]值不变。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max_long=<span class="number">-9999</span>;</span><br><span class="line"><span class="keyword">int</span> dp_long[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_long</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j] &amp;&amp; dp_long[i] &lt; dp_long[j] + <span class="number">1</span>)</span><br><span class="line">                dp_long[i] = dp_long[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp_long[i] &gt; max_long) max_long = dp_long[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">find_long</span>(a,n);</span><br><span class="line">    cout &lt;&lt; max_long+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图结点着色"><a href="#图结点着色" class="headerlink" title="图结点着色"></a>图结点着色</h2><p>回溯</p>
<h3 id="文字描述-7"><a href="#文字描述-7" class="headerlink" title="文字描述"></a>文字描述</h3><p>该题实质为图结点的着色问题。可以具体抽象为：输入无向连通图的各节点和其连接的点，找一种需要最少颜色的着色法使图中每条边的2个顶点着不同颜色。</p>
<p>输入设计：关键在于从字符串到邻接矩阵的转换。先使用s.erase(s.find(‘:’),1)去除字符串的”:”,然后使用if(s[j]&amp;&amp;(s[j]-s[0]))c[i][s[j]-s[0]+i]=1 的判断语句转换成邻接矩阵。</p>
<p>回溯设计：在图着色问题的解空间树中，如果从根结点到当前结点对应一个部分解，也就是所有的颜色指派都没有冲突，则在当前结点处选择第一棵子树继续搜索，也就是为下一个顶点着颜色1，否则，对当前子树的兄弟子树继续搜索，也就是为当前顶点着下一个颜色，如果所有m种颜色都已尝试过并且都发生冲突，则回溯到当前结点的父结点处，上一个顶点的颜色改变，以此类推。具体描述：</p>
<p>1.将数组color[n]初始化为0并令k=1;</p>
<p>2.while(k&gt;=1)：a)依次考察每一种颜色，若顶点k的着色与其他顶点的着色不发生冲突，则转步骤b；否则，搜索下一个颜色；b)若顶点已全部着色，则输出数组color[n]，返回。c)若顶点k是一个合法着色，则k=k+1,处理下一个顶点；否则，重置顶点k的着色情况，k=k-1，转步骤c）。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//城市数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//当前着色数</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        <span class="keyword">if</span>(c[k][i]==<span class="number">1</span>&amp;&amp;color[i]==color[k]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraphColor</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)color[i]=<span class="number">0</span>;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        color[k]=color[k]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(color[k]&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ok</span>(k)==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> color[k]=color[k]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度到n,着色完全</span></span><br><span class="line">        <span class="keyword">if</span>(color[k]&lt;=n&amp;&amp;k==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(color,color+n);</span><br><span class="line">            cout&lt;&lt;color[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度不到n，节点下移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[k]&lt;=n&amp;&amp;k&lt;n)k=k+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//回溯，着色未完全,返回父节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            color[k]=<span class="number">0</span>;</span><br><span class="line">            k=k<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step==n)<span class="comment">//着色数=城市数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(color,color+n);</span><br><span class="line">        cout&lt;&lt;color[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           color[step]=i+<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">ok</span>(step))<span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">           color[step]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   string s;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;s;</span><br><span class="line">       s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>),<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(s[j]&amp;&amp;(s[j]-s[<span class="number">0</span>]))c[i][s[j]-s[<span class="number">0</span>]+i]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;c[i][j]&lt;&lt;&quot;    &quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//   GraphColor(n);</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="集合找和为C"><a href="#集合找和为C" class="headerlink" title="集合找和为C"></a>集合找和为C</h2><h3 id="文字描述-8"><a href="#文字描述-8" class="headerlink" title="文字描述"></a>文字描述</h3><ol>
<li>回溯设计：</li>
</ol>
<p>目标函数：sum+=out[k],sum=t&amp;k=n；约束条件：sum&lt;t，k&lt;n；限界函数：sum&lt;t,k&lt;n</p>
<p>具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件：</p>
<ol>
<li><p>sum&lt;t&amp;k&lt;n，继续dfs到下一层</p>
</li>
<li><p>sum=t&amp;k=n，输出</p>
</li>
<li><p>sum&gt;t||k&gt;n，进行剪枝并回溯到上一层。</p>
</li>
<li><p>去除重复输出设计:将每次回溯所得的结果存入二维数组out_comp中，其中i表示结果序号，即存回溯得到的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出</p>
</li>
</ol>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c,n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//input</span></span><br><span class="line"><span class="keyword">int</span> sum,k,out[<span class="number">10000</span>],book[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> out_comp[<span class="number">10000</span>][<span class="number">10000</span>];<span class="comment">//去重复</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//记录解个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去重复结果</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun_row</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">10000</span>;p++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fun_row</span>(out, out_comp[p]))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">fun</span>())<span class="comment">//输出不重复的结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (out[n])</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;out[n]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">            out_comp[num][m] = out[n];</span><br><span class="line">            m++;n++;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == c &amp;&amp; k== n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">output</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;c || k&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i] &amp;&amp; (s[i]&lt;=out[k<span class="number">-1</span>]||k==<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存入out</span></span><br><span class="line">            out[k]=s[i];</span><br><span class="line">            sum+=out[k];</span><br><span class="line">            book[i]=<span class="number">1</span>;</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向下dfs</span></span><br><span class="line">            <span class="built_in">backtrack</span>(step+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            k--;</span><br><span class="line">            sum-=out[k];</span><br><span class="line">            book[i]=<span class="number">0</span>;</span><br><span class="line">            out[k]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;c&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||n&gt;<span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;worry input n!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;temp)s.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!num) cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="构成最小倍数"><a href="#构成最小倍数" class="headerlink" title="构成最小倍数"></a>构成最小倍数</h2><p>分支界限</p>
<h3 id="文字描述-9"><a href="#文字描述-9" class="headerlink" title="文字描述"></a>文字描述</h3><p>本题主要采用了BFS(广度优先搜索)+剪枝回溯的思路编写程序。主要使用了数组来存m位不同的十进制数字，使用队列来进行BFS的搜索的数据结构类型。为找寻最小倍数，先将输入的数组x进行升序排序，因为x数组中的数据可以重复使用，所以每次拓展活结点时，其子节点为x[]中的所有元素。找到则退出，没有找到则继续在该层遍历，然后拓展下一层继续按层寻找。</p>
<p>具体算法设计为：1.先对输入的数据进行判断，若x[i]%n=0，即单位输入的数字即为自然数n的最小倍数，则直接输出，退出程序。2.若没有，则非零元素按大小依次进入队头。3.遍历组合队头元素的每个活结点，out=front*10+x[i]，若out[i]%n=0，代表找到，输出并退出程序，否则，队头元素出队并将out入队作为下一层拓展遍历的活结点。4.若out&gt; pow(2,32)-1,表示查找失败，输出0且退出程序。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,*x;<span class="comment">//input</span></span><br><span class="line">__int32 out;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">()</span><span class="comment">//bfs广度搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x[i]%n))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;x[i]&lt;&lt;endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        front=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            out=front*<span class="number">10</span>+x[i];</span><br><span class="line">            <span class="keyword">if</span>(!(out%n))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;out&lt;&lt;endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out&gt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">32</span>)<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">            q.<span class="built_in">push</span>(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    x=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)cin&gt;&gt;x[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(x,x+m);</span><br><span class="line">    <span class="built_in">backtrack</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="贪心法求解最优服务次序"><a href="#贪心法求解最优服务次序" class="headerlink" title="贪心法求解最优服务次序"></a>贪心法求解最优服务次序</h2><h3 id="文字描述-10"><a href="#文字描述-10" class="headerlink" title="文字描述"></a>文字描述</h3><p>算法思想：利用贪心的思想，优先服务需要时间少的顾客，直到最后。运用到了队列的数据结构。</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> wait_pos[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n; cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s; cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; t_temp;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;temp) t_temp.<span class="built_in">push_back</span>(temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(t_temp.<span class="built_in">begin</span>(), t_temp.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(!t_temp.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">push</span>(t_temp.<span class="built_in">back</span>());</span><br><span class="line">        t_temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排位置</span></span><br><span class="line">    <span class="keyword">while</span>(!t.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            wait_pos[i][j] = t.<span class="built_in">front</span>();</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找时间并输出</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;wait_pos[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;j &amp;&amp; wait_pos[i][k])</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;wait_pos[i][k]&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;k;z++)sum+=wait_pos[i][z];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(<span class="keyword">double</span>)sum/n&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="自然数分解积最大问题"><a href="#自然数分解积最大问题" class="headerlink" title="自然数分解积最大问题"></a>自然数分解积最大问题</h2><h3 id="文字描述-11"><a href="#文字描述-11" class="headerlink" title="文字描述"></a>文字描述</h3><p>算法思想：贪心的想使每个分解出来的数尽可能的接近，因此得到的乘积最小。采取的策略：设n的加数为2+3+…+m+k;m为最大加数，k为剩余的数(k&lt;=m)；然后将k分到其他数中，策略就是从m-&gt;2的数值一次加一，直至把k消耗完。</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[1000];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;../input&quot;, &quot;r&quot;, stdin);</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int sum = 0, m = 0, k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //找最大加数a[m-1]</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[m++] = i;</span><br><span class="line">        sum += i;</span><br><span class="line">        if (sum &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= i;</span><br><span class="line">            m--;</span><br><span class="line">            k = n - sum;//余数k</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //cout&lt;&lt;&quot;a[m-1]:&quot;&lt;&lt;a[m-1]&lt;&lt;&quot;\t&quot;&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //消耗余数</span><br><span class="line">    for (int i = m - 1; k; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]++;</span><br><span class="line">        i--;</span><br><span class="line">        if (i &lt; 0) i = m - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //输出和累乘</span><br><span class="line">    int out=1;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        out *= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;out;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心法最大删除数字问题"><a href="#贪心法最大删除数字问题" class="headerlink" title="贪心法最大删除数字问题"></a>贪心法最大删除数字问题</h2><h3 id="文字描述-12"><a href="#文字描述-12" class="headerlink" title="文字描述"></a>文字描述</h3><p>该算法同样涵盖了贪心算法的思想，根据分析，应当优先清除高位的小数，这样就可以带来局部最优解。所以从最高位开始寻找，从左到右依次遍历s[i]，若s[i]&lt;s[i+1]，则删除s[i]，并且缩短一位即可；若未找到，直接将len=len-1，即删除最后一位，输出即可。根据验证，此方法得到的解即为全局最优解。</p>
<p>最终，标记第一位非0的字符，从该位开始输出，得到的结果即为删除后的最大整数。</p>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define MAX 10002</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int k,len,flag,i,j;</span><br><span class="line">	char s[MAX]=&#123;0&#125;;</span><br><span class="line">	gets(s);</span><br><span class="line">	len=strlen(s);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">	while(k)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0;i&lt;len-1;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(s[i]&lt;s[i+1])</span><br><span class="line">			&#123;</span><br><span class="line">				for(j=i;j&lt;len-1;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					s[j]=s[j+1];</span><br><span class="line">				&#125;</span><br><span class="line">				len--;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(i==len-1)</span><br><span class="line">		&#123;</span><br><span class="line">			len--;</span><br><span class="line">		&#125;</span><br><span class="line">		k--;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s[i]!=&#x27;0&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			flag=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=flag;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%c&quot;,s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="迷宫问题的分支界限"><a href="#迷宫问题的分支界限" class="headerlink" title="迷宫问题的分支界限"></a>迷宫问题的分支界限</h2><h3 id="文字-1"><a href="#文字-1" class="headerlink" title="文字"></a>文字</h3><p>约束条件：箱子没有撞墙、机器人没有撞墙、位置不重复（若重复则代表一定有更少的解决步骤）。程序中将可以走的位置全部用0来代表，不能走的位置用1来代表，因此撞墙的约束条件可用如下式子来判断：</p>
<p>if (maze[next.bx][next.by] == 0    //箱子所在位置不是墙</p>
<p>​       &amp;&amp; maze[next.px][next.py] == 0)   //&amp;&amp;人所在位置不是墙</p>
<p>箱子和机器人的位置用一个四维数组来存储，四维分别是箱子和人的行、列下标，则位置不重复的约束条件：</p>
<p>if (used[next.bx][next.by][next.px][next.py] == 0) //节点不重复</p>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> maze[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> px, py;  <span class="comment">//箱子位置</span></span><br><span class="line">    <span class="keyword">int</span> bx, by;  <span class="comment">//人位置</span></span><br><span class="line">    <span class="keyword">bool</span> useful;    <span class="comment">//本节点是否有效</span></span><br><span class="line">&#125;;                  <span class="comment">//无效条件：箱子越界、撞墙、节点重复</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;   <span class="comment">//n行m列</span></span><br><span class="line">node start;</span><br><span class="line"><span class="keyword">int</span> tx, ty;  <span class="comment">//目标位置</span></span><br><span class="line">queue &lt;node&gt; q1;</span><br><span class="line"><span class="keyword">int</span> used[MAX][MAX][MAX][MAX];   <span class="comment">//判重数组</span></span><br><span class="line"><span class="keyword">int</span> step[MAX][MAX][MAX][MAX];   <span class="comment">//步数数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> walk[<span class="number">4</span>][<span class="number">2</span>] = <span class="comment">//走一步后的新坐标变化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">-1</span>,  <span class="comment">//左</span></span><br><span class="line">    +<span class="number">1</span>, <span class="number">0</span>,  <span class="comment">//下</span></span><br><span class="line">    <span class="number">0</span>, +<span class="number">1</span>,  <span class="comment">//右</span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">0</span>   <span class="comment">//上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">node <span class="title">moveto</span><span class="params">(node cur, <span class="keyword">int</span> i)</span></span>;   <span class="comment">//返回人向i方向走一格的新节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;maze[i][j];   <span class="comment">//将数字按字符读入，再转换成数字</span></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (maze[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                maze[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                maze[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">//箱子</span></span><br><span class="line">            &#123;</span><br><span class="line">                start.bx = i;</span><br><span class="line">                start.by = j;</span><br><span class="line">                maze[i][j] = <span class="number">0</span>;   <span class="comment">//将此处标记为0，意为“可以走”</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">//目标位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                tx = i;</span><br><span class="line">                ty = j;</span><br><span class="line">                maze[i][j] = <span class="number">0</span>;   <span class="comment">//同上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">//人</span></span><br><span class="line">            &#123;</span><br><span class="line">                start.px = i;</span><br><span class="line">                start.py = j;</span><br><span class="line">                maze[i][j] = <span class="number">0</span>;   <span class="comment">//同上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记初始节点并入队</span></span><br><span class="line">    used[start.bx][start.by][start.px][start.py] = <span class="number">1</span>;</span><br><span class="line">    step[start.bx][start.by][start.px][start.py] = <span class="number">0</span>;</span><br><span class="line">    q1.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node cur, next;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cur = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)  <span class="comment">//人向4个方向试探</span></span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="built_in">moveto</span>(cur, i);    <span class="comment">//返回扩展所得的新节点</span></span><br><span class="line">            <span class="keyword">if</span> (next.useful)     <span class="comment">//若该节点有效</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next.bx == tx &amp;&amp; next.by == ty)    <span class="comment">//判断箱子是否到达目标位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> step[next.bx][next.by][next.px][next.py];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//还未到达，新节点入队</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q1.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//无法到达，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点无效条件：箱子或人越界、箱子或人撞墙、节点重复</span></span><br><span class="line"><span class="function">node <span class="title">moveto</span><span class="params">(node cur, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node next;</span><br><span class="line">    <span class="keyword">bool</span> moved = <span class="literal">false</span>;  <span class="comment">//判断箱子是否移动</span></span><br><span class="line">    next.bx = cur.bx;     <span class="comment">//箱子位置暂时不动</span></span><br><span class="line">    next.by = cur.by;</span><br><span class="line">    next.px = cur.px + walk[i][<span class="number">0</span>];  <span class="comment">//人向i方向移动一格</span></span><br><span class="line">    next.py = cur.py + walk[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next.px == next.bx &amp;&amp; next.py == next.by)  <span class="comment">//若此时人与箱子位置重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        next.bx += walk[i][<span class="number">0</span>];        <span class="comment">//那么箱子也要向i方向移动一格</span></span><br><span class="line">        next.by += walk[i][<span class="number">1</span>];</span><br><span class="line">        moved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断新节点next是否有效</span></span><br><span class="line">    next.useful = <span class="literal">false</span>;  <span class="comment">//初始为无效</span></span><br><span class="line">    <span class="keyword">if</span> (maze[next.bx][next.by] == <span class="number">0</span>        <span class="comment">//箱子所在位置不是墙</span></span><br><span class="line">        &amp;&amp; maze[next.px][next.py] == <span class="number">0</span>)     <span class="comment">//&amp;&amp;人所在位置不是墙</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[next.bx][next.by][next.px][next.py] == <span class="number">0</span>) <span class="comment">//节点不重复</span></span><br><span class="line">        &#123;</span><br><span class="line">            next.useful = <span class="literal">true</span>;   <span class="comment">//同时满足上述条件，该节点才有效</span></span><br><span class="line">            <span class="comment">//标记“到达过”</span></span><br><span class="line">            used[next.bx][next.by][next.px][next.py] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//根据箱子是否移动来修改步数</span></span><br><span class="line">            <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">                step[next.bx][next.by][next.px][next.py] = <span class="number">1</span> + step[cur.bx][cur.by][cur.px][cur.py];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                step[next.bx][next.by][next.px][next.py] = step[cur.bx][cur.by][cur.px][cur.py];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;    <span class="comment">//返回新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迷宫最长回路的分支界限"><a href="#迷宫最长回路的分支界限" class="headerlink" title="迷宫最长回路的分支界限"></a>迷宫最长回路的分支界限</h2><h3 id="文字描述-13"><a href="#文字描述-13" class="headerlink" title="文字描述"></a>文字描述</h3><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LongestRoute</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> state;</span><br><span class="line">        <span class="keyword">int</span> visit[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">block</span>(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> state = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">            <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">            <span class="keyword">this</span>-&gt;visit[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;visit[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;block&gt;&gt; map;</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,&#125;;<span class="comment">//上， 右， 下， 左</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest_route = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root_x;</span><br><span class="line">    <span class="keyword">int</span> root_y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LongestRoute;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    string cur_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;block&gt; cur_block_array;</span><br><span class="line"></span><br><span class="line">        cin&gt;&gt;cur_str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (cur_str[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    cur_block_array.<span class="built_in">emplace_back</span>(<span class="built_in">block</span>(i, j , <span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    cur_block_array.<span class="built_in">emplace_back</span>(<span class="built_in">block</span>(i , j , <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;input error at (%d, %d), input is : %c \n&quot;</span>, i, j, cur_str[j]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="built_in">emplace_back</span>(cur_block_array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_longest_route</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> position, <span class="keyword">int</span> cur_route_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//由于每个在分支限界中每个节点只有一次成为最优解的机会，故当一个节点被搜索过后，它不再有再次被置入搜索栈的资格</span></span><br><span class="line">    <span class="keyword">if</span>(x == root_x &amp;&amp; y == root_y &amp;&amp; cur_route_length != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_route_length - <span class="number">1</span>&gt; longest_route)</span><br><span class="line">        &#123;</span><br><span class="line">            longest_route = cur_route_length - <span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;update longest_route : &quot;</span>&lt;&lt;longest_route&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_x = x + direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_y = y + direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur_x &lt; <span class="number">0</span> || cur_x &gt;= n || cur_y &lt; <span class="number">0</span> || cur_y &gt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[x][y].state != map[cur_x][cur_y].state)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[x][y].state^map[cur_x][cur_y].state)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">1</span>)</span><br><span class="line">                    cur_position = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; map[x][y].state == <span class="number">0</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; map[x][y].state == <span class="number">1</span> &amp;&amp; position == <span class="number">0</span>)</span><br><span class="line">                    cur_position = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur_position != <span class="number">-1</span> &amp;&amp; map[cur_x][cur_y].visit[cur_position] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;cur_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;cur_y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;cur_position&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;endl;</span><br><span class="line">            map[cur_x][cur_y].visit[cur_position] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">search_longest_route</span>(cur_x, cur_y, cur_position, cur_route_length + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>, <span class="string">&quot;r+&quot;</span>, stdin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">create_map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!map[i][j].visit[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    root_x = i;root_y = j;</span><br><span class="line">                    <span class="built_in">search_longest_route</span>(i, j, k, <span class="number">1</span>);</span><br><span class="line">                    map[i][j].visit[k] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Longest Route Length : &quot;</span>&lt;&lt;longest_route&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯法求和因子"><a href="#回溯法求和因子" class="headerlink" title="回溯法求和因子"></a>回溯法求和因子</h2><h3 id="文字-2"><a href="#文字-2" class="headerlink" title="文字"></a>文字</h3><ol>
<li><p>输入设计：while(cin&gt;&gt;t)直到n=0跳出输入，结束程序</p>
</li>
<li><p>回溯设计：</p>
</li>
</ol>
<p>目标函数：sum+=out[k],sum=t;</p>
<p>约束条件：sum&lt;t,out[k]的k&lt;=n,即加数不超过n</p>
<p>限界函数：sum&lt;t</p>
<p>具体算法描述：未避免重复计算，先将输入的list数组进行降序排序，并将其后的数据作为下一层递归深度搜索的子节点。设置全局变量sum作为回溯的约束条件：</p>
<ol>
<li><p>sum&gt;t，继续dfs到下一层</p>
</li>
<li><p>sum=t，输出</p>
</li>
<li><p>sum&gt;t，进行剪枝并回溯到上一层。</p>
<p>去除重复后输出结果:将每次回溯所得的结果存入二维数组out_comp[i][j]中，其中i表示结果序号，即存回溯的out[n]到二维数组的第i行。每次结果与out_comp[i][j]的每行比较，有重复则不输出</p>
</li>
</ol>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,list[<span class="number">12</span>];<span class="comment">//input</span></span><br><span class="line"><span class="keyword">int</span> out[<span class="number">12</span>],out_comp[<span class="number">100</span>][<span class="number">12</span>];<span class="comment">//output</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//保存结果数</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重复结果</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun_row</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">100</span>;p++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fun_row</span>(out, out_comp[p]))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>,m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">fun</span>())<span class="comment">//输出不重复的结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;out[<span class="number">0</span>];</span><br><span class="line">        out_comp[num][<span class="number">0</span>] = out[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (out[n])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span>&lt;&lt;out[n];</span><br><span class="line">            out_comp[num][m] = out[n];</span><br><span class="line">            m++;n++;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == t) <span class="built_in">output</span>();</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;t)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i] &amp;&amp; (list[i]&lt;=out[k<span class="number">-1</span>]||k==<span class="number">0</span>))<span class="comment">//没有访问过且要求降序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存入out</span></span><br><span class="line">            out[k]=list[i];</span><br><span class="line">            sum+=out[k];</span><br><span class="line">            book[i]=<span class="number">1</span>;</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//dfs向下搜索</span></span><br><span class="line">            <span class="built_in">backtrack</span>(step+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            k--;</span><br><span class="line">            sum-=out[k];</span><br><span class="line">            book[i]=<span class="number">0</span>;</span><br><span class="line">            out[k]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输入设置</span></span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">1000</span> || t &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;worry input t&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">12</span> || n&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;worry input n&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i,flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            cin&gt;&gt;j;</span><br><span class="line">            list[i] = j;</span><br><span class="line">            <span class="keyword">if</span>(list[i]&gt;<span class="number">100</span> || list[i]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;worry input list[i]&quot;</span>&lt;&lt;endl;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;result :&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        sum=num=k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="number">12</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(out,<span class="number">0</span>,<span class="number">12</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            <span class="built_in">memset</span>(out_comp[i],<span class="number">0</span>,<span class="number">12</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="built_in">sort</span>(list,list+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;NONE&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="贪心算法解任务调度器"><a href="#贪心算法解任务调度器" class="headerlink" title="贪心算法解任务调度器"></a>贪心算法解任务调度器</h2><h3 id="文字-3"><a href="#文字-3" class="headerlink" title="文字"></a>文字</h3><p>任务调度分配的最短时间由任务数最多的任务所决定，设最多的任务数有max个，有max个任务数的任务共num个，任务总数为sum。则在任务之间的max-1个间隔贪心的插入n<em>( max-1)个任务(可能含待命)。最后计算最终调度时间：当需要插入的个数大于可插入利用的最大个数时，除任务A本身和间隔，需在末尾补上余下的num-1个任务，因此最短时间为max+ n</em>(max-1)+num-1。否则最短调度时间为任务总数sum。</p>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"></span><br><span class="line">    string s; cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> n; cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> task[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(task,<span class="number">0</span>,<span class="number">26</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//任务统计</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) task[s[i]-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="comment">//统计max和max个数num</span></span><br><span class="line">    <span class="keyword">int</span> mymax = <span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;   <span class="keyword">if</span>(mymax &lt; task[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mymax =task[i];</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mymax == task[i] )num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>((<span class="keyword">int</span>)s.<span class="built_in">size</span>(), (mymax + (mymax - <span class="number">1</span>) * n + num - <span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> matrix[M][M], <span class="keyword">int</span> i, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; matrix[i][mid]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(target &lt; matrix[i][mid])    right = mid;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不成熟的二分尝试1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span> matrix[M][M], <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">binarySearch</span>(matrix, i, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后采用的二分法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchMatrix_</span><span class="params">(<span class="keyword">int</span> matrix[M][M], <span class="keyword">int</span> target, <span class="keyword">int</span> bottle_r , <span class="keyword">int</span> bottle_c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix[bottle_r][bottle_c] == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(bottle_r==m || bottle_c==n || bottle_c==<span class="number">-1</span>|| bottle_r==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(matrix[bottle_r][bottle_c] &gt; target) <span class="built_in">searchMatrix_</span>(matrix, target, bottle_r<span class="number">-1</span> , bottle_c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">searchMatrix_</span>(matrix, target, bottle_r , bottle_c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input m,n:&quot;</span>; cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> matrix[M][M];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input matrix&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)cin&gt;&gt;matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input target:&quot;</span>; cin&gt;&gt;target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">searchMatrix</span>(matrix, target))cout&lt;&lt;<span class="string">&quot;ture&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">searchMatrix_</span>(matrix, target,m<span class="number">-1</span>,<span class="number">0</span>))cout&lt;&lt;<span class="string">&quot;ture&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间-快排"><a href="#时间-快排" class="headerlink" title="时间+快排"></a>时间+快排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		i=begin;j=end;r[<span class="number">0</span>]=r[i];</span><br><span class="line">        <span class="keyword">while</span>(i!=j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(r[j]&gt;r[<span class="number">0</span>]&amp;&amp;i&lt;j) j--;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">			&#123;</span><br><span class="line">				r[i]=r[j];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(r[i]&lt;r[<span class="number">0</span>]&amp;&amp;i&lt;j) i++;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">			&#123;</span><br><span class="line">				r[j]=r[i];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r[i]=r[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">quickSort</span>(r, begin, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(r, i + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> t1,t2;</span><br><span class="line">	<span class="keyword">double</span> t;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">int</span> r[N],i,n;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">40</span>];</span><br><span class="line">	FILE* fp;</span><br><span class="line">	fp=<span class="built_in">fopen</span>(<span class="string">&quot;D:/algorithm/test_2_1.csv&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1000</span>;n&lt;=<span class="number">100000</span>;n+=<span class="number">1000</span>)<span class="comment">//建立横坐标n</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">itoa</span>(n,ch,<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(ch,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		<span class="built_in">fwrite</span>(ch,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>),<span class="built_in">strlen</span>(ch),fp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>),<span class="number">1</span>,fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1000</span>;n&lt;=<span class="number">100000</span>;n+=<span class="number">1000</span>)<span class="comment">//输入纵坐标t</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//生成随机数</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) r[i]=<span class="built_in">rand</span>()%<span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">		t1=<span class="built_in">clock</span>();<span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(r, <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		t2=<span class="built_in">clock</span>();<span class="comment">//结束计时</span></span><br><span class="line">		t = (<span class="keyword">double</span>)(t2-t1)/CLOCKS_PER_SEC*<span class="number">1000</span>;</span><br><span class="line">		<span class="built_in">itoa</span>(t,ch,<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(ch,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		<span class="built_in">fwrite</span>(ch,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>),<span class="built_in">strlen</span>(ch),fp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>),<span class="number">1</span>,fp);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h2><p>分治</p>
<h3 id="文字-4"><a href="#文字-4" class="headerlink" title="文字"></a>文字</h3><p>分治法求解棋盘覆盖问题的技巧在于划分棋盘，使划分后的子棋盘的大小相同，并且每个子棋盘均包含一个特殊方格，从而将原问题分解为规模较小的棋盘覆盖问题。</p>
<p><em>k</em>&gt;0时，可将2<em>k</em>×2<em>k</em>的棋盘划分为4个2<em>k</em>-1×2<em>k</em>-1的子棋盘，这样划分后，由于原棋盘只有一个特殊方格，所以，这4个子棋盘中只有一个子棋盘包含该特殊方格，其余3个子棋盘中没有特殊方格。为了将这3个没有特殊方格的子棋盘转化为特殊棋盘，以便采用递归方法求解，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。</p>
<p>​             每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角（top left coner）方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量s来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。其次还要有一个变量nCount来记录L型骨牌的数量。</p>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//全局变量，表示L型骨牌编号</span></span><br><span class="line"><span class="keyword">int</span> board[M][M];<span class="comment">//全局变量，表示棋盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tr,tc表示棋盘左上角</span></span><br><span class="line"><span class="comment">//dr,dc表示表示特殊方格</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr , <span class="keyword">int</span> tc , <span class="keyword">int</span> dr , <span class="keyword">int</span> dc , <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//棋盘只有一个方格其是特殊方格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = ++t;<span class="comment">//L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s = size/<span class="number">2</span>;<span class="comment">//划分棋盘</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr+s &amp;&amp; dc&lt;tc+s)<span class="comment">//特殊方格在左上角子棋盘中</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr,tc,dr,dc,s);<span class="comment">//递归处理子棋盘</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用t号L型骨牌覆盖右下角，再递归处理子棋盘</span></span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s<span class="number">-1</span>]=number;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr,tc,tr+s<span class="number">-1</span>,tc+s<span class="number">-1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr+s &amp;&amp; dc &gt;= tc+s)<span class="comment">//特殊方格在右上角子棋盘中</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr,tc+s,dr,dc,s);<span class="comment">//递归处理子棋盘</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用t号L型骨牌覆盖左下角，再递归处理子棋盘</span></span><br><span class="line">        board[tr+s<span class="number">-1</span>][tc+s]=number;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr,tc+s,tr+s<span class="number">-1</span>,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr+s &amp;&amp; dc&lt;tc+s)<span class="comment">//特殊方格在左下角子棋盘中</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr+s,tc,dr,dc,s);<span class="comment">//递归处理子棋盘</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用t号L型骨牌覆盖右上角，再递归处理子棋盘</span></span><br><span class="line">        board[tr+s][tc+s<span class="number">-1</span>]=number;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr+s ,tc,tr+s,tc+s<span class="number">-1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr+s &amp;&amp; dc&gt;=tc+s)<span class="comment">//特殊方格在左上角子棋盘中</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr+s,tc+s,dr,dc,s);<span class="comment">//递归处理子棋盘</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//用t号L型骨牌覆盖右下角，再递归处理子棋盘</span></span><br><span class="line">        board[tr+s][tc+s]=number;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr+s,tc+s,tr+s,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size , x , y;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input size and (x,y)&quot;</span>;</span><br><span class="line">    cin&gt;&gt;size&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    board[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ChessBoard</span>(<span class="number">0</span>,<span class="number">0</span>,x,y,size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出棋盘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWJTU</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGORITHM-算法效率</title>
    <url>/2021/12/06/ALGORITHM02/</url>
    <content><![CDATA[<h1 id="算法-第二章-算法效率分析"><a href="#算法-第二章-算法效率分析" class="headerlink" title="算法_第二章__算法效率分析"></a>算法_第二章__算法效率分析</h1><h2 id="1-算法分析概述"><a href="#1-算法分析概述" class="headerlink" title="1.算法分析概述"></a>1.算法分析概述</h2><p>对算法所需要的两种计算机资源：时间资源和空间资源进行估算。</p>
<span id="more"></span>
<p>目的是为了设计和选择更好的算法</p>
<h3 id="（1）时间效率"><a href="#（1）时间效率" class="headerlink" title="（1）时间效率"></a>（1）时间效率</h3><p><strong>时间效率：</strong>设输入的元素个数为n,执行该算法的第i步操作记为op（i）,该步骤执行的次数为Cop(i)，则该算法的总执行时间为：</p>
<script type="math/tex; mode=display">
T(n)=\sum_i C_{opi} * C_i(n)</script><h3 id="（2）时间复杂性"><a href="#（2）时间复杂性" class="headerlink" title="（2）时间复杂性"></a>（2）时间复杂性</h3><p><strong>时间复杂性：</strong>指执行算法所消耗或占用时间资源的量<strong>【程序步数】</strong></p>
<p>​                        在最坏、最好、平均三种情况下的时间复杂度</p>
<h3 id="（3）例题"><a href="#（3）例题" class="headerlink" title="（3）例题"></a>（3）例题</h3><p><strong>1.非递归程序</strong>顺序检索：在具有n个元素的数组a[1……n]中找出值等于x的元素的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(Type *a, <span class="keyword">int</span> n, Type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	  <span class="keyword">if</span> (a[i]==x) <span class="keyword">return</span> i;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏：T(n) = n</p>
<p>最好：T(n) = 1</p>
<p>平均：Tavg（n）=sum[p(I)T(I)]</p>
<p>变式：设计一个尽可能高效的算法，在长度为n的一维数组a[n]中查找值最大的元素max和最小的元素min，并分析算法的最好、最坏和平均时间复杂度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxMin</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;max,<span class="keyword">int</span> &amp;min)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> I;</span><br><span class="line">  max=min=a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">if</span>(a[i]&gt;max) max=a[i];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;min) min=a[i];<span class="comment">//【要特别注意这的else！！！】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最好：是一个递增的，n-1</p>
<p>最坏：递减，2*（n-1）</p>
<p>平均：假设a中有一半元素比max大，a[i]&gt;max执行n-1次，else语句执行（n-1）/2次———&gt;平均3*（n-1）/2次</p>
<p><strong>2.递归程序的时间复杂性分析</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RSum</span><span class="params">(<span class="keyword">float</span> <span class="built_in">list</span>[],<span class="keyword">const</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> RSum(<span class="built_in">list</span>,n<span class="number">-1</span>)+<span class="built_in">list</span>[n<span class="number">-1</span>];	<span class="comment">//?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>T(n) = T(n-1)+2[T(0)=2]</p>
<blockquote>
<p><em>程序步骤不能确切反映程序运行的实际时间</em></p>
</blockquote>
<h2 id="2-渐进"><a href="#2-渐进" class="headerlink" title="2.渐进"></a>2.渐进</h2><p>定义：只关心f(n)的阶</p>
<p><strong>大O表示法：</strong>若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≤c×f(n)，则称f(n)是T(n)的上界，记为：T(n)=O(f(n))                        </p>
<p><strong>大Ω表示法：</strong>若存在两个正的常数c和n0，对于任意n≥n0，都有T(n)≥c×g(n)，则称g(n)是T(n)的下界，记为：T(n)= Ω(g(n)</p>
<p><strong>Θ表示法：</strong>若存在三个正的常数c1、c2和n0，对于任意n≥n0都有c1×f(n)≥T(n)≥c2×f(n)，则称f(n)与T(n)同阶，记为：T(n)=Θ(f(n))      </p>
<p>求解方法：</p>
<script type="math/tex; mode=display">
\lim_n {t(n)\over g(n)}=0\mbox{\quad \quad t(n)的增长次数比g(n)小}\\
\lim_n {t(n)\over g(n)}=c>0\mbox{\quad \quad t(n)的增长次数和g(n)相同}\\
\lim_n {t(n)\over g(n)}=\infty\mbox{\quad \quad t(n)的增长次数比g(n)大}</script><p>为0时，大O；为无穷时，大Ω；c为Θ</p>
<h2 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3.时间复杂度"></a>3.时间复杂度</h2><p>定义：针对指定基本运算，计数算法所做运算次数</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">1</span> ; j&lt;=i; j++)</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=j; k++)</span><br><span class="line">               x++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行次数为：</p>
<script type="math/tex; mode=display">
\sum^n_{i=1}\sum^i_{j=1}\sum^j_{k=1}1=\sum^n_{i=1}\sum^i_{j=1}j=\sum^n_{i=1}{i(i+1)\over2}=[n(n+1)(2n+1)/6+n(n+1)/2]/2 \\
={n^3+3n^2+2n\over6}</script><p>时间复杂度T(n) = O(n^3)</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20211206221539.png" alt="img"></p>
<h2 id="4-递归的高阶方程的数学分析"><a href="#4-递归的高阶方程的数学分析" class="headerlink" title="4.递归的高阶方程的数学分析"></a>4.递归的高阶方程的数学分析</h2><p>先化简再计算</p>
<p><strong>例：</strong></p>
<p>1.汉诺塔问题的递归算法的复杂度分析</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n , A ,B,C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)MoveOne(n,A,B);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Hanoi(n<span class="number">-1</span> , A ,C , B);</span><br><span class="line">		MoveOne(n,A,C);</span><br><span class="line">		Hanoi(n<span class="number">-1</span> , B , A , C);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M(n) = 2M(n-1)+1</p>
<p>M(n) = Θ(2^n)</p>
<p>2.斐波那契</p>
<p>代码：</p>
<p>1.递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> (n);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Fibonacci1(n<span class="number">-1</span>)+Fibonacci1(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A(n) = A(n-1)+A(n-2)+1</p>
<p>2.迭代法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> F[n+<span class="number">1</span>];</span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)</span><br><span class="line">		F[i] = F[i<span class="number">-1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度低但空间资源浪费高</p>
<p>A(n) = n - 1 = Θ(n)</p>
<p>3.最优解法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci3</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F , Fa , Fb;</span><br><span class="line">    Fa = <span class="number">0</span> ; Fb = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        F = Fa + Fb;</span><br><span class="line">        Fb = Fa;</span><br><span class="line">        Fa = F;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWJTU</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>ALGORITHM</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGPR-1</title>
    <url>/2022/02/08/ALGPR-1/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>第一周的算法课都讲了什么T.T</p>
<span id="more"></span>
<h1 id="CM1"><a href="#CM1" class="headerlink" title="CM1"></a>CM1</h1><h1 id="TD1"><a href="#TD1" class="headerlink" title="TD1"></a>TD1</h1><p>从字符的匹配开始讲的，说了蛮多伪代码的东西，真难看(bushi</p>
<h2 id="字符的匹配"><a href="#字符的匹配" class="headerlink" title="字符的匹配"></a>字符的匹配</h2><p>貌似没啥，就是熟悉一下子法语书写的伪代码</p>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables://定义变量</span><br><span class="line">	Caractère:courant//串，定义为字符类型</span><br><span class="line">	Entier:nbL//拿来计数的int</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	nbL &lt;- 0</span><br><span class="line">	courant &lt;- lire()//这里的读是一个个读</span><br><span class="line">	tantque(courant != &#x27;.&#x27;)</span><br><span class="line">		si(courant == &#x27;L&#x27;) </span><br><span class="line">			nbL &lt;- nbL+1</span><br><span class="line">		finsi</span><br><span class="line">		courant &lt;- lire()</span><br><span class="line">	fintanque</span><br><span class="line">	afficher(nbL)//输出</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="LE"><a href="#LE" class="headerlink" title="LE"></a>LE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables:</span><br><span class="line">	Caractère:courant,précédent</span><br><span class="line">	Entier:nbLE</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	nbLE &lt;- 0</span><br><span class="line">	précédent &lt;- &#x27;.&#x27;</span><br><span class="line">	courant &lt;- lire()</span><br><span class="line">	tantque(courant != &#x27;.&#x27;)</span><br><span class="line">		si(courant == &#x27;L&#x27; ET courant = &#x27;E&#x27;) </span><br><span class="line">			nbLE &lt;- nbLE+1</span><br><span class="line">		finsi</span><br><span class="line">		précédent &lt;- courant</span><br><span class="line">		courant &lt;- lire()</span><br><span class="line">	fintanque</span><br><span class="line">	afficher(nbLE)</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="ELLE"><a href="#ELLE" class="headerlink" title="ELLE"></a>ELLE</h3><p>就是把子串固定，然后拿courant去做匹配</p>
<p>以ELELLELLLLEL找ELLE为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables:</span><br><span class="line">	Chaine de caractère:courant,motif//motif是子串</span><br><span class="line">	Caractère: c</span><br><span class="line">	Entier: nbMotif	</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	nbMotif &lt;- 0</span><br><span class="line">	afficher(&quot;quel est le motif cherché?&quot;)</span><br><span class="line">	motif &lt;- lire()</span><br><span class="line">	//初始化串为...courant[0]</span><br><span class="line">	pour i de 0 à taille(motif)-2</span><br><span class="line">		courant[i] &lt;- &#x27;.&#x27;</span><br><span class="line">	finpour</span><br><span class="line">	c &lt;- lire()</span><br><span class="line">	courant[taille(motif)-1] &lt;- c</span><br><span class="line">	</span><br><span class="line">	//串变成了...E</span><br><span class="line">	</span><br><span class="line">	tantque(c != &#x27;.&#x27;)</span><br><span class="line">		si (courant = motif)</span><br><span class="line">			nbMotif &lt;- nbMotif+1</span><br><span class="line">		finsi</span><br><span class="line">		//从后往前移</span><br><span class="line">		pour i de 0 à taille(motif)-2</span><br><span class="line">			courant[i] &lt;- courant[i+1]</span><br><span class="line">		finpour</span><br><span class="line">		c &lt;- lire()</span><br><span class="line">		courant[taille(motif)-1] &lt;- c</span><br><span class="line">	fintanque</span><br><span class="line">	</span><br><span class="line">	afficher(nbMotif)</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>妙的！时间复杂度的话N*n，可能比用想的的find函数要好哎</p>
<p>实际写的好艰难,string里面真的好多东西哦:(</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nbMotif=<span class="number">0</span>;</span><br><span class="line">   string courant,motif;</span><br><span class="line">   cin&gt;&gt;courant;</span><br><span class="line">   cin&gt;&gt;motif;</span><br><span class="line">   <span class="keyword">size_t</span> p=<span class="number">0</span>;<span class="comment">//注意返回类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((p = courant.<span class="built_in">find</span>(motif,p)) != courant.npos)</span><br><span class="line">    &#123;</span><br><span class="line">        nbMotif++;</span><br><span class="line">        p += motif.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;nbMotif&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="老师的奇妙方法"><a href="#老师的奇妙方法" class="headerlink" title="老师的奇妙方法"></a>老师的奇妙方法</h3><p>用矩阵还是图的知识来实现匹配(example:LE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables:</span><br><span class="line">	Caractère:c</span><br><span class="line">	Entier: s,ss,x,nbLE</span><br><span class="line">	Tableau d&#x27;Entiers m &lt;- &#123;&#123;0,1,0,2&#125;,&#123;0,1,0,2&#125;&#125;</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	nbLE &lt;- 0</span><br><span class="line">	s &lt;- 0</span><br><span class="line">	tantque(s != 2)</span><br><span class="line">		courant &lt;- lire()</span><br><span class="line">		x &lt;- 0</span><br><span class="line">		si(c == &#x27;L&#x27;) alors x &lt;- 1	finsi</span><br><span class="line">		si(c == &#x27;E&#x27;) alors x &lt;- 2	finsi</span><br><span class="line">		si(c == &#x27;.&#x27;) alors x &lt;- 3	finsi</span><br><span class="line">		</span><br><span class="line">		ss &lt;- m(s,x)</span><br><span class="line">		si (s = 1 ET x = 2) alors nbLE &lt;- nbLE+1 finsi</span><br><span class="line">		s&lt;- ss</span><br><span class="line">	fintanque</span><br><span class="line">	afficher(nbLE)</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>时间复杂度的话应该有两部分，一是在写m矩阵那里，然后是主程序。主程序的时间复杂度的话，有个逐个读的n，然后剩下的话我感觉有m^2。—-&gt; ?</p>
<p>矩阵长这样</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220209020654.png" alt="img" style="zoom:50%;" /></p>
<p>好像是在用s和x来表示前后两次的匹配的结果</p>
<p>但感觉就是时间也多了，空间也给浪费了嘛(；′⌒`)</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>“肘，再逝一次”</p>
<h2 id="TD题"><a href="#TD题" class="headerlink" title="TD题"></a>TD题</h2><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p>1.1 Points et polygone (enregistrement)<br>On souhaite calculer quelques propri´et´es d’un polygone quelconque (p´erim etre, longueur<br>moyenne des arˆetes, boite englobante). La boite englobante est un rectangle englobant le<br>polygone de cˆot´es paralleles aux axes. Les sommets du polygone sont donn´es (dans l’ordre<br>de parcours du p´erimetre) par leurs coordonn´ees r´eelles dans un plan et le nom du point<br>(caractere).<br>La liste de coordonn´ees est suppos´ee correcte et n’est lue qu’une seule fois. Exemple de<br>fichier a lire :<br>— 1,5 3,7 A<br>— 6,4 4,6 B<br>— 5,8 8,3 C<br>— …<br>— 1,5 3,7 A (dernier sommet a ne pas ajouter dans la structure de donn´ees)<br>Les coordonn´ees du dernier sommet sont ´egales a celles du premier. Ce sommet permet<br>uniquement de d´etecter la fermeture du polygone. Il ne faut pas rentrer ce sommet dans la<br>structure de donn´ees.<br>— Proposez une structure de donn´ee pour stocker le polygone,<br>— Ecrivez l’algorithme principal pour lire le fichier contenant les points du polygone, ´<br>appeler les fonctions permettant de calculer les propri´et´es demand´ees et afficher les<br>r´esultats a l’´ecran,<br>— Ecrivez les fonctions secondaires pour calculer la longueur du p´erim`etre, calculer la ´<br>longueur moyenne des arˆetes et d´elimiter la boite englobante.</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types//应该是在定义结构体</span><br><span class="line">	point: enregistrement</span><br><span class="line">		caratère: nom</span><br><span class="line">		réel: x</span><br><span class="line">		réel: y</span><br><span class="line">	fin_enregistrement</span><br><span class="line">	</span><br><span class="line">	tabPoint: tableau de point</span><br><span class="line"></span><br><span class="line">Algorithme principal Polygone</span><br><span class="line">Variables://定义变量</span><br><span class="line">	tabPoint polygone,boiteEnglobante</span><br><span class="line">	réel périmètre, longMoy</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	polygone &lt;- lirePolygone(&quot;data.txt&quot;)//读文件</span><br><span class="line">	périmètre &lt;- calcuPérimètre(polygone)//周长</span><br><span class="line">	longMoy &lt;- périmètre/taille(polygone)//棱边数</span><br><span class="line">	boiteEnglobante &lt;- calculBoite(polygone)</span><br><span class="line">Fin Algorithme</span><br></pre></td></tr></table></figure>
<h3 id="我想的C"><a href="#我想的C" class="headerlink" title="我想的C++"></a>我想的C++</h3><p>不知道能不能成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Nom;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distance</span><span class="params">(Point A, Point B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    vecter&lt;Point&gt; PonitsDePolygone;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//构造函数</span></span><br><span class="line">    	<span class="built_in">Polygone</span>(Point A)&#123;PonitsDePolygone.<span class="built_in">push</span>(A);&#125;</span><br><span class="line">    	<span class="comment">//拷贝构造 ou 析构？？？？</span></span><br><span class="line">    	<span class="keyword">float</span> périmè<span class="built_in">tre</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">longMoy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>KMP,CM和未完成的C++就是明天一定</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>ALGORITHM</tag>
        <tag>KMP</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGPR-2</title>
    <url>/2022/02/09/ALGPR-2/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>第二周的算法课都讲了什么T.T</p>
<span id="more"></span>
<h1 id="TD2"><a href="#TD2" class="headerlink" title="TD2"></a>TD2</h1><p>尝试在课上直接记blog的第一天</p>
<h2 id="Recursivite"><a href="#Recursivite" class="headerlink" title="Récursivité"></a>Récursivité</h2><h3 id="calcule-la-puissance-d’un-nombre"><a href="#calcule-la-puissance-d’un-nombre" class="headerlink" title="calcule la puissance d’un nombre"></a>calcule la puissance d’un nombre</h3><p>principe_1: calcul récursif pour n != 0,et puissance(x,0)=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entier puissance(entier x,entier n):</span><br><span class="line">Début</span><br><span class="line">	si (n = 0) alors retourner 1//结束递归的跳出条件</span><br><span class="line">	sinon retourner x * pusissance(x,n-1)//递归</span><br><span class="line">	finsi</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>principe_2: par la méthod “diviser pour régner”,et puissance(x,0)=1,et puissance(x,1)=x div étant la division entiere</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Début</span><br><span class="line">	//结束递归的跳出条件</span><br><span class="line">	si (n = 0) </span><br><span class="line">		alors retourner 1</span><br><span class="line">	finsi</span><br><span class="line">	si (n = 1) </span><br><span class="line">		alors retourner x</span><br><span class="line">	finsi</span><br><span class="line">	</span><br><span class="line">	//本质还是在所递归，有减少一些递归的次数</span><br><span class="line">	entier y = puiss2(x, (n div 2))</span><br><span class="line">	si (n mod 2 = 0 ) </span><br><span class="line">		alors retourner y*y</span><br><span class="line">	sinon</span><br><span class="line">		alors retourner x*y*y</span><br><span class="line">	finsi</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>——&gt;<strong>堆栈！</strong></p>
<h3 id="L’ordre-inverse"><a href="#L’ordre-inverse" class="headerlink" title="L’ordre inversé"></a>L’ordre inversé</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">affiche_1(vecteur&lt;entier&gt; w)</span><br><span class="line">Début</span><br><span class="line">	pour i de 0 à taille(w) -1 faire</span><br><span class="line">		écrire(w[i]+&#x27;&#x27;)</span><br><span class="line">	fin_pour</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">affiche_2(vecteur&lt;entier&gt; w,int debut)</span><br><span class="line">Début</span><br><span class="line">	si(debut &lt; taille(w)) alors</span><br><span class="line">		écrire(w[debut]+&#x27;&#x27;)</span><br><span class="line">		affiche_2(w,debut+1)</span><br><span class="line">    fin_si</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">entier debut = taille(w) -1</span><br><span class="line">affiche_inv(vecteur&lt;entier&gt; w,int debut)</span><br><span class="line">Début</span><br><span class="line">	si(debut = -1) exit(0) fin_si</span><br><span class="line">	écrire(w[debut]+&#x27;&#x27;)</span><br><span class="line">	affiche_inv(w,debut-1)</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以初始化为0，先递归再输出[妙！]</span><br><span class="line">affiche_inv(vecteur&lt;entier&gt; w,int debut)</span><br><span class="line">Début</span><br><span class="line">	si(debut &lt; taille(w)) alors</span><br><span class="line">		affiche_inv(w,debut-1)</span><br><span class="line">		écrire(w[debut]+&#x27;&#x27;)</span><br><span class="line">	fin_si</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="String的palidrome"><a href="#String的palidrome" class="headerlink" title="String的palidrome"></a>String的palidrome</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Algorithm palindrome</span><br><span class="line">	booléen &lt;- palindrome(string s,int decal)</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	si(decal &lt; (taille(s)-1)/2)</span><br><span class="line">		si(s[decal] != s[taille(s)-1-decal]) </span><br><span class="line">			retourner FAUX </span><br><span class="line">		sinon</span><br><span class="line">			palindrome(s,decal+1)</span><br><span class="line">		sinon </span><br><span class="line">			retourner VRAI</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>—&gt;用<strong>stack</strong>来实现</p>
<h2 id="Reine-et-pions-八皇后！"><a href="#Reine-et-pions-八皇后！" class="headerlink" title="Reine et pions(八皇后！)"></a>Reine et pions(八皇后！)</h2><p>题有点怪</p>
<p>先写题</p>
<p>On considère un échiquier de huit cases sur huit comportant huit pions et une reine. Les positions des pions et de la reine sont données dans un fichier sous un format que vous devez définir(selon la structure de données que vous choisissez). La reine peut se déplacer sur les lignes(diagonales; verticale et horizontale) sur lesquelles elle se trouve. On souhaite savoir combien de pions sont en prise(i.e. pouvant êrte pris par la reine). Si deux pions ou plus sont sur la même ligne(diagonale, verticale , horizontale), seul le premier est en prise.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DFS</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">9</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">if</span>(step &gt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) cout&lt;&lt;res[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试每一种可能 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         继续下一步 <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ;   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CM2"><a href="#CM2" class="headerlink" title="CM2"></a>CM2</h1><h2 id="Gestion-de-la-memoire-内存管理"><a href="#Gestion-de-la-memoire-内存管理" class="headerlink" title="Gestion de la mémoire//内存管理"></a>Gestion de la mémoire//内存管理</h2><p>Possible de stocker un lien vers une case mémoire</p>
<p>Utile pour :</p>
<p>​            Structures de données (<strong>listes chainées, arbres</strong>)</p>
<p>​            Passage de paramètres：传递参数<br>​            Allocation de mémoire：配置、地址分配</p>
<p>像是在讲指针的样子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">utilisation &#x27;lien&#x27; :</span><br><span class="line">ExempleLienEntier</span><br><span class="line">variables</span><br><span class="line">	lien entier lienEnt//声明一个lien</span><br><span class="line">	entier ent</span><br><span class="line">Début</span><br><span class="line">	lienEnt ← lien(ent)</span><br><span class="line">	contenu(lienEnt) ← 5</span><br><span class="line">	reçoit la valeur 5//接受</span><br><span class="line">	afficher(ent)</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>关于lien和contenu</p>
<ul>
<li>lien:创造或声明链接</li>
<li>contenu：访问链接的内容</li>
</ul>
<h2 id="Structures-de-donnees-composees"><a href="#Structures-de-donnees-composees" class="headerlink" title="Structures de données composées"></a>Structures de données composées</h2><ul>
<li>Stockage de plusieurs données dans une seule structure pour：Structurer les données，Faciliter les traitements</li>
<li>Données de même type : listes et arbres//树和表<br>Données de type quelconque : enregistrements(记录登记)</li>
</ul>
<h3 id="Enregistrements"><a href="#Enregistrements" class="headerlink" title="Enregistrements"></a>Enregistrements</h3><p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220210110243.png" alt="img" style="zoom:50%;" /></p>
<p>应该是结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">types</span><br><span class="line">	article : Enregistrement</span><br><span class="line">		entier : référence</span><br><span class="line">		réel : prix</span><br><span class="line">		chaine de caractère : libellé</span><br><span class="line">		entier : quantité</span><br><span class="line">	Fin enregistrement</span><br><span class="line">vectArticles : tableau d’article</span><br><span class="line"></span><br><span class="line">variables</span><br><span class="line">article artCour // article courant</span><br><span class="line">entier valeurStock</span><br><span class="line"></span><br><span class="line">artCour.prix &lt;-- lire ()</span><br><span class="line">artCour.libellé &lt;-- lire ()</span><br><span class="line">artCour.quantité &lt;-- lire ()</span><br><span class="line">valeurStock &lt;-- artCour.prix * artCour.quantité</span><br><span class="line">écrire (&quot;La valeur du stock de &quot;, artCour.libellé, &quot; est de : &quot;,valeurStock, &quot; euros&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Structures-lineaires"><a href="#Structures-lineaires" class="headerlink" title="Structures linéaires"></a>Structures linéaires</h3><h4 id="Listes"><a href="#Listes" class="headerlink" title="Listes"></a>Listes</h4><h5 id="Definition"><a href="#Definition" class="headerlink" title="Définition"></a>Définition</h5><p>Ensemble d’éléments de même type liés par une relation de séquentialité</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220210110621.png" alt="img" style="zoom:50%;" /></p>
<p>注意一下名字： prédécesseur， successeur</p>
<p>一些关于表的基本操作:插入、删除、测试表是否为空、测表长</p>
<h5 id="Tableaux表"><a href="#Tableaux表" class="headerlink" title="Tableaux表"></a>Tableaux表</h5><p>Accès direct à un élément à l’aide de son indice(下标)</p>
<p>目标算法: Somme(求和), Tris(排序), Présence d’élément(?)</p>
<p>Exemple de définition de types composés </p>
<ul>
<li>tabEnt : Tableau d’entiers </li>
<li>matReels : Tableau de dimension 2 de réels </li>
<li>tab4DEnt : tableau d’entiers de dimension 4</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//检查是否正序</span><br><span class="line">variables</span><br><span class="line">	tabEnt tab</span><br><span class="line">	entier n</span><br><span class="line">	booléen trie</span><br><span class="line"></span><br><span class="line">&#123;n, tab&#125; &lt;- lire ()</span><br><span class="line">trie &lt;- VRAI</span><br><span class="line">pour i &lt;- 0 à n-2 faire</span><br><span class="line">	si ( tab[i] &gt; tab[i+1] ) alors</span><br><span class="line">    	trie FAUX</span><br><span class="line">    fin si</span><br><span class="line">fin pour</span><br><span class="line">si ( non trie ) alors</span><br><span class="line">	écrire (&quot;le tableau n’est pas trié&quot;)</span><br><span class="line">fin si</span><br><span class="line"></span><br><span class="line">//一般函数</span><br><span class="line">variables</span><br><span class="line">	vectArticles tabArt//?结构体的vector？</span><br><span class="line">	réel valStock</span><br><span class="line">	entier n</span><br><span class="line">Début</span><br><span class="line">&#123;n, tabArt&#125; &lt;-- lire (&quot;data.txt&quot;)</span><br><span class="line">valStock &lt;-- 0</span><br><span class="line">pour i 0 à n-1 faire</span><br><span class="line">	valStock valStock + tabArt[i].prix * tabArt[i].quantité</span><br><span class="line">fin pour</span><br><span class="line">écrire (&quot;La valeur du stock des &quot;, n, &quot; articles est de : &quot;,valStock, &quot; euros&quot;)</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>所以说就是表的元素可以是结构体的意思？</p>
<h5 id="Liste-chainee链表"><a href="#Liste-chainee链表" class="headerlink" title="Liste chainée链表"></a>Liste chainée链表</h5><h6 id="单向-successeur"><a href="#单向-successeur" class="headerlink" title="单向 successeur"></a>单向 successeur</h6><p>链表的定义(值与指向下一元素的指针)：</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220210112853.png" alt="img" style="zoom:50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type</span><br><span class="line">	elementEntier : Enregistrement</span><br><span class="line">		entier valeur,</span><br><span class="line">		lien elementEntier suivant, // lien vers l’élément suivant</span><br><span class="line">	Fin enregistrement</span><br><span class="line"></span><br><span class="line">variables</span><br><span class="line">	elementEntier elementUn, elementDeux, ..., elementSix</span><br><span class="line">...</span><br><span class="line">	elementUn.valeur 12</span><br><span class="line">	elementUn.suivant lien(elementDeux)</span><br><span class="line">	elementDeux.valeur 99</span><br><span class="line">	elementDeux.suivant lien(elementTrois)</span><br><span class="line">	...</span><br><span class="line">	elementCinq.suivant lien(elementSix)</span><br><span class="line">	elementSix.valeur 16</span><br><span class="line">	elementSix.suivant VIDE</span><br></pre></td></tr></table></figure>
<h6 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h6><p>要同时定义前置和后置指针</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220210113415.png" alt="img" style="zoom:50%;" /></p>
<p>Calcul de la longueur d’une liste（递归）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fonction : longueur calculLongueur(lienDébutListe)</span><br><span class="line">paramètres : lien elementEntier lienDébutListe</span><br><span class="line">résultats : entier longueur</span><br><span class="line">Début</span><br><span class="line"> si ( lienDébutListe est VIDE ) alors</span><br><span class="line">  	longueur 0</span><br><span class="line"> sinon</span><br><span class="line">  	longueur 1 + calculLongueur(lienD´ebutListe-&gt;suivant)</span><br><span class="line"> fin si</span><br><span class="line"> retourner longueur</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>Recherche d’un élément dans une liste（递归）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fonction : présence chercherElement(lienDébutListe, val)</span><br><span class="line">	paramètres : lien élémentEntier lienDébutListe,</span><br><span class="line">				entier val</span><br><span class="line">	résultats : booléen présence</span><br><span class="line">Début</span><br><span class="line">	si ( lienDébutListe est VIDE ) alors//链表为空退出</span><br><span class="line">		présence FAUX</span><br><span class="line">	sinon</span><br><span class="line">  		si ( lienDébutListe-&gt;valeur = val ) alors</span><br><span class="line"> 			présence VRAI</span><br><span class="line">		sinon</span><br><span class="line"> 			présence chercherElement(lienDébutListe-&gt;suivant, val)</span><br><span class="line">		fin_si</span><br><span class="line">	fin_si</span><br><span class="line"> retourner présence</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>就是链表本质就是结构体+数组吗？</p>
<h5 id="Liste-chainee和tableau时间复杂度的比较"><a href="#Liste-chainee和tableau时间复杂度的比较" class="headerlink" title="Liste chainée和tableau时间复杂度的比较"></a>Liste chainée和tableau时间复杂度的比较</h5><p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220210114750.png" alt="img" style="zoom:50%;" /></p>
<p>查找，添加/删除头(位)</p>
<h4 id="Piles"><a href="#Piles" class="headerlink" title="Piles"></a>Piles</h4><p>存储结构讲表与链表，然后栈、队列是特殊的线性表（？）</p>
<p>LIFO:栈，先入后出</p>
<p>基本操作： ajoute(push),delete(pop),Test de pile vide</p>
<h4 id="File-d’attente"><a href="#File-d’attente" class="headerlink" title="File d’attente"></a>File d’attente</h4><p>FIFO：队列，先入先出</p>
<h3 id="Structures-arborescentes"><a href="#Structures-arborescentes" class="headerlink" title="Structures arborescentes"></a>Structures arborescentes</h3><p>​    Extension du concept de liste avec plusieurs successeurs pour un élément(一个节点后面可以接多个节点)</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总有地上的菜鸡，敢于直面大佬的开源</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>Récursivité</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGPR-3</title>
    <url>/2022/02/21/ALGPR-3/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>ALGPR的第三周</p>
<span id="more"></span>
<h1 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h1><h2 id="TD2-Division-euclidienne"><a href="#TD2-Division-euclidienne" class="headerlink" title="TD2_Division euclidienne"></a>TD2_Division euclidienne</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">couplEntier qr &lt;- divEuclid(entier n, entier d)</span><br><span class="line">Types</span><br><span class="line">	couplEntiers: enregistrement</span><br><span class="line">		entier: quotient</span><br><span class="line">		entier: reste</span><br><span class="line">	fin_enregistrement</span><br><span class="line">	</span><br><span class="line">Variables</span><br><span class="line">	couplEntiers qr,inter</span><br><span class="line">	</span><br><span class="line">Début</span><br><span class="line">	Si(n &lt; d) alors </span><br><span class="line">		qr.reste &lt;- n;</span><br><span class="line">	Sinon</span><br><span class="line">		qr.quotient++;</span><br><span class="line">		divEuclid(n - d , d);</span><br><span class="line">	fin_Si</span><br><span class="line">	retourner qr</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	Si(n &lt; d) alors </span><br><span class="line">		qr.quotient &lt;- 0;</span><br><span class="line">		qr.reste &lt;- n;</span><br><span class="line">	Sinon</span><br><span class="line">		inter &lt;- divEuclid(n - d , d);</span><br><span class="line">		qr.quotient &lt;- inter.quotient + 1;</span><br><span class="line">		qr.reste = inter.reste ;</span><br><span class="line">	fin_Si</span><br><span class="line">	retourner qr</span><br><span class="line">Fin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="TD3-Definition"><a href="#TD3-Definition" class="headerlink" title="TD3_Définition"></a>TD3_Définition</h2><p>Notion de lien vers une structure de données: ce lien est un type de données à part entière défini par le mot-clé <strong>lien</strong>, suivi du type lié.</p>
<p>Cette notion de lien sera traduite(翻译) en C++ par la notion de <strong>pointeur</strong>（指针）</p>
<ul>
<li>Lien Type_x 1: pour créer ou déclarer un lien sur une variable</li>
<li>contenu(1): pour accéder au contenu du lien 1</li>
</ul>
<p>指针和引用</p>
<p>指针本质也是变量，存储地址。引用本质是取地址。</p>
<p>注：</p>
<ol>
<li><p>引用必须初始化，引用不能为空，引用只是别名不是实体</p>
<p>就是说不能这样子 int &amp;n</p>
<p>要这样 int &amp;n = m(m之前定义)</p>
<p>然后in &amp;n = 3这样子也会报错（？）</p>
</li>
<li><p>引用没有const</p>
</li>
<li><p>引用的自增和指针的自增问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p,entier;</span><br><span class="line"><span class="keyword">int</span> &amp;q = entier;</span><br><span class="line">entier=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;q;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;&amp;q&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">*p++;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;&amp;q&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">q++;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;&amp;q&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">p++;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;&amp;q&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;q&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><img src="undefined" alt="img" style="zoom:50%;" /></p>
<p>指针自增就是还挺多，*运算符的优先级低于右++，然后还有什么移位不安全啥的，看到再说</p>
</li>
</ol>
<p>Exemple</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables</span><br><span class="line">	Lien Entier lienEnt</span><br><span class="line">	Entier n</span><br><span class="line">Début</span><br><span class="line">	lienEnt &lt;- lien(n)</span><br><span class="line">	conteun(lienEnt) &lt;- 5</span><br><span class="line">	afficher(n)</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int *lienEnt,n</span><br><span class="line">lienEnt = &amp;n;</span><br><span class="line">*lienEnt = 5;</span><br><span class="line">cout&lt;&lt;n;</span><br></pre></td></tr></table></figure>
<p>[?]</p>
<ul>
<li>ne transmettre que la valeur de la variable: utiliser le passage par valeur</li>
<li>modifier la valeur originale de la variable: utiliser le passage en partage</li>
</ul>
<h2 id="TD3-Swap"><a href="#TD3-Swap" class="headerlink" title="TD3_Swap"></a>TD3_Swap</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variables</span><br><span class="line">	Entier c</span><br><span class="line">Début</span><br><span class="line"> 	c &lt;- a</span><br><span class="line"> 	a &lt;- b</span><br><span class="line"> 	b &lt;- c</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h2 id="TD3-Swap-lien-struct"><a href="#TD3-Swap-lien-struct" class="headerlink" title="TD3_Swap+lien+struct"></a>TD3_Swap+lien+struct</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fonction creerArticle</span><br><span class="line">problème : création d&#x27;un novel article</span><br><span class="line">apecification:</span><br><span class="line">	fonction: Lien Article &lt;- creerArticle(r,n,p)</span><br><span class="line">	paramètres: Entier r, VectCar n , Réel p</span><br><span class="line">	résultats: Lien Article 1A</span><br><span class="line">	</span><br><span class="line">Variables</span><br><span class="line">	Lien Article 1A</span><br><span class="line">Début</span><br><span class="line">	1A &lt;- nouveau()</span><br><span class="line">	contenu(1A).reference &lt;- r</span><br><span class="line">	contenu(1A).nom &lt;- n</span><br><span class="line">	contenu(1A).prix &lt;- p</span><br><span class="line">	renvoyer 1A</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总有地上的菜鸡，敢于直面大佬的开源</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>指针与引用</tag>
      </tags>
  </entry>
  <entry>
    <title>ALGPR-4</title>
    <url>/2022/02/28/ALGPR-4/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>关于算法的第四周</p>
<span id="more"></span>
<h1 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h1><h2 id="Listes-chainees"><a href="#Listes-chainees" class="headerlink" title="Listes chainées"></a>Listes chainées</h2><p>En utilisant une structure de liste chainée dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour: </p>
<ul>
<li>afficher les éléments de liste(打印)</li>
<li>ajouter un éléments à la fin de la liste(增)</li>
<li>rechercher une valeur avec renvoi du nombre de valeurs présentes dans la liste(查)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type</span><br><span class="line">	elementSimplementChiane: Enregistrement</span><br><span class="line">		type valeur,</span><br><span class="line">		lien elementSimplementChiane suivant</span><br><span class="line">		suivant</span><br><span class="line">	Fin_Enregistrement</span><br><span class="line"></span><br><span class="line">type</span><br><span class="line">	elementEntier: Enregistrement</span><br><span class="line">		type valeur</span><br><span class="line">		lien elementSimplementChiane suivant</span><br><span class="line">	Fin_Enregistrement</span><br></pre></td></tr></table></figure>
<h3 id="Afficher"><a href="#Afficher" class="headerlink" title="Afficher"></a>Afficher</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type</span><br><span class="line">	ElementEntier: enregistrement</span><br><span class="line">		Entier valeur</span><br><span class="line">		Lien ElementEntier suivant</span><br><span class="line">	Fin_Enregistrement</span><br><span class="line"></span><br><span class="line">afficherElement(Lien ElementEntier début)</span><br><span class="line">paramètre: Lien sur ElementEntier</span><br><span class="line">resultat: vide</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	si(début non vide) alors</span><br><span class="line">		écrire(début -&gt; valeur)//也可以写成contenu(début).valeur</span><br><span class="line">		afficherElement(début -&gt; suivant)//contenu(début).suivant</span><br><span class="line">	finsi</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="Ajouter"><a href="#Ajouter" class="headerlink" title="Ajouter"></a>Ajouter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type</span><br><span class="line">	ElementEntier: enregistrement</span><br><span class="line">		Entier valeur</span><br><span class="line">		Lien ElementEntier suivant</span><br><span class="line">	Fin_Enregistrement</span><br><span class="line"></span><br><span class="line">ajoutFin(Lien ElementEntier début, Entier val)</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	si(début n&#x27;est pas vide) alors</span><br><span class="line">		contenu(début).suivant &lt;- ajoutFin(contenu(début).suivant,val)</span><br><span class="line">	sinon</span><br><span class="line">		contenu(début).valeur &lt;- val;</span><br><span class="line">		contenu(début).suivant &lt;- NULL;</span><br><span class="line">	finsi</span><br><span class="line">	renvoyer début</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="Rechercher"><a href="#Rechercher" class="headerlink" title="Rechercher"></a>Rechercher</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type</span><br><span class="line">	ElementEntier: enregistrement</span><br><span class="line">		Entier valeur</span><br><span class="line">		Lien ElementEntier suivant</span><br><span class="line">	Fin_Enregistrement</span><br><span class="line"></span><br><span class="line">rechercheNbVal(Lien ElementEntier début, Entier val)</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	si(début n&#x27;est pas vide) alors</span><br><span class="line">		si(contenu(début).valeur = val)</span><br><span class="line">			nb &lt;- nb+1</span><br><span class="line">		finsi</span><br><span class="line">		nb &lt;- nb+rechercheNbVal(contenu(début).suivant,val)</span><br><span class="line">	sinon</span><br><span class="line">		nb&lt;-0</span><br><span class="line">	finsi</span><br><span class="line">	renvoyer début</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h2 id="Liste-doublement-chainees"><a href="#Liste-doublement-chainees" class="headerlink" title="Liste doublement chainées"></a>Liste doublement chainées</h2><p>En utilisant une structure de liste doublement chainées dont les valeurs sont des Entiers, proposer les algorithmes des fonctions secondaires pour:</p>
<ul>
<li>ajouter un éléments à la bonne place dans une liste triée,</li>
<li>supprimer un élément dont la valeur est donnée en paramètre.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types</span><br><span class="line">	ElementEntierDbl: enregistrement</span><br><span class="line">		Entier valeur</span><br><span class="line">		Lien ElementEntierDbl suivant</span><br><span class="line">		Lien ElementEntierDbl précrédent</span><br><span class="line">	Fin_Enregistrement</span><br></pre></td></tr></table></figure>
<h3 id="Ajouter-1"><a href="#Ajouter-1" class="headerlink" title="Ajouter"></a>Ajouter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types</span><br><span class="line">	ElementEntierDbl: enregistrement</span><br><span class="line">		Entier valeur</span><br><span class="line">		Lien ElementEntierDbl suivant</span><br><span class="line">		Lien ElementEntierDbl précrédent</span><br><span class="line">	Fin_Enregistrement</span><br><span class="line">	</span><br><span class="line">ajoutTrié(Lien ElementEntier début, Entier val)</span><br><span class="line">Variable: Lien ElementEntierDbl tmp</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	si(début n&#x27;est pas vide) alors</span><br><span class="line">		si(val &lt; contenu(début).valeur)</span><br><span class="line">			tmp &lt;- noveau()</span><br><span class="line">			contenu(tmp).valeur &lt;- val</span><br><span class="line">			contenu(tmp).suivant &lt;- début</span><br><span class="line">			//insère</span><br><span class="line">			contenu(précrédent) &lt;- contenu(début).précrédent</span><br><span class="line">			contenu(début).précrédent &lt;- tmp</span><br><span class="line">			début &lt;- tmp</span><br><span class="line">		sinon</span><br><span class="line">			contenu(début).précrédent &lt;- ajoutTrié(contenu(début).suivant,val)</span><br><span class="line">		finsi</span><br><span class="line">	sinon</span><br><span class="line">	 	début &lt;- noveau()</span><br><span class="line">		contenu(début).valeur &lt;- val</span><br><span class="line">		</span><br><span class="line">	finsi</span><br><span class="line">	renvoyer début</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h2 id="Arbres-binaires"><a href="#Arbres-binaires" class="headerlink" title="Arbres binaires"></a>Arbres binaires</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type NoeudArbreBinaire: Enregistrement</span><br><span class="line">	type valeur,</span><br><span class="line">	lien NoeudArbreBinaire fg,</span><br><span class="line">	NoeudArbreBinaire fd,</span><br><span class="line">Fin_enregistrement</span><br></pre></td></tr></table></figure>
<h3 id="Fonction-parcoursPrefixe"><a href="#Fonction-parcoursPrefixe" class="headerlink" title="Fonction parcoursPréfixe"></a>Fonction parcoursPréfixe</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Début</span><br><span class="line">	afficher(racine -&gt; valeur)</span><br><span class="line">	si racine -&gt; fg non vide alors</span><br><span class="line">		parcoursPréfixe(racine-&gt;fg)</span><br><span class="line">	fin_si</span><br><span class="line">	si racine -&gt; fd non vide alors</span><br><span class="line">		parcoursPréfixe(racine-&gt;fd)</span><br><span class="line">	fin_si</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="Recherche"><a href="#Recherche" class="headerlink" title="Recherche"></a>Recherche</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Booleen &lt;- existe(lien NoeudEntier noeud, Entier val)</span><br><span class="line">Début</span><br><span class="line">	si(noeud is not vide) alors</span><br><span class="line">		renvoyer FAUX</span><br><span class="line">	sinon</span><br><span class="line">		si(noeud.valeur = val) alors</span><br><span class="line">			renvoyer VRAI</span><br><span class="line">		sinon </span><br><span class="line">			renvoyer existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val)//注意这里一定是ou</span><br><span class="line">		fin_si</span><br><span class="line">	fin_si</span><br><span class="line">Fin</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line">Début</span><br><span class="line">	si(noeud is not vide) alors</span><br><span class="line">		renvoyer FAUX</span><br><span class="line">	sinon</span><br><span class="line">			renvoyer (noeud.valeur = val) OU existe(noeud-&gt;fg,val) OU existe(noeud-&gt;fd,val)</span><br><span class="line">	fin_si</span><br><span class="line">Fin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Supprime"><a href="#Supprime" class="headerlink" title="Supprime[]"></a>Supprime[]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lien NoeudEntier &lt;- supprimeFeuille(lien NoeudEntier, Entier val)</span><br><span class="line">efface()、nouveau()</span><br><span class="line"></span><br><span class="line">Début</span><br><span class="line">	si(noeud is not vide) alors</span><br><span class="line">		si(noeud.fg = vide ET noeud.fd = vide ET noeud.valeur = val)</span><br><span class="line">			efface(noeud)</span><br><span class="line">		sinon</span><br><span class="line">			noeud.fg &lt;- supprimeFeuille(noeud.fg , val)</span><br><span class="line">			noeud.fd &lt;- supprimeFeuille(noeud.fd , val)</span><br><span class="line">		fin_si</span><br><span class="line">	fin_si</span><br><span class="line">	renvoyer noeud</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h3 id="Ajouter-2"><a href="#Ajouter-2" class="headerlink" title="Ajouter"></a>Ajouter</h3><h4 id="Haute"><a href="#Haute" class="headerlink" title="Haute"></a>Haute</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entier &lt;- hauteur(lien NoeudEntier noeud)</span><br><span class="line">Début</span><br><span class="line">	variable: entier g,d=0//放这里吗？？？？是的</span><br><span class="line">	si(noeud.fg is not vide) alors</span><br><span class="line">		g &lt;- hauteur(noeud.fd)</span><br><span class="line">	finsi</span><br><span class="line">	si(noeud.fd is not vide) alors</span><br><span class="line">		d &lt;- hauteur(noeud.fd)</span><br><span class="line">	finsi</span><br><span class="line">	h &lt;- 1+ max(g,d)</span><br><span class="line">    renvoyer h</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<p>ajouter dans la branche la plus courte d’un arbre une valeur passée en paramètre(在树的最短分支上添加一个参数中传递的值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//[用树高来判断存在问题]---&gt;树的最小深度问题</span><br><span class="line">lien NoeudEntier &lt;- ajoutHtMin(lien NoeudEntier noeud, Entier val)</span><br><span class="line">Début</span><br><span class="line">	si(noeud is not vide) alors</span><br><span class="line">		si(hauteur(noeud-&gt;fg) &lt; hauteur(noeud-&gt;fd))</span><br><span class="line">			noeud.fg &lt;- ajoutHtMin(noeud-&gt;fg, val)</span><br><span class="line">		sinon</span><br><span class="line">			noeud.fd &lt;- ajoutHtMin(noeud-&gt;fd, val)	</span><br><span class="line">	sinon</span><br><span class="line">		nouveau.valeur &lt;- val</span><br><span class="line">		nouveau.fg &lt;- NULL</span><br><span class="line">		nouveau.fd &lt;- NULL</span><br><span class="line">    	noeud &lt;- nouveau()</span><br><span class="line">    finsi</span><br><span class="line">    renvoyer noeud</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h2 id="Arbres-binaires-de-recherche-ABR-enracinement"><a href="#Arbres-binaires-de-recherche-ABR-enracinement" class="headerlink" title="Arbres binaires de recherche(ABR): enracinement"></a>Arbres binaires de recherche(ABR): enracinement</h2><p>Définition : Un ABR est un arbre dont les valeurs des noeuds appartiennent à un ensemble totalement ordonné et les conditions équivalentes suivantes sont vérifiées:</p>
<p>​    La liste des valeurs en ordre infixe est croissante</p>
<p>​    Pour tout noeud x de valeur v, les valeurs des noeuds de la branche gauche de x sont inférieures ou égales à v et les valeurs des noeuds de la branche droite de x sont surpérieures ou égales à v (左节点要小于根节点，右节点要大于根结点)</p>
<p>二叉查找树的查找会更快</p>
<h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h3><p>constituer</p>
<p>用parcoursInfixe()创建//中序</p>
<p>inferieur, superieur(), abr()//都是布尔型函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specification:</span><br><span class="line">	fonction: super &lt;- superieur(racine , x)</span><br><span class="line">	parametres: lien NoeudArbreBinaire racine, Entier x</span><br><span class="line">	resultat: booleen</span><br><span class="line"></span><br><span class="line">Debut</span><br><span class="line">variables locales</span><br><span class="line">	booleen b &lt;- (x &gt;= racine-&gt;valeur)</span><br><span class="line">	choix selon</span><br><span class="line">		(racine-&gt;fg != NULL et racine-&gt;fd != NULL):</span><br><span class="line">			renvoyer superieur(racine-&gt;fg , x) et</span><br><span class="line">					superieur(racine-&gt;fd , x) et b</span><br><span class="line">		(racine-&gt;fg != NULL et racine-&gt;fd = NULL):</span><br><span class="line">			renvoyer superieur(racine-&gt;fg , x) et b</span><br><span class="line">		(racine-&gt;fg = NULL et racine-&gt;fd != NULL):</span><br><span class="line">			renvoyer superieur(racine-&gt;fd , x) et b</span><br><span class="line">		(racine-&gt;fg = NULL et racine-&gt;fd = NULL):</span><br><span class="line">			renvoyer b</span><br><span class="line">	fin_choix_selon</span><br><span class="line">Fin</span><br></pre></td></tr></table></figure>
<h1 id="CM"><a href="#CM" class="headerlink" title="CM"></a>CM</h1><p>真后悔，没去</p>
<p>待补</p>
<p>看了一眼，大概c++的语法。好耶！</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>ALGORITHM</category>
      </categories>
  </entry>
  <entry>
    <title>CCUBE_Chapitre1</title>
    <url>/2022/02/04/CCUBE-01/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>CCUBE: ${C^3}$ est capteurs, contrôle, commande</p>
<span id="more"></span>
<h1 id="Chapitre-0-Preface-et-Objectifs"><a href="#Chapitre-0-Preface-et-Objectifs" class="headerlink" title="Chapitre_0:Préface et Objectifs"></a>Chapitre_0:Préface et Objectifs</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Préface"></a>Préface</h2><p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220204024706.png" alt="img"></p>
<h2 id="Objectifs-et-moyens"><a href="#Objectifs-et-moyens" class="headerlink" title="Objectifs et moyens"></a>Objectifs et moyens</h2><h3 id="教学目标："><a href="#教学目标：" class="headerlink" title="教学目标："></a>教学目标：</h3><p>— échantillonner un signal 信号采样;<br>— en faire une analyse de Fourier 傅里叶分析;<br>— modéliser un système physique continu par le langage des fonctions de transfert 用transfert函数给系统建模;<br>— modéliser un système physique continu par le langage de l’espace d’état 用l’’espace d’état给系统建模;<br>— lier les phénomènes physiques aux paramètres de ces représentations (temps de réponse, stabilité) ;<br>— interfacer le temps continu et le temps discret(离散) ;<br>— simuler(模拟) ces représentations à l’aide de logiciels adaptés.</p>
<h3 id="TP"><a href="#TP" class="headerlink" title="TP"></a>TP</h3><p>使用Matlab的Simulink完成：</p>
<p>1.la reconstruction d’une partition à partir de l’enregistrement audio-phonique ;</p>
<p>2.le pilotage en simulation d’une navette spatiale, version très simplifiée d’un contrat avec l’agence spatiale</p>
<h3 id="前置数学知识"><a href="#前置数学知识" class="headerlink" title="前置数学知识"></a>前置数学知识</h3><p>— les nombres complexes 复数;<br>— la dérivation et l’intégration d’une fonction d’une <strong>variable réelle</strong>（？） à <strong>valeur réelle</strong>（？） 积分求导;<br>— les suites de nombres réels ou complexes ;<br>on n’a pas à craindre les quelques calculs élémentaires de séries ;<br>— le calcul matriciel 矩阵 ;<br>— les valeurs et vecteurs propres, la diagonalisation d’une matrice carrée特征值；</p>
<p>—LTI linéaire temporellement invariant线性时间不变</p>
<h1 id="Chapitre1-Concepts-et-outils-fondamentaux"><a href="#Chapitre1-Concepts-et-outils-fondamentaux" class="headerlink" title="Chapitre1:Concepts et outils fondamentaux"></a>Chapitre1:Concepts et outils fondamentaux</h1><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总有地上的菜鸡，敢于直面大佬的开源</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>CCUBE</category>
      </categories>
  </entry>
  <entry>
    <title>ANG</title>
    <url>/2022/02/06/ANG-01/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>From BBC 6 Minute English.(<a href="https://www.bbc.co.uk/learningenglish/english/features/6-minute-english">https://www.bbc.co.uk/learningenglish/english/features/6-minute-english</a> )</p>
<span id="more"></span>
<h1 id="Welcome-to-the-‘metaverse’"><a href="#Welcome-to-the-‘metaverse’" class="headerlink" title="Welcome to the ‘metaverse’"></a>Welcome to the ‘metaverse’</h1><p>Links：<a href="https://www.bbc.co.uk/learningenglish/english/features/6-minute-english_2022/ep-220106">https://www.bbc.co.uk/learningenglish/english/features/6-minute-english_2022/ep-220106</a></p>
<h2 id="1-5-minutes的introduction"><a href="#1-5-minutes的introduction" class="headerlink" title="1.5 minutes的introduction"></a>1.5 minutes的introduction</h2><p>The topic I chose to talk about is &lt;&lt;<em>Welcome to the ‘metaverse’</em>&gt;&gt;. </p>
<p>So to begin with, what is metavers? According to the video, metaverse means a virtual-reality space in which users can interact with a computer-generated environment and other users. Recently, Facebook announced that it was hiring ten thousand new workers to develop <strong>VR</strong> for the ‘metaverse’, according to  Mark Zuckerberg, the Facebook boss,” in the future we’ll all spend much of our time living and working in the ‘metaverse’ “. But people hold different opinions about it.</p>
<p>Some supporters think it can make a great difference to our living world. They believe that with the technology of  metaverse,  everything that we do on our phone today can be done in 3-D. </p>
<p>But there are also some negative opinions. For example,some people called VR ‘ vomity reality ’,because wearing the headset of VR makes them feel sick, maybe because it’s so <strong>unwieldy</strong> .</p>
<p>From my perspective, I hold a supportive attitude towards this new technology as it seems so cool which can make our world more convenient .</p>
<h2 id="2-new-keywords"><a href="#2-new-keywords" class="headerlink" title="2 new keywords"></a>2 new keywords</h2><p>VR: virtual-reality,a hypothetical three-dimensional visual world created by a computer; user wears special goggles and fiber optic gloves etc., and can enter and move about in this world and interact with objects as if inside it</p>
<p>unwieldy: difficult to move or carry because it’s so heavy, large or strangely shaped</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以元宇宙就是VR? VR OU AR ?</p>
<p>看了一些科普，就是有比较像头号玩家那种世界（或许赛博朋克的那种？。感觉就是，元宇宙感觉是个画大饼的不太实的概念（</p>
<h1 id="Body-language-online"><a href="#Body-language-online" class="headerlink" title="Body language online"></a>Body language online</h1><p>Links: <a href="https://www.bbc.co.uk/learningenglish/english/features/6-minute-english/ep-211209">https://www.bbc.co.uk/learningenglish/english/features/6-minute-english/ep-211209</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The topic I chose to talk about is ‘Body language online’. </p>
<p>As we know, body language is important when we communicate with others. By using some hand gestures and facial expressions, we can make the conversation more natural. But during the Covid <strong>pandemic</strong>,  the communication tend to move online to be video meetings by using software like Zoom and Skype. So, in that case, how has body language changed in the world of online video meetings?</p>
<p>Firstly, eye contact. In face-to-face meetings, we immediately see someone’s reaction to what we’ve said through eye contact, but using a web camera to make eye contact is almost impossible in online meetings and this often creates a kind of ‘distance’ effect.—&gt; ? </p>
<p>Secondly, pause. It was completely normal to have a one-minute pause in a room with one another because we knew when we’re thinking but if we don’t hear someone speak on video, we may ask them if there are some Internet problems.—&gt; Slow down.</p>
<p>Last but not the least, smile or laughing. <em>Erica</em> , a communications expert from the conversation, points out that laughing often happens in <strong>unison</strong>,  so it is much less likely that we laugh and smile on camera. Laughing is often done in unison where we can quickly pick up the energy of someone smiling or laughing and feed off of that and laugh together. When it comes to screen delays, the fact that it’s not natural to see our own camera – being distracted by that – we are much less likely to laugh and smile. —&gt;<strong>Water cooler effect.</strong></p>
<p>That’s all.</p>
<h2 id="New-words"><a href="#New-words" class="headerlink" title="New words"></a>New words</h2><p><strong>Water cooler effect</strong>: it’s an American expression to describe informal conversations between people at work.—&gt; Talk someting informal out of the topic.</p>
<p><strong>In Unison</strong>: it means happening together and at the same time </p>
<p><strong>Pandemic</strong>: 流行病 </p>
<p>noun: a widespread outbreak of an infectious disease and many people are infected at the same time</p>
<p>adjective: existing everywhere</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>ANG</category>
      </categories>
      <tags>
        <tag>metaverse</tag>
        <tag>BBC_6mintues</tag>
      </tags>
  </entry>
  <entry>
    <title>MATHS-TP1</title>
    <url>/2022/02/22/MATH-TP1/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>MATHS_TP1: Initiation Matlab – Equation de la chaleur 1D</p>
<span id="more"></span>
<h1 id="Initiation"><a href="#Initiation" class="headerlink" title="Initiation"></a>Initiation</h1><p>注释：%</p>
<p>显示：disp、fprintf</p>
<p>vecteur: x = [x1,x2……,xn] %空格或者逗号都可以；vecteur colonne</p>
<p>冒号：5：-1：1 %表示5到1以-1为间隔的vecteur</p>
<p>linspace：是Matlab中的均分计算指令，用于产生x1,x2之间的N点行线性的矢量。其中x1、x2、N分别为起始值、终止值、元素个数。若默认N，默认点数为100</p>
]]></content>
      <categories>
        <category>NANTE_S6</category>
        <category>MATHS</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>PRO20</title>
    <url>/2022/02/07/PRO20/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>趁着可能对P2E有点用处的东风，把上学期一个很有意思的softskill给整理了。</p>
<span id="more"></span>
<h1 id="中间"><a href="#中间" class="headerlink" title="中间"></a>中间</h1><p>就是一个教怎么组织项目的课，具体实例是建养鸡场，选址、选鸡蛋品种（bio或者非bio）、然后风险评估啥的。以下是一些有趣的概念的大略整理。</p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Définitions"></a>Définitions</h2><p>Project: Un ensemble de tâches coordonnées accomplies par des personnes utilisant des moyens dans le but de répondre au besoin<br>du client avec la qualité demandée en temps et coûts maitrisés</p>
<p>Gestion de projet: La Gestion de projet s’assure du déroulement opérationnel prévu dans la planification. Elle reporte à la fonction de pilotage de projet sur l’avancement, elle sollicite des prises de décisions et remonte des alertes</p>
<p>Management de projet: Direction + Gestion = Management</p>
<h2 id="Cadrage-框架-du-Project"><a href="#Cadrage-框架-du-Project" class="headerlink" title="Cadrage(框架) du Project"></a>Cadrage(框架) du Project</h2><ul>
<li><p>L’identité du client</p>
</li>
<li><p>Les objectifs du projet</p>
<p>目标应该满足的原则：S(Spécifique)M(Mesurable)A(Atteignable)R(Réaliste)T(Temporel)</p>
</li>
<li><p>Les délais à respecter</p>
</li>
<li><p>Les limites du budget à investir</p>
</li>
<li><p>L’utilité du projet</p>
</li>
<li><p>La rentabilité escomptée du projet</p>
</li>
</ul>
<h2 id="Decomposer-le-projet"><a href="#Decomposer-le-projet" class="headerlink" title="Décomposer le projet"></a>Décomposer le projet</h2><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><p>WBS : Work Breakdown Structure. Décomposition hiérarchique, axée sur les livrables, du travail que l’équipe de projet doit exécuter pour atteindre les objectifs du projet et produire les livrables souhaités.</p>
<p>做法：</p>
<ul>
<li>Spécifier les objectifs du projet</li>
<li>Identifier spécifiquement les produits, services ou résultats </li>
<li>Identifier les travaux</li>
<li>Subdiviser les éléments jusqu’au niveau qui permet la<br>planification et le contrôle</li>
</ul>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207153543.png" alt="img"></p>
<h3 id="PBS"><a href="#PBS" class="headerlink" title="PBS"></a>PBS</h3><p>Product Breakdown Structure</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207215522.png" alt="img" style="zoom:80%;" /></p>
<p>注：当时好像是上课没咋讲这个，后来是按照网上(ZHIHU)的文章说，WBS是以项目结果为导向的工作过程的结构分解，PBS是项目交付结果本身为对象进行的层级结构分解来做的。具体到这道题，就是，WBS包含整个项目管理，PBS只是按照养鸡场本身按照地基、外部建筑、内部建筑、服务设施这样子分级。</p>
<h2 id="Diagramme-de-Gantt"><a href="#Diagramme-de-Gantt" class="headerlink" title="Diagramme de Gantt"></a>Diagramme de Gantt</h2><p>C’est un outil que peut aider à définir un planning réaliste.</p>
<p>貌似就是一个项目的时间的进程表，找出要做的事情，然后分析发生的先后或者并行关系，搞成条状表就行了。</p>
<p>Exemple(红色表示关键事件) : </p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207153744.png" alt="img"></p>
<h2 id="PERT"><a href="#PERT" class="headerlink" title="PERT"></a>PERT</h2><p>C’est un outil souvent utilisée pour la gestion de projets  importants et à long terme. </p>
<p>PERT = Program Evaluation and Review Technic (ou CPM: Critical Path Method)</p>
<p>就是把上面那个Gantt图给这样子表示，然后往里面写时间就行，然后选时间最大的那条线（不是我说，这好像算法里面的那个啥图</p>
<p>Exemple:</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207154725.png" alt="img"></p>
<h2 id="Les-risques"><a href="#Les-risques" class="headerlink" title="Les risques"></a>Les risques</h2><p>Principaux risques  incluent  Risques financiers, Risques marchés, Risques technologiques, Risques liés à l’équipe.</p>
<p> Pour gestion des risques, on peut utiliser le table comme ça,</p>
<p>就是两部分：严重程度+发生概率</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207154820.png" alt="img"></p>
<p>对，记得当时有个文化shock还蛮有趣的小点就是，当时有个风险是员工absent，然后写应对措施，我说搞时刻表，然后其他人：推迟上班的时间或者改变工作环境。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实这个项目还有超级多的东西，当时TD课第一节课搞WBS、PBS和GANTT的图，第二节课搞投资和收益计算，第三节课是风险评估，参与程度递减，到最后一节课就除了汇报叭叭两句就完全没太参与进去，不知道在干嘛了T^T</p>
<p>反正最后结论就是要养bio的鸡，唔。</p>
]]></content>
      <categories>
        <category>NANTE_S5</category>
        <category>PRO20</category>
      </categories>
      <tags>
        <tag>SOFTSKILLS</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTEM_DS</title>
    <url>/2022/01/27/SSTEM-DS/</url>
    <content><![CDATA[<h1 id="SSTEM期末自救"><a href="#SSTEM期末自救" class="headerlink" title="SSTEM期末自救"></a><centre>SSTEM期末自救<centre></h1><span id="more"></span>
<h2 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h2><h3 id="TD1"><a href="#TD1" class="headerlink" title="TD1"></a>TD1</h3><h3 id="Question-Apres-avoir-defini-les-differentes-parties-prenantes-du-Systeme-identifiez-les-differentes-utilisations-et-modelisez-les-sous-forme-d’un-diagramme-des-cas-d’utilisation"><a href="#Question-Apres-avoir-defini-les-differentes-parties-prenantes-du-Systeme-identifiez-les-differentes-utilisations-et-modelisez-les-sous-forme-d’un-diagramme-des-cas-d’utilisation" class="headerlink" title="Question: Après avoir défini les différentes parties prenantes du Système, identifiez les différentes utilisations et modélisez les sous forme d’un diagramme des cas d’utilisation"></a>Question: Après avoir <strong>défini les différentes parties prenantes</strong> du Système, identifiez les différentes utilisations et modélisez les sous forme d’<strong>un diagramme des cas d’utilisation</strong></h3><p>Diagramme des cas d’utilisation 的 étape:</p>
<ol>
<li><p>Finalité,Missions,Objectifs(套话)</p>
<p>Finalité: <strong><em>Assurer le fonctionnement des systèmes d</em></strong>‘information de réseau ferroviaire.</p>
<p>Missions:具体任务，得在问题中找，可能用到的词：définir,assurer,informer</p>
<p>Objectifs: <strong><em>Pendre des dispositions raisonnable pour tous les</em></strong> trains grace <strong><em>à la coopération mutuelle entre</em></strong> [……]</p>
</li>
<li><p>Les parties prenantes</p>
<p>找实体，可以画个方框图</p>
<p>comme ca：</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220127160428.png" alt="img"></p>
</li>
<li><p>Les cas d’utilisation</p>
<p>画小人图</p>
<p>一些值得注意的点：方框+标题，拓展的include和extend(都是虚箭头画的)</p>
<p>include: Celles qui sont incluses dans une action existante —-&gt;obligatoirement,一定被执行</p>
<p>​                1.任务与子任务</p>
<p>​                2.小人的任务与任务间</p>
<p>extend: Celles qui étendent une action existante—&gt;éventuellement,可能被执行</p>
</li>
<li><p>Les interfaces</p>
<p>随缘</p>
</li>
</ol>
<h3 id="TD2"><a href="#TD2" class="headerlink" title="TD2"></a>TD2</h3><p>Question:</p>
<h4 id="1-Identifier-les-parties-prenantes-et-leur-role-dans-ce-processus"><a href="#1-Identifier-les-parties-prenantes-et-leur-role-dans-ce-processus" class="headerlink" title="1.Identifier les parties prenantes et leur rôle dans ce processus"></a>1.Identifier les parties prenantes et leur rôle dans ce processus</h4><p>关键是区分<strong>ACTEUR</strong> OU <strong>COLLABORATEUR</strong>—&gt;看是否有开启或者终止活动</p>
<p>然后在行为中找出触发事件(<strong>Délencheur</strong>)和终止事件(<strong>Final</strong>)</p>
<p>可能用到的一些词：envoyer,refuse,annulation,verifier</p>
<h4 id="2-Modeliser-ce-processus-en-BPMN"><a href="#2-Modeliser-ce-processus-en-BPMN" class="headerlink" title="2. Modéliser ce processus en BPMN"></a>2. Modéliser ce processus en BPMN</h4><p>表示判断：sinon,valide</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220127162932.png" alt="img"></p>
<p>表示发信：envoyer,demande</p>
<p>表示收信：recevoir</p>
<p><img src="C:\Users\nili990221\AppData\Roaming\Typora\typora-user-images\image-20220127163018343.png" alt="image-20220127163018343"></p>
<p>终止和起始：都是空心圆但终止的要粗一点</p>
<h3 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h3><p>Question:</p>
<h4 id="1-Concevoir-le-diagramme-Entites-Associations-de-ce-systeme"><a href="#1-Concevoir-le-diagramme-Entites-Associations-de-ce-systeme" class="headerlink" title="1.Concevoir le diagramme Entités-Associations de ce système."></a>1.Concevoir le diagramme Entités-Associations de ce système.</h4><p>​        画<strong><em>ER</em></strong>图等价于画<strong><em>MCD</em></strong>: Modèle Conceptuel des Données(概念模型)</p>
<p>ER(MCD):主体+关系+实体与关系的比</p>
<ol>
<li><p>objet &lt;=&gt;entité</p>
<p>Propriété &lt;=&gt;attribut，属性，列</p>
<p>没有外键</p>
</li>
<li><p>lien &lt;=&gt;association</p>
<p>记得加比例，关于比例—&gt;est le lien entre l’entité et l’association</p>
<p>是minimum+maximum</p>
<p>minimum:0:peut ne pas apparaître</p>
<p>​                   1:doit apparaître</p>
<p>maximum:1:ne peut pas apparaître plus d’une fois</p>
<p>​                     n:peut apparaître plusieurs fois</p>
</li>
</ol>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220127170205.png" alt="img"></p>
<p>一些典型的关系及其比例：être: chefdegare和être是1:1，être和personne是0:1</p>
<p>​                                              detype: salle和detype是1:1,detype和typedesalle是0:n</p>
<p>TD3的2到5题是对ER的评价和补充，暂时不想展开看（TO BE ADDED）</p>
<h3 id="TD4"><a href="#TD4" class="headerlink" title="TD4"></a>TD4</h3><p>Question: Cet exercice s’appuie sur la modélisation de gestion de réseau ferroviaire mis en place lors des TDs précédents. Il a pour but de pratiquer SQL à travers l’écriture d’un certain nombre de requêtes. Le MCD utilisé est joint ci-dessous.</p>
<h4 id="1-A-partir-du-MCD-mettre-en-oeuvre-le-modele-physique-de-la-base-de-donnees-MPD"><a href="#1-A-partir-du-MCD-mettre-en-oeuvre-le-modele-physique-de-la-base-de-donnees-MPD" class="headerlink" title="1.À partir du MCD, mettre en oeuvre le modèle physique de la base de données (MPD)"></a>1.À partir du MCD, mettre en oeuvre le modèle physique de la base de données (MPD)</h4><p>逻辑模型<strong><em>MLD</em></strong>: Modèle logiques与物理模型<strong><em>MPD</em></strong>: Modèle physiques：物理模型有数据类型</p>
<p>MPD:含实体的外键+箭头+数据类型</p>
<ol>
<li><p>实体</p>
<p>标出主键（PK）与<strong>外键</strong>（FK）</p>
</li>
<li><p>箭头</p>
<p>箭头指向：从表指向主表的外键所在的位置</p>
<p>从表：以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询.<br>箭头：从表外键➡️主表</p>
</li>
<li><p>数据类型</p>
<p>integer/float</p>
<p>character varying(256/128)</p>
<p>date/datetime/timestamp</p>
</li>
</ol>
<h4 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h4><p>基本语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">DISTINCT</span>) 列名 </span><br><span class="line"><span class="keyword">FROM</span> 表名 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span>: <span class="number">1.</span><span class="built_in">UPPER</span>(Nom) <span class="keyword">LIKE</span> <span class="string">&#x27;%TER%&#x27;</span></span><br><span class="line">	   <span class="number">2.</span><span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span><span class="operator">/</span><span class="keyword">MONTH</span><span class="operator">/</span>DOW<span class="operator">/</span><span class="keyword">HOUR</span><span class="operator">/</span>MINUTES  <span class="keyword">FROM</span> 表名)<span class="operator">=</span>……</span><br></pre></td></tr></table></figure>
<h3 id="TD5"><a href="#TD5" class="headerlink" title="TD5"></a>TD5</h3><h4 id="1-表的创建"><a href="#1-表的创建" class="headerlink" title="1.表的创建"></a>1.表的创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">(</span><br><span class="line">    列名  数据类型  <span class="keyword">PRIMARY</span> KEY<span class="operator">/</span><span class="keyword">NOT</span> <span class="keyword">NULL</span><span class="operator">/</span>或其他</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--联合主键</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">PRIMARY</span> KEY(列名<span class="number">1</span>,列名<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--外键约束</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> 约束名</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(外键名)</span><br><span class="line">    <span class="keyword">REFERENCES</span> 表名(外键名)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">    <span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="2-表的增删改"><a href="#2-表的增删改" class="headerlink" title="2.表的增删改"></a>2.表的增删改</h4><ol>
<li><p>INSERT</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">--若插入的列为空，写NULL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="comment">--where里面写查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--EXMPLE</span></span><br><span class="line"><span class="keyword">WHERE</span> trajet_id <span class="keyword">in</span> </span><br><span class="line">			(<span class="keyword">SELECT</span> trajet_id <span class="keyword">FROM</span> arret </span><br><span class="line"> 			<span class="keyword">WHERE</span> <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> arret_horaireprevu) <span class="operator">=</span> <span class="number">2016</span> <span class="keyword">AND</span> </span><br><span class="line"> 			<span class="built_in">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> arret_horaireprevu) <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> </span><br><span class="line"> 			<span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> arret_horaireprevu) <span class="operator">&lt;</span> <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>UPDATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE 表名</span><br><span class="line"><span class="keyword">SET</span> 列名</span><br><span class="line"><span class="keyword">WHERE</span> ……</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="TP"><a href="#TP" class="headerlink" title="TP"></a>TP</h2><h3 id="TP1"><a href="#TP1" class="headerlink" title="TP1"></a>TP1</h3><p>查询工作SELECT</p>
<p>1.UNION SELECT: Donner la/les fonction(s) de Yvon Manac’h</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Mecanicien&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> Mecanicien <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Personne </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(Personne_Nom) <span class="operator">=</span> <span class="string">&#x27;MANAC&#x27;&#x27;H&#x27;</span> <span class="keyword">AND</span> <span class="built_in">UPPER</span>(Personne_Prenom) <span class="operator">=</span> <span class="string">&#x27;YVON&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Agent&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> Agent <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Personne </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(Personne_Nom) <span class="operator">=</span> <span class="string">&#x27;MANAC&#x27;&#x27;H&#x27;</span> <span class="keyword">AND</span> <span class="built_in">UPPER</span>(Personne_Prenom) <span class="operator">=</span> <span class="string">&#x27;YVON&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Conducteur&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> Conducteur <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Personne </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(Personne_Nom) <span class="operator">=</span> <span class="string">&#x27;MANAC&#x27;&#x27;H&#x27;</span> <span class="keyword">AND</span> <span class="built_in">UPPER</span>(Personne_Prenom) <span class="operator">=</span> <span class="string">&#x27;YVON&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="string">&#x27;ChefDeGare&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> ChefDeGare <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Personne</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(Personne_Nom) <span class="operator">=</span> <span class="string">&#x27;MANAC&#x27;&#x27;H&#x27;</span> <span class="keyword">AND</span> <span class="built_in">UPPER</span>(Personne_Prenom) <span class="operator">=</span> <span class="string">&#x27;YVON&#x27;</span></span><br></pre></td></tr></table></figure>
<p>2.嵌套查询:Donner les horaires en gare de Nantes, pour les trains qui relient Nantes à Lyon pour la journée de demain. En pratique, on regardera quels trajets s’arrêtent à Nantes et Lyon. Attention, les gares de Lyon ne s’appellent pas ‘Gare de Lyon’ mais comporte Lyon dans leur nom.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> train_id,trajet_id,arret_horaireprevu</span><br><span class="line"><span class="keyword">FROM</span> train <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> trajet <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> arret</span><br><span class="line"><span class="keyword">WHERE</span> trajet_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> trajet_id</span><br><span class="line">	<span class="keyword">FROM</span> train <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> trajet <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> arret</span><br><span class="line">	<span class="keyword">WHERE</span> arret_horaireprevu <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-12-21 00:00:00&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-21 23:59:59&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">	  	  <span class="built_in">UPPER</span>(gare_abrege) <span class="keyword">LIKE</span> <span class="string">&#x27;%NANTES%&#x27;</span></span><br><span class="line">	<span class="keyword">INTERSECT</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> trajet_id</span><br><span class="line">			  <span class="keyword">FROM</span> train <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> trajet <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> arret</span><br><span class="line">			  <span class="keyword">WHERE</span> arret_horaireprevu <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-12-21 00:00:00&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-21 23:59:59&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">					<span class="built_in">UPPER</span>(gare_abrege) <span class="keyword">LIKE</span> <span class="string">&#x27;%LYON%&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> arret_horaireprevu</span><br><span class="line"></span><br><span class="line"><span class="comment">--关于intersect:取交集--&gt;并集：union,差集：except</span></span><br></pre></td></tr></table></figure>
<h3 id="TP2"><a href="#TP2" class="headerlink" title="TP2"></a>TP2</h3><p>继续写select(聚集函数)</p>
<p>1.Combien y a-t-il de conducteurs dans la base ? </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="comment">--COUNT(*)拿来统计列</span></span><br><span class="line"><span class="keyword">FROM</span> conducteur</span><br></pre></td></tr></table></figure>
<p>2.De combien de gare chaque chef de gare est-il responsable? </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> personne_nom,personne_prenom,personne_id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> gare <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> chefdegare <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> personne <span class="keyword">GROUP</span> <span class="keyword">BY</span> personne_nom,personne_prenom,personne_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> count</span><br></pre></td></tr></table></figure>
<p>注意点：GROUP BY上写除函数之外的所有的select,聚集函数后可以直接命名，comme ca</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220127180520.png" alt="img"></p>
<p>3.MAX、AVG</p>
<h3 id="TP3"><a href="#TP3" class="headerlink" title="TP3"></a>TP3</h3><p>SELECT + 导出PDF</p>
<p>Générez un document, nommé rapport05.pdf, avec la liste des 5 propriétaires possédant les plus grandes superficies,<br>triés en ordre décroissant des sommes de superficie de terrain qu’ils possèdent. On utilisera pour cela la fonction <strong>ST_AREA</strong>（算面积使用）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> personne_nom,<span class="built_in">SUM</span>(ST_AREA(parcelle_geometry)) <span class="keyword">AS</span> area,<span class="built_in">COUNT</span>(parcelle_id)</span><br><span class="line"><span class="keyword">FROM</span> culture <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> parcelle <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> appartient <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> personne</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> personne_nom</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> area <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<h2 id="PROJECT"><a href="#PROJECT" class="headerlink" title="PROJECT"></a>PROJECT</h2><p>TD6&amp;7 et TP 4&amp;5</p>
]]></content>
      <categories>
        <category>NANTE_S5</category>
        <category>SSTEM</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>Voyage-Paris</title>
    <url>/2021/12/08/Voyage-Paris/</url>
    <content><![CDATA[<h1 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h1><p>铁塔$\longrightarrow$迪士尼$\longrightarrow$卢浮宫$\longrightarrow$奥赛$\longrightarrow$先贤祠</p>
<span id="more"></span>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>下午到的</p>
<p>铁塔上看的夕阳</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201224029.png" alt="img"></p>
<p>超好看！</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/png/20211209000220.png" alt="img"></p>
<p>顺便打卡盗梦空间的桥</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223509.png" alt="img"></p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>迪士尼好玩的</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223552.png" alt="img"></p>
<p>未来的日子永远爱跳跳虎</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>卢浮宫真的好大就是说</p>
<p>法国斥巨资修建这座宫殿或许比里面的展品还要了不起。</p>
<p>雕塑真的好厉害。</p>
<p>伊斯兰教的艺术印象蛮深。</p>
<p>然后镇馆三宝打卡成功：维纳斯、蒙娜丽莎、胜利女神</p>
<center class="half">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223807.png"width="200"/>
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223713.png" width="200"/>
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223655.png" width="200"/>
</center>



<p>画的话，宗教类、宫廷很多。一开始很震撼，看多了，嗯，装不下。</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>奥赛博物馆的话就是好看的画</p>
<p>梵高好看</p>
<p>莫奈也好好看</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223903.png" alt="img"></p>
<p>还有个点彩画派</p>
<p>很喜欢的画买了明信片但忘记画家了T^T</p>
<p>出来时的公园，好看到分不清是不是在画中</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201223951.png" alt="img"></p>
<p>（或许还记得出来一家商店里面的9000欧的衣服？</p>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>先贤祠</p>
<p>外面比里面好看</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201224001.png" alt="img"></p>
<p>只记得里面的钟摆了</p>
<p>看到了一群穿正装的未来大佬们</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201224010.png" alt="img"></p>
<p>听说隔壁是很法国很厉害的大学</p>
<p>站在那里真的会有</p>
<p>一种学术的</p>
<p>很厉害的感觉</p>
<p>听说建筑仿的是意大利的万神庙</p>
<p>那就正好</p>
<h1 id="下一站"><a href="#下一站" class="headerlink" title="下一站"></a>下一站</h1><p>意大利！</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>巴黎再会~</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201224046.png" alt="img"></p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201224018.png" alt="img"></p>
]]></content>
      <categories>
        <category>生活区</category>
        <category>Voyage</category>
      </categories>
      <tags>
        <tag>Paris</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTEM01</title>
    <url>/2021/12/06/SSTEM01/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>介绍SysML和其简单应用,对TD1的内容进行简单的总结与归纳。</p>
<span id="more"></span>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>SysML: un <u>outil</u> pour modéliser les Systèmes</p>
<p>But: Analyse et description des systèmes( Besoin, Description de sous-systèmes, Chîne d’information)</p>
<p>But pour cet TD: Analyse externe d’un systèmes</p>
<h1 id="Etape（以exemples进行更好说明）"><a href="#Etape（以exemples进行更好说明）" class="headerlink" title="Etape（以exemples进行更好说明）"></a>Etape（以exemples进行更好说明）</h1><h2 id="0-Exemples"><a href="#0-Exemples" class="headerlink" title="0.Exemples"></a>0.Exemples</h2><p>Analyse externe d’un <u>radio-réveil</u>.</p>
<h2 id="1-Identification-de-la-finalite-des-missions-et-objectifs-du-systeme"><a href="#1-Identification-de-la-finalite-des-missions-et-objectifs-du-systeme" class="headerlink" title="1.Identification de la finalité des  missions et objectifs du système"></a>1.Identification de la <em>finalité</em> des  <em>missions</em> et <em>objectifs</em> du système</h2><p>​    <strong>finalité</strong>: Qu’est-ce qu’<u>apporte</u> le Système?à quoi <u>sert</u>-il?</p>
<p>​    <strong>missions:</strong> Comment le Système contribue-t-il à la <strong>finalité</strong>. Sur quels principes reposent la <u>mise</u> en <u>oeuvre</u> de la finalité?</p>
<p>​    <strong>objectifs:</strong> Comment le Système met-il en oeuvre ses <strong>missions</strong>?</p>
<p><strong>Exemples:</strong></p>
<p>​    <strong>finalité</strong>: réveiller une personne endormie</p>
<p>​    <strong>missions:</strong>  réveiller l’utilisateur à l’aide d’un signal sonore  (bip ou radio choisie) à une heure prédéfinie. <u>Diffuser</u> le signal sonore émit par une station  radio.</p>
<p>​    <strong>objectifs:</strong> Émettre un son suffisamment fort pour le réveil (ex: &gt;  90db).</p>
<h2 id="2-Identification-de-interacteurs-ou-parties-prenantes-du-systeme"><a href="#2-Identification-de-interacteurs-ou-parties-prenantes-du-systeme" class="headerlink" title="2.Identification de interacteurs ou parties prenantes du système"></a>2.Identification de <em>interacteurs</em> ou <em>parties prenantes</em> du système</h2><ul>
<li><p><strong>Faire une liste des parties prenantes:</strong> les éléments qui sont relies au Systèmes (systèmes physiques, personnes…) via une action sur ce système.</p>
<p><strong>Note:</strong> Les <strong>éléments interne</strong> du Système <strong>ne font pas</strong> partie des ‘parties prenantes’</p>
<p><strong>Exemples:</strong></p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202115864.png" alt="img"></p>
</li>
<li><p><strong>Faire un diagramme de bloc</strong></p>
<p>Le système est placé au centre du <u>schéma</u>.</p>
<p>Il est relié aux parties prenantes.</p>
<p>Sur le lien, on peut faire <u>figurer</u> la nature du lien</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202143042.png" alt="img"></p>
</li>
</ul>
<h2 id="3-Les-cas-d’utilisation"><a href="#3-Les-cas-d’utilisation" class="headerlink" title="3.Les  cas d’utilisation"></a>3.Les  cas d’utilisation</h2><p>Le cycle de vie du Système peut comporter: <u>conception, implémentation, implémentation, utilisation, démantèlement, recyclage</u>.</p>
<p>​    <strong>Règles de dessin</strong></p>
<ul>
<li><p>Les parties prenantes qui utilisent ou ont une action sur le Système seront représentées comme des <strong>acteurs</strong>, <em>un petit bonhomme</em></p>
</li>
<li><p>Le Système est représenté comme <em>un bloc</em></p>
</li>
<li><p>Dans le bloc figurent les <strong>actions(fonctionnalités) que peuvent faire les acteurs</strong>. Elles sont représentées par une <em>ellipse</em>.</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202233671.png" alt="img"></p>
</li>
<li><p>Dans le bloc, on doit dessiner les actions importantes et les liaisons entre les actions.</p>
<p>2 types: extend, include(<u>obligatoirement</u>).</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202213800.png" alt="img"></p>
</li>
</ul>
<h2 id="4-Les-interfaces"><a href="#4-Les-interfaces" class="headerlink" title="4.Les interfaces"></a>4.Les interfaces</h2><p>Certaines des parties prenantes alimentent/sont alimentées par le Système. Pour chacune d’elle, on peut définir le/les <u>flux</u>(matière-énergie-information) qui sont échangés.</p>
<p>​    <strong>Règles de dessin</strong></p>
<ul>
<li><p>Le système est un bloc au centre du <u>schéma.</u></p>
</li>
<li><p>Les <u>flux</u> entrants et sortants du système sont indiqués par des boites de connexion sur le bord du bloc central.</p>
</li>
<li><p>Les flux sont également décrits par des boites sur le coté du diagramme.</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202258612.png" alt="img"></p>
</li>
</ul>
<h1 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h1><p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202704990.png" alt="img"></p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/image-20211205202724279.png" alt="img"></p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20211206205312.png" alt="img"></p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20211206205403.png" alt="img"></p>
<p>TD1小结：用学长的拼拼凑凑的搞上去的，但自己的第一次思考并没有把finalité,missions,objectif给找好。在理解上存在偏差。希望之后能够有所改进</p>
<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><p>Outil:工具</p>
<p>Radio-réveil:收音机闹钟</p>
<p>Sert:服务、帮助</p>
<p>Apporte：带来，提供</p>
<p>Mise:安装</p>
<p>oeuvre:工作</p>
<p>Diffuser:扩散、传播</p>
<p>Schéma:图解、提纲</p>
<p>Figurer:画出、代表</p>
<p>conception, implémentation, implémentation, utilisation, démantèlement, recyclage：设计，实施，实施，使用，拆卸，回收。</p>
<p>Flux:流动</p>
<p>Obligatoirement：必须的</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>来法国后的第一篇博客真的太多想说了的。（虽然在国内也没写几篇</p>
<p>首先就是上这节课的那天下午是流体的期末，所以对课上很多内容都不知道，包括TD1的实例，也有其他许多待修正的部分。</p>
<p>其次就是很多地方都是照搬的PPT，没有起到一个很好的总结和思考。</p>
<p>这篇博客完成的也是磕磕绊绊，对法语键盘的不熟悉（比如打不出oe和^i)和法语的不熟悉。</p>
<p>最后的最后，希望自己坚持下去，做好记录，出现越来越少不认识的单词和行文中越来越少的中文。</p>
<p>就祝自己能以此为新开始，用Blog的形式见证我在南特这两年的跌跌撞撞的成长。</p>
]]></content>
      <categories>
        <category>NANTE_S5</category>
        <category>SSTEM</category>
      </categories>
      <tags>
        <tag>SysML</tag>
      </tags>
  </entry>
  <entry>
    <title>Voyage-Italie</title>
    <url>/2022/02/01/Voyage-Italie/</url>
    <content><![CDATA[<h1 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h1><p>马耳他$\longrightarrow$罗马$\longrightarrow$米兰</p>
<span id="more"></span>
<h1 id="马耳他"><a href="#马耳他" class="headerlink" title="马耳他"></a>马耳他</h1><p>好看！</p>
<p>看到海就真的超级开心</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201231830.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201231634.png" height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201231445.png" height="200">
    </div>



<p>能在这个岛上过暑假的小孩应该很幸福吧</p>
<p>但就是住的好远（晕车真的难顶</p>
<p>体验了壁炉和烤鸡</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201231721.png"width=40%><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201232158.png" width=40%>
</div>




<p>还有偷偷摘下来的仙人掌的果</p>
<p>整体风格蛮中东的</p>
<p>但又特别电影</p>
<p>穷途末路的英雄的流浪故事</p>
<p>碰到的司机大叔也人超级好</p>
<p>希望这两年间能再去一次</p>
<p>带着夏企和橘子汽水</p>
<p>想念夏天</p>
<h1 id="罗马"><a href="#罗马" class="headerlink" title="罗马"></a>罗马</h1><p>西班牙台阶$\longrightarrow$总统府（？maybe）$\longrightarrow$圣天使堡$\longrightarrow$梵蒂冈$\longrightarrow$万神庙$\longrightarrow$斗兽场$\longrightarrow$什么祭坛</p>
<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p>西班牙台阶，总统府和一个喷泉</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234600.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234616.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234815.png"height="200">   </div>


<p>夕阳好看！</p>
<p>龙虾意面好吃！</p>
<p>冰淇淋好吃！</p>
<div align="center">
     <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234928.png" height="200">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234943.png" height="200">
      <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201234958.png" height="200">
    </div>




<h2 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a>DAY2</h2><p>圣天使堡+法院+梵蒂冈+万神庙</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235138.png"width="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235129.png" width="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235447.png" width="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235151.png" width="200">
    </div>



<p>夕阳好看！</p>
<p>在梵蒂冈被骗了10欧QAQ</p>
<p>但暴走了两次不亏！（Cappella Sistina</p>
<p>看到了前前前手机壁纸，开心</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235204.png" alt="img"></p>
<h2 id="DAY3"><a href="#DAY3" class="headerlink" title="DAY3"></a>DAY3</h2><p>斗兽场+祭坛</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235423.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201235732.png" height="200">
</div>


<p>中餐好吃！</p>
<p>臭鸟拉屎（猖狂到当地老太太会打伞的程度，可恶</p>
<h1 id="米兰"><a href="#米兰" class="headerlink" title="米兰"></a>米兰</h1><p>个人不官方的宣布</p>
<p>米兰就是旅游荒漠</p>
<p>只就去了大教堂，然后有猥琐的偷偷喂鸽子</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201230627.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201230643.png" height="200">
</div>


<p>但是！</p>
<p>米兰火锅！好好吃！店名：“巴倒辣”。人生建议：不能点中辣不能点中辣不能点中辣！（上次被辣成瓜娃子还是在重庆的时候了</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201230545.png" alt="img"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虽然没去佛罗伦萨和威尼斯，但得歇一段时间不看人文类风光啦~</p>
<p>意大利再见﻿ε≡٩(๑&gt;₃&lt;)۶ </p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201230618.png" alt="img"></p>
]]></content>
      <categories>
        <category>生活区</category>
        <category>Voyage</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm-绪论</title>
    <url>/2021/12/06/algorithm01/</url>
    <content><![CDATA[<h1 id="算法-第一章-绪论"><a href="#算法-第一章-绪论" class="headerlink" title="算法_第一章__绪论"></a>算法_第一章__绪论</h1><span id="more"></span>
<h2 id="1-算法的五大特征"><a href="#1-算法的五大特征" class="headerlink" title="1.算法的五大特征"></a>1.算法的五大特征</h2><p>输入、输出、确定性、有穷性、可行性</p>
<h2 id="2-算法的描述方法"><a href="#2-算法的描述方法" class="headerlink" title="2.算法的描述方法"></a>2.算法的描述方法</h2><ul>
<li>自然语言描述</li>
<li>流程描述</li>
<li>伪代码描述</li>
</ul>
<h2 id="3-算法的重要问题"><a href="#3-算法的重要问题" class="headerlink" title="3.算法的重要问题"></a>3.算法的重要问题</h2><p>排序、查找、字符串匹配、图问题、组合问题、几何问题、数值问题</p>
<h2 id="4-算法基本的数据结构"><a href="#4-算法基本的数据结构" class="headerlink" title="4.算法基本的数据结构"></a>4.算法基本的数据结构</h2><p>线性结构、数结构、图结构、集合</p>
<h2 id="5-算法设计的方法策略"><a href="#5-算法设计的方法策略" class="headerlink" title="5.算法设计的方法策略"></a>5.算法设计的方法策略</h2><p>蛮力法、递归与分治、动态规划、贪心算法、回溯与分治</p>
]]></content>
      <categories>
        <category>SWJTU</category>
        <category>ALGORITHM</category>
      </categories>
      <tags>
        <tag>ALGORITHM</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>那些细碎而美好的存在</title>
    <url>/2022/02/01/%E7%BB%86%E7%A2%8E%E8%80%8C%E7%BE%8E%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>一个持续更新的日常记录</p>
<span id="more"></span>
<h1 id="2022-2-1"><a href="#2022-2-1" class="headerlink" title="2022_2_1"></a>2022_2_1</h1><p>我画画真好看，嘿嘿</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201221428.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201221611.png" height="200">
    </div>



<p>以及，新的学期新的摸鱼</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220201221742.png" alt="img" style="zoom:50%;" /></p>
<h1 id="2022-2-2"><a href="#2022-2-2" class="headerlink" title="2022_2_2"></a>2022_2_2</h1><p>-经过一天的讨论，滑雪假兜兜转转起起伏伏，最终成为了和学长一起的法国自驾游（开心期待</p>
<p>-希望快点长大到可以开着车向着随机方向选择随机地点随机停留的那天</p>
<p>-莫名其妙的去测了MBTI，第三次了吧，真的好神奇，还是INFJ，从高考填志愿到大一再到今天，前辈们留下的东西是真的太厉害了。</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220202235702.png"height="200">    </div>
# 2022_2_3

安然给的国家爸爸发的大白兔，四舍五入我也收到大使馆的春节礼物啦

<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207223907.png"height="200">    </div>

<h1 id="2022-2-4"><a href="#2022-2-4" class="headerlink" title="2022_2_4"></a>2022_2_4</h1><p>很难不记录</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220204154934.png"height="200">    </div>

<h1 id="2022-2-7"><a href="#2022-2-7" class="headerlink" title="2022_2_7"></a>2022_2_7</h1><p>周六周末没有学习，可恶</p>
<p>看到一个好有意思的财神爷饭，周五做给大家吃，期待复刻，嘿嘿</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220207223313.png"height="200">    </div>

<h1 id="2022-2-9"><a href="#2022-2-9" class="headerlink" title="2022_2_9"></a>2022_2_9</h1><p>关于财神饭的复刻,成功!</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220211191730.png"height="200">    </div>

<h1 id="2022-2-10"><a href="#2022-2-10" class="headerlink" title="2022_2_10"></a>2022_2_10</h1><p>谷爱凌nb！！！！！以及抓住摸鱼的zwl子</p>
<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220211191929.png"height="200"> <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220211192132.png"height="200">    </div>
# 2022_2_11

摸了一个谷爱凌和意外好吃的番茄牛奶辣椒粥

<div align="center">
    <img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220213210356.png"height="200"><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220213210423.png" height="200">
    </div>

<h1 id="2022-2-12"><a href="#2022-2-12" class="headerlink" title="2022_2_12"></a>2022_2_12</h1><p>旅行途中遇到的可可爱爱的善意们</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220213210228.png" alt="img" style="zoom:50%;" /></p>
<h1 id="2022-2-21"><a href="#2022-2-21" class="headerlink" title="2022_2_21"></a>2022_2_21</h1><p>春天来了</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220307224454.png" alt="img"  /></p>
<h1 id="2022-3-4"><a href="#2022-3-4" class="headerlink" title="2022_3_4"></a>2022_3_4</h1><p>可以做梦不补考吗(靓女流泪</p>
<h1 id="2022-3-7"><a href="#2022-3-7" class="headerlink" title="2022_3_7"></a>2022_3_7</h1><p>好好听</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/jpg/20220307224135.png" alt="img"  /></p>
]]></content>
      <categories>
        <category>生活区</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>序言</title>
    <url>/2021/12/05/hello-world/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>太晚了，明天写。</p>
<p>截断测试</p>
<span id="more"></span>
<p>图片测试：</p>
<p><img src="https://gitee.com/nililili7876/blog_nantes/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202112041747093.jpg" alt="img"></p>
<p>数学公式测试</p>
<script type="math/tex; mode=display">T(n)=\sum_i C_{opi} * C_i(n)</script><p>公式测试2</p>
<script type="math/tex; mode=display">
T(n)=\sum_i C_{opi} * C_i(n)</script><p>Flags：</p>
<p>侧边栏多级分类</p>
<p>FLUID整理</p>
<p>Pro20整理</p>
<p>SSTEM一周一记</p>
]]></content>
      <categories>
        <category>生活区</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
